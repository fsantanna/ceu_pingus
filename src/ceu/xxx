#!/usr/bin/env lua

--[[
-- This file is automatically generated.
-- Check the github repository for a readable version:
-- http://github.com/fsantanna/ceu
--
-- Céu is distributed under the MIT License:
--

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--
--]]

FILES = {
    ceu_types_h =
        [====[
#ifndef _CEU_TYPES_H
#define _CEU_TYPES_H

#include <stdint.h>

#ifdef __LP64__
typedef unsigned long word;
#else
typedef unsigned int  word;
#endif
typedef unsigned int  uint;
typedef unsigned char byte;
#ifndef __cplusplus
typedef unsigned char bool;
#endif

typedef int64_t  s64;
typedef int32_t  s32;
typedef int16_t  s16;
typedef int8_t    s8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t   u8;

typedef float    f32;
typedef double   f64;

#endif
]====],
    template_h =
        [====[
#ifndef === DEFS_H ===
#define === DEFS_H ===

#include "ceu_types.h"

=== DEFINES ===     /* CEU_EXTS, CEU_WCLOCKS, CEU_INTS, ... */

/* TODO: lbl => unsigned */
#ifndef CEU_OS
typedef === TCEU_NLBL === tceu_nlbl;
#endif

#ifdef CEU_IFCS
/* (x) number of different classes */
typedef === TCEU_NCLS === tceu_ncls;
#endif

/* TODO: remove */
#define CEU_NTRAILS === CEU_NTRAILS ===

#include "ceu_os.h"

=== NATIVE_PRE ===
=== EVENTS ===      /* CEU_IN_, CEU_OUT_ */
=== FUNCTIONS ===   /* CEU_FUN_ */
=== TUPLES ===

/* class definitions */
/*
// TODO: host language to have access to classes
=== CLSS_DEFS ===
*/

#endif
]====],
    template_c =
        [====[
#line 1 "=== FILENAME ==="

=== OUT_H ===
#include "ceu_os.h"

#include <stdlib.h>
#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#include <signal.h>     /* signal */
#endif
#ifdef CEU_RUNTESTS
#include <string.h>     /* memset */
#endif

#ifdef CEU_THREADS
#   define CEU_ATOMIC(f)                                      \
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex); \
                f                                             \
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
#else
#   define CEU_ATOMIC(f) f
#endif

#ifdef CEU_NEWS_POOL
#include "ceu_pool.h"
#endif

#ifdef CEU_IFCS
#include <stddef.h>
/* TODO: === direto? */
#define CEU_NCLS       (=== CEU_NCLS ===)
#endif

/* native code from the Main class */
=== NATIVE ===

/* class/adts definitions */
/* may use types defined above in "NATIVE" */
/* each class may define new native code that appear after its struct declaration */
=== TOPS_DEFS ===

/* goto labels */
enum {
=== LABELS_ENUM ===
};

typedef struct {
#ifdef CEU_IFCS
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    s8        ifcs_clss[CEU_NCLS][=== IFCS_NIFCS ===];
            /* Does "cls" implements "ifc?"
             * (I*) ifc = (I*) cls;     // returns null if not
             * TODO(ram): bitfield
             */

    u16       ifcs_flds[CEU_NCLS][=== IFCS_NFLDS ===];
    u16       ifcs_evts[CEU_NCLS][=== IFCS_NEVTS ===];
    void*     ifcs_funs[CEU_NCLS][=== IFCS_NFUNS ===];
#endif
} _tceu_app;

/* TODO: remove from RAM */
static _tceu_app _CEU_APP = {
#ifdef CEU_IFCS
#ifdef CEU_OS_APP
#error remove from RAM!
#endif
    {
=== IFCS_CLSS ===
    },
    {
=== IFCS_FLDS ===
    },
    {
=== IFCS_EVTS ===
    },
    {
=== IFCS_FUNS ===
    }
#endif
};

/**********************************************************************/

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
tceu_app* CEU_APP_SIG = NULL;
static void ceu_segfault (int sig_num) {
#ifdef CEU_ORGS
    printf("SEGFAULT on %p : %d\n", CEU_APP_SIG->lst.org, CEU_APP_SIG->lst.lbl);
#else
    printf("SEGFAULT on %d\n", CEU_APP_SIG->lst.lbl);
#endif
    exit(0);
}
#endif
#endif

#ifdef CEU_RUNTESTS
static void ceu_stack_clr () {
    int a[1000];
    memset(a, 0, sizeof(a));
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS
=== PRES_C ===
#endif

#ifdef CEU_ORGS
=== CONSTRS_C ===
#endif

#ifdef CEU_THREADS
/* THREADS_C */
=== THREADS_C ===
#endif

/* FUNCTIONS_C */
=== FUNCTIONS_C ===

#ifdef CEU_OS_APP
static void* ceu_app_calls (tceu_app* _ceu_app, tceu_nevt evt, void* param) {
    switch (evt) {
        /* STUBS */
        === STUBS ===
        /*
        case CEU_IN_XXX:
            return CEU_Main_XXX(param);
        */
        default:;
#ifdef CEU_DEBUG
        ceu_out_log(0, (long)"invalid call\n");
#endif
    }
    return NULL;
}
#endif

static int ceu_app_go (tceu_app* _ceu_app , tceu_go* _ceu_go) {
    int _CEU_LBL = _STK->trl->lbl;
#ifdef CEU_GOTO
_CEU_GOTO_:
#endif

#ifdef CEU_DEBUG
#ifndef CEU_OS_APP
#ifdef CEU_ORGS
    _ceu_app->lst.org = _STK_ORG;
#endif
    _ceu_app->lst.trl = _STK->trl;
    _ceu_app->lst.lbl = _CEU_LBL;
#endif
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS_APP
printf("OK : lbl=%d : org=%p\n", _CEU_LBL, _STK_ORG);
#endif
#endif
#endif

#ifdef CEU_RUNTESTS
    ceu_stack_clr();
#endif

    switch (_CEU_LBL) {
        === CODE ===
    }
#ifdef CEU_DEBUG
    ceu_out_assert(0, "no return");
#endif
    return RET_HALT;    /* TODO: should never be reached anyways */
}

#ifdef CEU_OS_APP
static __attribute__((noinline))  __attribute__((noclone))
#endif
void
ceu_app_init (tceu_app* _ceu_app)
{
    _ceu_app->seqno = 0;
#if defined(CEU_RET) || defined(CEU_OS_APP)
    _ceu_app->isAlive = 1;
#endif
#ifdef CEU_ASYNCS
    _ceu_app->pendingAsyncs = 1;
#endif
#ifdef CEU_RET
    _ceu_app->ret = 0;
#endif
#ifdef CEU_WCLOCKS
    _ceu_app->wclk_late = 0;
    _ceu_app->wclk_min_set = CEU_WCLOCK_INACTIVE;
    _ceu_app->wclk_min_cmp = CEU_WCLOCK_INACTIVE;
#ifdef CEU_TIMEMACHINE
    _ceu_app->wclk_late_ = 0;
    _ceu_app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
    _ceu_app->wclk_min_cmp_ = CEU_WCLOCK_INACTIVE;
#endif
#endif
#ifdef CEU_THREADS
    pthread_mutex_init(&_ceu_app->threads_mutex, NULL);
    /*PTHREAD_COND_INITIALIZER,*/
    _ceu_app->threads_n = 0;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
#endif

    === TOPS_INIT ===

#ifdef CEU_OS_APP

#ifdef __AVR
    _ceu_app->code  = (__typeof__(ceu_app_go)*)    (((word)_ceu_app->addr>>1) + &ceu_app_go);
    _ceu_app->calls = (__typeof__(ceu_app_calls)*) (((word)_ceu_app->addr>>1) + &ceu_app_calls);
#else
    _ceu_app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);
    _ceu_app->calls = (__typeof__(ceu_app_calls)*) (&ceu_app_calls);
#endif

#else   /* !CEU_OS_APP */

    _ceu_app->code  = (__typeof__(ceu_app_go)*)    (&ceu_app_go);

#endif  /* CEU_OS_APP */

#ifndef CEU_OS_APP
#ifdef CEU_DEBUG
    CEU_APP_SIG = _ceu_app;
    signal(SIGSEGV, ceu_segfault);
#endif
#endif

    ceu_out_org(_ceu_app, _ceu_app->data, CEU_NTRAILS, Class_Main,
#ifdef CEU_ORGS_NEWS
                0,
#endif
                NULL, NULL);

#ifdef CEU_LUA
    ceu_luaL_newstate(_ceu_app->lua);
    ceu_out_assert(_ceu_app->lua != NULL, NULL);
    ceu_luaL_openlibs(_ceu_app->lua);
    ceu_lua_atpanic(_ceu_app->lua, ceu_lua_atpanic_f);    /* TODO: CEU_OS */
#endif

    ceu_out_go(_ceu_app, CEU_IN__INIT, NULL);
}

/* EXPORTED ENTRY POINT
 * CEU_EXPORT is put in a separate section ".export".
 * "gcc-ld" should place it at 0x00, before ".text".
 */

#ifdef CEU_OS_APP
__attribute__ ((section (".export")))
void CEU_EXPORT (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                , char** luaifc
#endif
) {
    *size = sizeof(CEU_Main);
    *init = (tceu_init*) &ceu_app_init;
#ifdef CEU_OS_LUAIFC
    *luaifc = (=== APP_LUAIFC ===);
#endif
}
#endif
]====],
    ceu_os_h =
        [====[
#ifndef _CEU_OS_H
#define _CEU_OS_H

#include <stddef.h>
#include "ceu_types.h"

#ifdef CEU_DEBUG
#include <assert.h>
#endif

#if defined(CEU_OS) && defined(__AVR)
#error Understand this again!
#include "Arduino.h"
#define CEU_ISR
#define CEU_ISR_ON()  interrupts()
#define CEU_ISR_OFF() noInterrupts()
#else
#define CEU_ISR_ON()
#define CEU_ISR_OFF()
#endif

#if defined(CEU_OS_KERNEL) || defined(CEU_OS_APP)
#define CEU_OS
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ADTS_NEWS)
#define CEU_NEWS
#endif
#if defined(CEU_ORGS_NEWS_POOL) || defined(CEU_ADTS_NEWS_POOL)
#define CEU_NEWS_POOL
#endif

#ifdef CEU_OS

    /* TODO: all should be configurable */
    #define CEU_EXTS
    #define CEU_WCLOCKS
    #define CEU_ASYNCS
    #define CEU_RET
    #define CEU_CLEAR
#ifndef __AVR
#endif
    #define CEU_INTS
    #define CEU_ORGS
    /*#define CEU_PSES*/ /* TODO: never tried */
    #define CEU_NEWS
    #define CEU_NEWS_POOL
    #define CEU_ORGS_NEWS
    #define CEU_ORGS_NEWS_MALLOC
    #define CEU_ORGS_NEWS_POOL
    #define CEU_ADTS_NEWS
    #define CEU_ADTS_NEWS_MALLOC
    #define CEU_ADTS_NEWS_POOL
/*
    #define CEU_THREADS
*/

#ifdef __AVR
    #define CEU_QUEUE_MAX 256
#else
    #define CEU_QUEUE_MAX 65536
#endif

    #define CEU_IN__NONE          0
    #define CEU_IN__STK         255
    #define CEU_IN__ORG         254
    #define CEU_IN__ORG_PSED    253
    #define CEU_IN__CLEAR       252
    #define CEU_IN__ok_killed   251
    #define CEU_IN__INIT        250     /* HIGHER EXTERNAL */
    #define CEU_IN__ASYNC       249
    #define CEU_IN__THREAD      248
    #define CEU_IN__WCLOCK      247
    #define CEU_IN_OS_START     246
    #define CEU_IN_OS_STOP      245
    #define CEU_IN_OS_DT        244
    #define CEU_IN_OS_INTERRUPT 243
#ifdef CEU_TIMEMACHINE
    #define CEU_IN__WCLOCK_     242
    #define CEU_IN              242
#else
    #define CEU_IN              243
#endif

    #define CEU_IN_higher       CEU_IN__INIT  /* _INIT = HIGHER EXTERNAL */
    #define CEU_IN_lower        128     /* TODO: not checked from up and down */

    typedef s8 tceu_nlbl;   /* TODO: to small!! */

#endif /* CEU_OS */

#ifdef CEU_OS_APP

    #define ceu_out_log(mode,str) \
        ((__typeof__(ceu_sys_log)*)((_ceu_app)->sys_vec[CEU_SYS_LOG]))(mode,str)

    #define ceu_out_assert_ex(v,msg,file,line)          \
        if ((!(v)) && ((msg)!=NULL)) {                  \
            ceu_out_log(0, (long)"[");                  \
            ceu_out_log(0, (long)(file));               \
            ceu_out_log(0, (long)":");                  \
            ceu_out_log(2, (line));                     \
            ceu_out_log(0, (long)"] ");                 \
            ceu_out_log(0, (long)"runtime error: ");    \
            ceu_out_log(0, (long)(msg));                \
            ceu_out_log(0, (long)"\n");                 \
        }                                               \
        ((__typeof__(ceu_sys_assert)*)((_ceu_app)->sys_vec[CEU_SYS_ASSERT]))(v)
    #define ceu_out_assert(v,msg) ceu_out_assert_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr, size) \
        ((__typeof__(ceu_sys_realloc)*)((_ceu_app)->sys_vec[CEU_SYS_REALLOC]))(ptr,size)

    #define ceu_out_req() \
        ((__typeof__(ceu_sys_req)*)((_ceu_app)->sys_vec[CEU_SYS_REQ]))()

    #define ceu_out_load(addr) \
        ((__typeof__(ceu_sys_load)*)((_ceu_app)->sys_vec[CEU_SYS_LOAD]))(addr)

#ifdef CEU_ISR
    #define ceu_out_isr(n,f) \
        ((__typeof__(ceu_sys_isr)*)((_ceu_app)->sys_vec[CEU_SYS_ISR]))(n,f,_ceu_app)
#endif

#ifdef CEU_CLEAR
    #define ceu_out_clear(go,cnt,org,from,stop) \
        ((__typeof__(ceu_sys_clear)*)((_ceu_app)->sys_vec[CEU_SYS_CLEAR]))(go,cnt,org,from,stop)
#endif
    #define ceu_out_stack_push(go,elem,ptr) \
        ((__typeof__(ceu_sys_stack_push)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_PUSH]))(go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
        ((__typeof__(ceu_sys_stack_clear_org)*)((_ceu_app)->sys_vec[CEU_SYS_STACK_CLEAR_ORG]))(go,org,lim)
#endif

    #define ceu_out_org(app,org,n,lbl,isDyn,parent,lnks) \
        ((__typeof__(ceu_sys_org)*)((app)->sys_vec[CEU_SYS_ORG]))(org,n,lbl,isDyn,parent,lnks)

#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
        ((__typeof__(ceu_sys_org_trail)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_TRAIL]))(org,idx,lnk)

    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
        ((__typeof__(ceu_sys_org_spawn)*)((_ceu_app)->sys_vec[CEU_SYS_ORG_SPAWN]))(go,lbl_cnt,org,lbl_org)
#endif

    #define ceu_out_start(app) \
        ((__typeof__(ceu_sys_start)*)((_ceu_app)->sys_vec[CEU_SYS_START]))(app)
    #define ceu_out_link(app1,evt1 , app2,evt2) \
        ((__typeof__(ceu_sys_link)*)((_ceu_app)->sys_vec[CEU_SYS_LINK]))(app1,evt1,app2,evt2)

    #define ceu_out_emit(app,id,sz,buf) \
        ((__typeof__(ceu_sys_emit)*)((app)->sys_vec[CEU_SYS_EMIT]))(app,id,sz,buf)

    #define ceu_out_call(app,id,param) \
        ((__typeof__(ceu_sys_call)*)((app)->sys_vec[CEU_SYS_CALL]))(app,id,param)

#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
        ((__typeof__(ceu_sys_wclock)*)((app)->sys_vec[CEU_SYS_WCLOCK]))(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #error TIMEMACHINE
#endif
#endif

    #define ceu_out_go(app,evt,evtp) \
        ((__typeof__(ceu_sys_go)*)((app)->sys_vec[CEU_SYS_GO]))(app,evt,evtp)

#else /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

    #define ceu_out_log(mode,str) \
            ceu_sys_log(mode,str)

    #define ceu_out_assert_ex(v,msg,file,line)          \
        if ((!(v)) && ((msg)!=NULL)) {                  \
            ceu_out_log(0, (long)"[");                  \
            ceu_out_log(0, (long)(file));               \
            ceu_out_log(0, (long)":");                  \
            ceu_out_log(2, line);                       \
            ceu_out_log(0, (long)"] ");                 \
            ceu_out_log(0, (long)"runtime error: ");    \
            ceu_out_log(0, (long)(msg));                \
            ceu_out_log(0, (long)"\n");                 \
        }                                               \
        ceu_sys_assert(v);
    #define ceu_out_assert(v,msg) ceu_out_assert_ex((v),(msg),__FILE__,__LINE__)

    #define ceu_out_realloc(ptr,size) \
            ceu_sys_realloc(ptr,size)
    #define ceu_out_req() \
            ceu_sys_req()

#ifdef CEU_CLEAR
    #define ceu_out_clear(go,cnt,org,from,stop) \
            ceu_sys_clear(go,cnt,org,from,stop)
#endif
    #define ceu_out_stack_push(go,elem,ptr) \
            ceu_sys_stack_push(go,elem,ptr)
#ifdef CEU_ORGS
    #define ceu_out_stack_clear_org(go,org,lim) \
            ceu_sys_stack_clear_org(go,org,lim)
#endif

#ifdef CEU_ORGS_NEWS
    #define ceu_out_org(app,org,n,lbl,isDyn,parent,lnks) \
            ceu_sys_org(org,n,lbl,isDyn,parent,lnks)
#else
    #define ceu_out_org(app,org,n,lbl,parent,lnks) \
            ceu_sys_org(org,n,lbl,parent,lnks)
#endif
#ifdef CEU_ORGS
    #define ceu_out_org_trail(org,idx,lnk) \
            ceu_sys_org_trail(org,idx,lnk)
    #define ceu_out_org_spawn(go, lbl_cnt, org, lbl_org) \
            ceu_sys_org_spawn(go, lbl_cnt, org, lbl_org)
#endif
#ifdef CEU_WCLOCKS
    #define ceu_out_wclock(app,dt,set,get) \
            ceu_sys_wclock(app,dt,set,get)
#ifdef CEU_TIMEMACHINE
    #define ceu_out_wclock_(app,dt,set,get) \
            ceu_sys_wclock_(app,dt,set,get)
#endif
#endif
    #define ceu_out_go(app,evt,evtp) \
            ceu_sys_go(app,evt,evtp)

#endif /* ! CEU_OS_APP (!CEU_OS||CEU_OS_KERNEL) */

#define ceu_in_emit(app,id,n,buf) \
    ceu_out_go(app,id,buf)

#ifdef CEU_THREADS
/* TODO: app */
#include "ceu_threads.h"
#endif

#ifdef CEU_LUA
#include <stdio.h>      /* BUFSIZ */
#include <string.h>     /* strcpy */
#if defined(__ANDROID__) || defined(CEU_OS)
    #include "lua.h"
    #include "lauxlib.h"
    #include "lualib.h"
#else
    #include <lua5.1/lua.h>
    #include <lua5.1/lauxlib.h>
    #include <lua5.1/lualib.h>
#endif

#ifdef CEU_OS_APP
    #define ceu_luaL_newstate(set) { \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_NEW, NULL); \
    }

    #define ceu_luaL_openlibs(l) { \
        lua_State* p = l;          \
        ceu_out_call(_ceu_app, CEU_OUT_LUAL_OPENLIBS, &p); \
    }

    #define ceu_lua_atpanic(l, f) {     \
    }

    #define ceu_luaL_loadstring(set, l, str) {  \
        tceu__lua_State___char_ p = { l, str }; \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUAL_LOADSTRING, &p); \
    }

    #define ceu_lua_pushnumber(l, v) {      \
        tceu__lua_State___int p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHNUMBER, &p); \
    }

    #define ceu_lua_pushstring(l, v) {      \
        tceu__lua_State___char_ p = { l, v }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHSTRING, &p); \
    }

    #define ceu_lua_pushlightuserdata(l, v) {   \
        tceu__lua_State___void_ p = { l, v };     \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PUSHLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_pcall(set,l,nargs,nrets,err) {                  \
        tceu__lua_State___int__int__int p = { l, nargs, nrets, err }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_PCALL, &p); \
    }

    #define ceu_lua_isnumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISNUMBER, &p); \
    }

    #define ceu_lua_tonumber(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TONUMBER, &p); \
    }

    #define ceu_lua_isboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISBOOLEAN, &p); \
    }

    #define ceu_lua_toboolean(set, l, idx) {    \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_TOBOOLEAN, &p); \
    }

    #define ceu_lua_pop(l, n) {             \
        tceu__lua_State___int p = { l, n }; \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_POP, &p); \
    }

    #define ceu_lua_isstring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISSTRING, &p); \
    }

    #define ceu_lua_tostring(set, l, idx) {     \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOSTRING, &p); \
    }

    #define ceu_lua_islightuserdata(set, l, idx) {  \
        tceu__lua_State___int p = { l, idx };       \
        set = (int) ceu_out_call(_ceu_app, CEU_OUT_LUA_ISLIGHTUSERDATA, &p); \
    }

    #define ceu_lua_touserdata(set, l, idx) {   \
        tceu__lua_State___int p = { l, idx };   \
        set = ceu_out_call(_ceu_app, CEU_OUT_LUA_TOUSERDATA, &p); \
    }

    #define ceu_lua_error(l) {  \
        lua_State** p = &l;        \
        ceu_out_call(_ceu_app, CEU_OUT_LUA_ERROR, &p); \
    }
#else
    #define ceu_luaL_newstate(set)               set = luaL_newstate()
    #define ceu_luaL_openlibs(l)                 luaL_openlibs(l)
    #define ceu_lua_atpanic(l,f)                 lua_atpanic(l,f)
    #define ceu_luaL_loadstring(set,l,str)       set = luaL_loadstring(l,str)
    #define ceu_lua_pushnumber(l,v)              lua_pushnumber(l,v)
    #define ceu_lua_pushstring(l,v)              lua_pushstring(l,v)
    #define ceu_lua_pushlightuserdata(l,v)       lua_pushlightuserdata(l,v)
    #define ceu_lua_pcall(set,l,nargs,nrets,err) set = lua_pcall(l,nargs,nrets,err)
    #define ceu_lua_isnumber(set,l,idx)          set = lua_isnumber(l,idx)
    #define ceu_lua_tonumber(set,l,idx)          set = lua_tonumber(l,idx)
    #define ceu_lua_isboolean(set,l,idx)         set = lua_isboolean(l,idx)
    #define ceu_lua_toboolean(set,l,idx)         set = lua_toboolean(l,idx)
    #define ceu_lua_pop(l,n)                     lua_pop(l,n)
    #define ceu_lua_isstring(set,l,idx)          set = lua_isstring(l,idx)
    #define ceu_lua_tostring(set,l,idx)          set = lua_tostring(l,idx)
    #define ceu_lua_islightuserdata(set,l,idx)   set = lua_islightuserdata(l,idx)
    #define ceu_lua_touserdata(set,l,idx)        set = lua_touserdata(l,idx)
    #define ceu_lua_error(l)                     lua_error(l)
#endif
#endif

typedef u8 tceu_nevt;   /* max number of events */
                        /* TODO: should "u8" be fixed? */

typedef u8 tceu_ntrl;   /* max number of trails per class */
                        /* TODO: should "u8" be fixed? */

typedef u16 tceu_nstk;  /* max size of internal stack in bytes */
                        /* TODO: should "u16" be fixed? */

#ifdef __cplusplus
#define CEU_WCLOCK_INACTIVE 0x7fffffffL     /* TODO */
#else
#define CEU_WCLOCK_INACTIVE INT32_MAX
#endif
#define CEU_WCLOCK_EXPIRED (CEU_WCLOCK_INACTIVE-1)

/* TCEU_TRL */

typedef union tceu_trl {
    tceu_nevt evt;

    /* normal await // IN__CLEAR */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt1;
        tceu_nlbl lbl;
        u8        seqno;        /* TODO(ram): 2 bits is enough */
    };

    /* IN__STK */
    struct {                    /* TODO(ram): bitfields */
        tceu_nevt evt2;
        tceu_nlbl lbl2;
        tceu_nstk stk;
    };

    /* IN__ORG */
#ifdef CEU_ORGS
    struct {                    /* TODO(ram): bad for alignment */
        tceu_nevt evt3;
        struct tceu_org_lnk* lnks;
    };
#endif
} tceu_trl;

/* TCEU_RECURSE */

typedef struct {
    tceu_nlbl lbl;      /* TODO(ram): not required if only one `recurse´ */
    void*     data;
} tceu_recurse;

/* TCEU_STK */

/* TODO(speed): hold nxt trl to run */
typedef struct tceu_stk {
    tceu_nevt evt;  /* TODO: small in the end of struct? */
    u8        evt_sz;
    u8        offset;

    union {
#ifdef CEU_CLEAR
        void* cnt;  /* dont clear the continuation trail */
#endif
#if defined(CEU_ORGS) && defined(CEU_INTS)
        void* evto; /* emitting org */
#endif
    };

    tceu_trl* trl;  /* trail being traversed */
#ifdef CEU_ORGS
    void* org;      /* org being traversed */
#endif
#ifdef CEU_CLEAR
    void* stop;     /* stop at this trl/org */
        /* traversals may be bounded to org/trl
         * default (NULL) is to traverse everything */
        /* TODO: could be shared w/ evto */
#endif
    byte  evt_buf[0];
} tceu_stk;
/* TODO: see if fields can be reused in union */

/* TCEU_LNK */

/* simulates an org prv/nxt */
typedef struct tceu_org_lnk {
    struct tceu_org* prv;   /* TODO(ram): lnks[0] does not use */
    struct tceu_org* nxt;   /*      prv, n, lnk                  */
    struct tceu_org* up;
    u8 lnk;
    tceu_ntrl n;            /* use for ands/fins                 */
} tceu_org_lnk;

#ifdef CEU_NEWS
typedef struct {
    tceu_org_lnk** lnks;
    byte**         queue;
} tceu_pool_;
#endif

/* TCEU_ORG */

typedef struct tceu_org
{
#ifdef CEU_ORGS
    struct tceu_org* prv;   /* linked list for the scheduler */
    struct tceu_org* nxt;
    struct tceu_org* up;
    u8 lnk;
#endif
#if defined(CEU_ORGS) || defined(CEU_OS)
    tceu_ntrl n;            /* number of trails (TODO(ram): opt, metadata) */
#endif
    /* prv/nxt/lnk/n must be in the same order as "tceu_org_lnk" */

#ifdef CEU_ORGS

#ifdef CEU_IFCS
    tceu_ncls cls;          /* class id */
#endif

#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    u8 isAlive: 1;          /* Three purposes:
                             * - =0 if terminate normally or =1 if from scope
                             *      checked to see if should call free on pool
                             * - required by "watching o" to avoid awaiting a
                             *      dead org
                             * - required by "Do T" to avoid awaiting a dead 
                             *      org
                             */
#endif

#ifdef CEU_ORGS_NEWS
    u8 isDyn: 1;            /* created w/ new or spawn? */
#endif

#ifdef CEU_ORGS_NEWS_POOL
    tceu_pool_*  pool;      /* TODO(ram): opt, traverse lst of cls pools */
#endif

#ifdef CEU_ORGS_WATCHING
    int ret;
    u32 id;
        /* TODO: couldn't find a way to use the address as an identifier
         * when killing an organism. The "free" happens before the "kill"
         * completes and the address can be reused in the meantime.
         * It could happen that an await on a newly created organism awakes
         * from the previous "kill".
         * Couldn't reproduce on "tests.lua", but "turtle.ceu" does.
         */
#endif

#endif  /* CEU_ORGS */

    tceu_trl trls[0];       /* first trail */

} tceu_org;

#ifdef CEU_ORGS_WATCHING
typedef struct {
    u32 org;
    int ret;
} tceu_org_kill;
#endif

#ifdef CEU_ORGS_POOL_ITERATOR
typedef struct tceu_pool_iterator {
    struct tceu_pool_iterator* prv; /* previous active pool iterator in the stack */
    tceu_org* org; /* org to be traversed next in this iterator */
} tceu_pool_iterator;
#endif

/* TCEU_GO */

/* TODO: tceu_go => tceu_stk? */
typedef struct tceu_go {
    #define CEU_STACK_MAX   1024*sizeof(tceu_stk)
        /* TODO: possible to calculate (not is CEU_ORGS_NEWS)
        #define CEU_STACK_MAX   (CEU_NTRAILS+1) // current +1 for each trail
        */
    byte stk[CEU_STACK_MAX];
    tceu_nstk stk_nxti;
    tceu_nstk stk_curi;
} tceu_go;

#define stack_init(go)    (go)->stk_curi = (go)->stk_nxti = 0
#define stack_empty(go)   ((go)->stk_curi == (go)->stk_nxti)
#define stack_get(go,i)   (((tceu_stk*)&((go)->stk[i])))
#define stack_cur(go)     stack_get((go),(go)->stk_curi)
#define stack_nxt(go)     stack_get((go),(go)->stk_nxti)
#define stack_sz(go,i)    ((tceu_nstk)(sizeof(tceu_stk)+stack_get((go),i)->evt_sz))
#define stack_curi(go)    ((go)->stk_curi)
#define stack_nxti(go)    ((go)->stk_nxti)
#define stack_pushi(go,e) ((go)->stk_nxti + sizeof(tceu_stk) + (e)->evt_sz)
#define stack_full(go,e)  (stack_pushi((go),(e)) >= CEU_STACK_MAX)

#define stack_prvi(go)                                          \
    ((go)->stk_curi - stack_cur((go))->offset)

#define stack_pop(go)                                           \
    ceu_out_assert(!stack_empty(go), "stack underflow");        \
    ceu_stack_pop_f((go));

#define stack_push(go,elem,ptr)                                 \
    ceu_out_assert(!stack_full((go),(elem)), "stack overflow"); \
    ceu_out_stack_push((go),(elem),(ptr));

#define STK  stack_cur(&go)
#define _STK stack_cur(_ceu_go)
#ifdef CEU_ORGS
#define STK_ORG_ATTR  (STK->org)
#define _STK_ORG_ATTR (_STK->org)
#else
#define STK_ORG_ATTR  (app->data)
#define _STK_ORG_ATTR (_ceu_app->data)
#endif
#define STK_ORG  ((tceu_org*)STK_ORG_ATTR)    /* not an lvalue */
#define _STK_ORG ((tceu_org*)_STK_ORG_ATTR)   /* not an lvalue */
#define STK_LBL (STK->trl->lbl)

/* TCEU_LST */

#ifdef CEU_DEBUG
typedef struct tceu_lst {
#ifdef CEU_ORGS
    void*     org;
#endif
    tceu_trl* trl;
    tceu_nlbl lbl;
} tceu_lst;
#endif

/* TCEU_APP */

typedef struct tceu_app {
    /* global seqno: incremented on every reaction
     * awaiting trails matches only if trl->seqno < seqno,
     * i.e., previously awaiting the event
     */
    u8 seqno:         2;
#if defined(CEU_RET) || defined(CEU_OS)
    u8 isAlive:       1;
#endif
#ifdef CEU_ASYNCS
    u8 pendingAsyncs: 1;
#endif

#ifdef CEU_OS
    struct tceu_app* nxt;
#endif

#ifdef CEU_RET
    int ret;
#endif

#ifdef CEU_WCLOCKS
    s32         wclk_late;
    s32         wclk_min_set;   /* used to set */
    s32         wclk_min_cmp;   /* used to compare */
                                /* cmp<-set every reaction */
#ifdef CEU_TIMEMACHINE
    s32         wclk_late_;
    s32         wclk_min_set_;
    s32         wclk_min_cmp_;
#endif
#endif

#ifndef CEU_OS
#ifdef CEU_DEBUG
    tceu_lst    lst; /* segfault printf */
#endif
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_T threads_mutex;
    /*CEU_THREADS_COND_T  threads_cond;*/
    u8                  threads_n;          /* number of running threads */
        /* TODO: u8? */
#endif
#if defined(CEU_LUA) || defined(CEU_OS)
#ifdef CEU_LUA
    lua_State*  lua;    /* TODO: move to data? */
#else
    void*       lua;
#endif
#endif

    int         (*code)  (struct tceu_app*,tceu_go*);
    void        (*init)  (struct tceu_app*);
#ifdef CEU_OS
    void*       (*calls) (struct tceu_app*,tceu_nevt,void*);
    void**      sys_vec;
    void*       addr;
#ifdef CEU_OS_LUAIFC
    char*       luaifc;
#endif
#endif
    tceu_org*   data;
} tceu_app;

#ifdef CEU_OS
typedef void (*tceu_init)   (tceu_app* app);
typedef void (*tceu_export) (uint* size, tceu_init** init
#ifdef CEU_OS_LUAIFC
                            , char** luaifc
#endif
);
#endif

/* TCEU_THREADS_P */

#ifdef CEU_THREADS
typedef struct {
    tceu_app* app;
    tceu_org* org;
    s8*       st; /* thread state:
                   * 0=ini (sync  spawns)
                   * 1=cpy (async copies)
                   * 2=lck (sync  locks)
                   * 3=end (sync/async terminates)
                   */
} tceu_threads_p;
#endif

/* TCEU_ADT */

#ifdef CEU_ADTS_NEWS
typedef struct {
    void* root;
#ifdef CEU_ADTS_NEWS_POOL
    void* pool;
#endif
} tceu_adt_root;
#endif

/* RET_* */

enum {
    RET_HALT = 0
    /*RET_GOTO,*/
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
    , RET_RESTART
#endif
#ifdef CEU_ASYNCS
    , RET_ASYNC
#endif
#ifdef CEU_RET
    , RET_QUIT
#endif
};

#ifdef CEU_PSES
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed);
#endif

int  ceu_go_all    (tceu_app* app);

#ifdef CEU_WCLOCKS
int       ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get);
#endif
void      ceu_sys_go     (tceu_app* app, int evt, void* evtp);

#ifdef CEU_OS

/* TCEU_LINK */

typedef struct tceu_lnk {
    tceu_app* src_app;
    tceu_nevt src_evt;
    tceu_app* dst_app;
    tceu_nevt dst_evt;
    struct tceu_lnk* nxt;
} tceu_lnk;

/* TCEU_QUEUE */

typedef struct {
    tceu_app* app;
    tceu_nevt evt;
#if CEU_QUEUE_MAX == 256
    s8        sz;
#else
    s16       sz;   /* signed because of fill */
#endif
    byte      buf[0];
} tceu_queue;

#ifdef CEU_ISR
typedef void(*tceu_isr_f)(tceu_app* app, tceu_org* org);
#endif

void ceu_os_init      (void);
int  ceu_os_scheduler (int(*dt)());
tceu_queue* ceu_sys_queue_nxt (void);
void        ceu_sys_queue_rem (void);

void      ceu_sys_assert    (int v);
void      ceu_sys_log       (int mode, long str);
void*     ceu_sys_realloc   (void* ptr, size_t size);
int       ceu_sys_req       (void);
tceu_app* ceu_sys_load      (void* addr);
#ifdef CEU_ISR
int       ceu_sys_isr       (int n, tceu_isr_f f, tceu_app* app);
#endif
#ifdef CEU_CLEAR
int       ceu_sys_clear     (tceu_go* _ceu_go, tceu_nlbl cnt, tceu_org* org, tceu_trl* from, void* stop);
#endif
void      ceu_sys_stack_push (tceu_go* go, tceu_stk* elem, void* ptr);
#ifdef CEU_ORGS
void      ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim);
#endif

void      ceu_sys_org       (tceu_org* org, int n, int lbl, int isDyn, tceu_org* parent, tceu_org_lnk** lnks);
#ifdef CEU_ORGS
void      ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnk);
int       ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* org, tceu_nlbl lbl_org);
#endif
void      ceu_sys_start     (tceu_app* app);
int       ceu_sys_link      (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_unlink    (tceu_app* src_app, tceu_nevt src_evt, tceu_app* dst_app, tceu_nevt dst_evt);
int       ceu_sys_emit      (tceu_app* app, tceu_nevt evt, int sz, void* param);
void*     ceu_sys_call      (tceu_app* app, tceu_nevt evt, void* param);

enum {
    CEU_SYS_ASSERT = 0,
    CEU_SYS_LOG,
    CEU_SYS_REALLOC,
    CEU_SYS_REQ,
    CEU_SYS_LOAD,
#ifdef CEU_ISR
    CEU_SYS_ISR,
#endif
#ifdef CEU_CLEAR
    CEU_SYS_CLEAR,
#endif
    CEU_SYS_STACK_PUSH,
#ifdef CEU_ORGS
    CEU_SYS_STACK_CLEAR_ORG,
#endif
    CEU_SYS_ORG,
#ifdef CEU_ORGS
    CEU_SYS_ORG_TRAIL,
    CEU_SYS_ORG_SPAWN,
#endif
    CEU_SYS_START,
    CEU_SYS_LINK,
    CEU_SYS_UNLINK,
    CEU_SYS_EMIT,
    CEU_SYS_CALL,
#ifdef CEU_WCLOCKS
    CEU_SYS_WCLOCK,
#endif
    CEU_SYS_GO,
    CEU_SYS_MAX
};

/* SYS_VECTOR
 */
extern void* CEU_SYS_VEC[CEU_SYS_MAX];

#endif  /* CEU_OS */

#endif  /* _CEU_OS_H */
]====],
    ceu_os_c =
        [====[
/* TODO: #ifdef CEU_INTS: seqno, stk_curi, CEU_STK */

#include "ceu_os.h"

#ifdef __AVR
#ifdef CEU_OS
#error Understand this again!
#include <avr/pgmspace.h>
void* CEU_APP_ADDR = NULL;
#endif
#endif

#include <string.h>

#ifdef CEU_DEBUG
#include <stdio.h>      /* printf */
#ifndef CEU_NOSTDLIB
#include <assert.h>     /* sys_assert */
#endif
#endif

#if defined(CEU_DEBUG) || defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL)
#include <stdlib.h>     /* realloc, exit */
void *realloc(void *ptr, size_t size);
#endif

#ifdef CEU_NEWS_POOL
#include "ceu_pool.h"
#endif

/*
 * pthread_t thread;
 * pthread_mutex_t mutex;
 * pthread_cond_t  cond;
 * pthread_self();
        Uint32 SDL_ThreadID(void);
 * pthread_create(&thread, NULL, f, &p);
        SDL_Thread *SDL_CreateThread(int (*fn)(void *), void *data);
 * pthread_mutex_lock(&mutex);
 * pthread_mutex_unlock(&mutex);
 * pthread_cond_wait(&cond, &mutex);
 * pthread_cond_signal(&cond);
*/

/**********************************************************************
 * "APPS" running on the OS do not need any of the below.
 **********************************************************************/

#ifndef CEU_OS_APP

#ifndef CEU_NOSTDLIB

void ceu_sys_assert (int v) {
#ifdef CEU_DEBUG
    assert(v);
#else
    (void)v;
#endif
}

#include <stdio.h>
void ceu_sys_log (int mode, long s) {
    switch (mode) {
        case 0:
            printf("%s", (char*)s);
            break;
        case 1:
            printf("%lX", s);
            break;
        case 2:
            printf("%ld", s);
            break;
    }
}

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
#define CEU_MAX_DYNS 100
static int _ceu_dyns_ = 0;  /* check if total of alloc/free match */
#endif
#endif

#if defined(CEU_NEWS) || defined(CEU_THREADS) || defined(CEU_OS_KERNEL)
void* ceu_sys_realloc (void* ptr, size_t size) {
#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    if (size == 0) {
        if (ptr != NULL) {
            _ceu_dyns_--;
        }
    } else {
        if (_ceu_dyns_ >= CEU_MAX_DYNS) {
            return NULL;
        }
        _ceu_dyns_++;           /* assumes no malloc fails */
    }
#endif
#endif
    return realloc(ptr, size);
}
#endif

#endif /* ifndef CEU_NOSTDLIB */

int CEU_REQS = 0;
int ceu_sys_req (void) {
    CEU_REQS++;
    return CEU_REQS;
}

/**********************************************************************/

void ceu_stack_pop_f (tceu_go* go) {
    go->stk_nxti = go->stk_curi;
    go->stk_curi -= stack_cur(go)->offset;
}

void ceu_sys_stack_push (tceu_go* go, tceu_stk* elem, void* ptr) {
    elem->offset = go->stk_nxti - go->stk_curi;
    go->stk_curi = go->stk_nxti;
    go->stk_nxti = stack_pushi(go, elem);
    *stack_cur(go) = *elem;
    if (ptr != NULL) {
        memcpy(stack_cur(go)->evt_buf, ptr, elem->evt_sz);
    }
}

#ifdef CEU_DEBUG
void ceu_stack_dump (tceu_go* go) {
    int i;
    printf("=== STACK-DUMP [%d -> %d]\n", go->stk_curi, go->stk_nxti);
    for (i=0; i<go->stk_nxti; i+=stack_sz(go,i)) {
        printf("[%d] evt=%d sz=%d\n", i, stack_get(go,i)->evt, stack_get(go,i)->evt_sz);
    }
}
#endif

/* TODO: move from 1=>0 (change also in code.lua) */
#ifdef CEU_ORGS
/*
 * All traversals for the "org" being cleared (as well as nested ones) must 
 * continue with the org in sequence.
 */
static int __ceu_isParent (tceu_org* parent, tceu_org* me) {
    return (parent==me) || (me!=NULL && __ceu_isParent(parent,me->up));
}
void ceu_sys_stack_clear_org (tceu_go* go, tceu_org* org, int lim) {
    int i;
    for (i=0; i<lim; i+=stack_sz((go),i)) {
        tceu_stk* stk = stack_get((go),i);
        if (stk->evt == CEU_IN__NONE) {
            continue;   /* already cleared: avoids accessing dangling pointer */
        }
        if (__ceu_isParent(org, (tceu_org*)stk->org)) {
            if (stk->stop == NULL) {        /* broadcast traversal */
                /* jump to next organism */
                stk->org = org->nxt;
                stk->trl = &((tceu_org*)org->nxt)->trls [
                            (org->n == 0) ?
                            ((tceu_org_lnk*)org)->lnk : 0
                          ];
            } else {                        /* ignore local traversals */
                stk->evt = CEU_IN__NONE;
            }
        }
    }
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS

void ceu_sys_org_trail (tceu_org* org, int idx, tceu_org_lnk* lnks) {
    org->trls[idx].evt  = CEU_IN__ORG;
    org->trls[idx].lnks = lnks;
    lnks[0].nxt = (tceu_org*) &lnks[1];
    lnks[1].prv = (tceu_org*) &lnks[0];
    lnks[1].nxt = org;
    lnks[1].n   = 0;    /* marks end of linked list */
    lnks[1].lnk = idx+1;
    lnks[0].up = lnks[1].up = org;
}

int ceu_sys_org_spawn (tceu_go* _ceu_go, tceu_nlbl lbl_cnt, tceu_org* neworg, tceu_nlbl neworg_lbl) {
    /* save the continuation to run after the constructor */
    _STK->trl->evt = CEU_IN__STK;
    _STK->trl->lbl = lbl_cnt;
    _STK->trl->stk = stack_curi(_ceu_go);
       /* awake in the same level as we are now (-1 vs the constructor push below) */

    /* prepare the new org to start */
    neworg->trls[0].evt = CEU_IN__STK;
    neworg->trls[0].lbl = neworg_lbl;
    neworg->trls[0].stk = stack_nxti(_ceu_go);

    {
        /* switch to ORG */
        tceu_stk stk;
                 stk.evt  = CEU_IN__STK;
                 stk.org  = neworg;
                 stk.trl  = &neworg->trls[0];
                 stk.stop = &neworg->trls[neworg->n]; /* don't follow the up link */
                 stk.evt_sz = 0;
        stack_push(_ceu_go, &stk, NULL);
    }
    return RET_RESTART;
}

#endif

#ifdef CEU_ORGS_WATCHING
static u32 CEU_ORGS_ID = 0;;
#endif

void ceu_sys_org (tceu_org* org, int n, int lbl,
#ifdef CEU_ORGS_NEWS
                  int isDyn,
#endif
                  tceu_org* parent, tceu_org_lnk** lnks)
{
    /* { evt=0, seqno=0, lbl=0 } for all trails */
    memset(&org->trls, 0, n*sizeof(tceu_trl));

#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
    org->n  = n;
    org->up = parent;
#endif
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING) || defined(CEU_OS_KERNEL)
    org->isAlive = 1;
#endif
#ifdef CEU_ORGS_WATCHING
    org->ret = 0;
    org->id  = CEU_ORGS_ID++;
    ceu_out_assert(CEU_ORGS_ID > 0, "orgs overflow");
#endif
#ifdef CEU_ORGS_NEWS
    org->isDyn = isDyn;
#endif

    /* org.trls[0] == org.blk.trails[1] */
    org->trls[0].evt = CEU_IN__STK;
    org->trls[0].lbl = lbl;

#ifdef CEU_ORGS
    if (lnks == NULL) {
        return;             /* main class */
    }

    /* re-link */
    {
        tceu_org_lnk* lst = &(*lnks)[1];
        lst->prv->nxt = org;
        org->prv = lst->prv;
        org->nxt = (tceu_org*)lst;
        lst->prv = org;
    }
#endif  /* CEU_ORGS */
}
#ifndef CEU_ORGS
#define ceu_sys_org(a,b,c,d,e) ceu_sys_org(a,b,c,NULL,NULL)
#endif

#ifdef CEU_ORGS
void ceu_sys_org_kill (tceu_app* _ceu_app, tceu_go* _ceu_go, tceu_org* org)
{
#if defined(CEU_ORGS_NEWS) || defined(CEU_ORGS_WATCHING)
    org->isAlive = 0;
#endif

    /* awake listeners after clear (this is a stack!) */
#ifdef CEU_ORGS_WATCHING
    /* TODO(speed): only if was ever watched! */
    {
        tceu_stk stk;
                 stk.evt  = CEU_IN__ok_killed;
                 stk.org  = _ceu_app->data;
                 stk.trl  = &_ceu_app->data->trls[0];
                 stk.stop = NULL;
                 stk.evt_sz = sizeof(tceu_org_kill);
        tceu_org_kill ps = { org->id, org->ret };
        stack_push(_ceu_go, &stk, &ps);
            /* param "org" is pointer to what to kill */
    }
#endif
}

#ifdef CEU_ORGS_NEWS
void ceu_sys_org_free (tceu_org* org)
{
    /* free org */
    if (org->isDyn) {
        /* re-link PRV <-> NXT */
        org->prv->nxt = org->nxt;
        org->nxt->prv = org->prv;

        /* free */
#if    defined(CEU_ORGS_NEWS_POOL) && !defined(CEU_ORGS_NEWS_MALLOC)
        ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
#elif  defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        if (org->pool->queue == NULL) {
            ceu_sys_realloc(org, 0);
        } else {
            ceu_pool_free((tceu_pool*)org->pool, (byte*)org);
        }
#elif !defined(CEU_ORGS_NEWS_POOL) &&  defined(CEU_ORGS_NEWS_MALLOC)
        ceu_sys_realloc(org, 0);
#endif
    }
}
#endif /* CEU_ORGS_NEWS */

#endif

/**********************************************************************/

#ifdef CEU_CLEAR
int ceu_sys_clear (tceu_go* _ceu_go, tceu_nlbl cnt,
                   tceu_org* org, tceu_trl* from, void* stop)
{
    if (_STK->evt < CEU_IN_lower) {
        /* need this extra level in the case we are in an internal event and
         * the emit sets the current level to NONE when aborted */
        tceu_stk stk        = *_STK;
_STK->trl++;
                 stk.evt    = CEU_IN__STK;
                 stk.evt_sz = 0;
        stack_push(_ceu_go, &stk, NULL);
    }

    /* save the continuation to run after the clear */
    /* trails[1] points to ORG blk ("clear trail") */
    _STK->trl->evt = CEU_IN__STK;
    _STK->trl->stk = stack_curi(_ceu_go);
    _STK->trl->lbl = cnt;

    {
        tceu_stk stk;
                 stk.evt    = CEU_IN__CLEAR;
                 stk.cnt    = _STK->trl;
#ifdef CEU_ORGS
                 stk.org    = org;
#endif
                 stk.trl    = from;
                 stk.stop   = stop;
                 stk.evt_sz = 0;
        stack_push(_ceu_go, &stk, NULL);    /* continue after it */
    }

    return RET_RESTART;
}
#endif

/**********************************************************************/

#ifdef CEU_ORGS_POOL_ITERATOR
static tceu_pool_iterator* CEU_POOL_ITERATORS;

void ceu_pool_iterator_enter (tceu_pool_iterator* me) {
    if (me != CEU_POOL_ITERATORS) {
        me->prv = CEU_POOL_ITERATORS;
        CEU_POOL_ITERATORS = me;
    }
}

void ceu_pool_iterator_leave (tceu_pool_iterator* me) {
    CEU_POOL_ITERATORS = me->prv;
}

void ceu_pool_iterator_kill (tceu_org* org) {
    tceu_pool_iterator* it = CEU_POOL_ITERATORS;
    while (it != NULL) {
        if (it->org == org) {
            it->org = (it->org->nxt->n == 0) ? NULL : it->org->nxt;
                /* change next iteration to point to org in sequence */
        }
        it = it->prv;
    }
}
#endif

/**********************************************************************/

#ifdef CEU_WCLOCKS

/* TODO: wclk_min_cmp to be global among all apps */

int ceu_sys_wclock (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set > t) ) {
        app->wclk_min_set = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}

#ifdef CEU_TIMEMACHINE
/* TODO: unify with above */
int ceu_sys_wclock_ (tceu_app* app, s32 dt, s32* set, s32* get)
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "get") */

    /* SET */
    if (set != NULL) {
        t = dt - app->wclk_late;
        *set = t;

    /* CHECK */
    } else {
        t = *get;
        if ((t > app->wclk_min_cmp_) || (t > dt)) {
            *get -= dt;    /* don't expire yet */
            t = *get;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (app->wclk_min_set_ > t) ) {
        app->wclk_min_set_ = t;
#ifdef ceu_out_wclock_set
        ceu_out_wclock_set(t);
#endif
    }

    return ret;
}
#endif

#endif

/**********************************************************************/

#ifdef CEU_LUA
int ceu_lua_atpanic_f (lua_State* lua) {
#ifdef CEU_DEBUG
    char msg[255] = "LUA_ATPANIC: ";
    strncat(msg, lua_tostring(lua,-1), 100);
    strncat(msg, "\n", 1);
    ceu_out_assert(0, msg);
/*
*/
#else
    ceu_out_assert(0, "bug found");
#endif
    return 0;
}
#endif

/**********************************************************************/

#ifdef CEU_PSES
#ifdef CEU_OS_KERNEL
#error Not implemented!
#endif
void ceu_pause (tceu_trl* trl, tceu_trl* trlF, int psed) {
    do {
        if (psed) {
            if (trl->evt == CEU_IN__ORG) {
                trl->evt = CEU_IN__ORG_PSED;
            }
        } else {
            if (trl->evt == CEU_IN__ORG_PSED) {
                trl->evt = CEU_IN__ORG;
            }
        }
        if ( trl->evt == CEU_IN__ORG
        ||   trl->evt == CEU_IN__ORG_PSED ) {
            trl += 2;       /* jump [fst|lst] */
        }
    } while (++trl <= trlF);

#ifdef ceu_out_wclock_set
    if (!psed) {
        ceu_out_wclock_set(0);  /* TODO: recalculate MIN clock */
                                /*       between trl => trlF   */
    }
#endif
#ifdef CEU_TIMEMACHINE
#ifdef ceu_out_wclock_set_
    if (!psed) {
        ceu_out_wclock_set_(0);  /* TODO: recalculate MIN clock */
                                 /*       between trl => trlF   */
    }
#endif
#endif
}
#endif

/**********************************************************************/

u8 CEU_GC = 0;  /* execute __ceu_os_gc() when "true" */

void ceu_sys_go (tceu_app* app, int evt, void* evtp)
{
    tceu_go go;

#ifdef CEU_ORGS_POOL_ITERATOR
    CEU_POOL_ITERATORS = NULL;
        /* clean/restart stacked pools every reaction */
#endif


    switch (evt) {
#ifdef CEU_ASYNCS
        case CEU_IN__ASYNC:
            app->pendingAsyncs = 0;
            break;
#endif
#ifdef CEU_WCLOCKS
        case CEU_IN__WCLOCK:
            app->wclk_min_cmp = app->wclk_min_set;      /* swap "cmp" to last "set" */
            app->wclk_min_set = CEU_WCLOCK_INACTIVE;    /* new "set" resets to inactive */
            if (app->wclk_min_cmp <= *((s32*)evtp)) {
                app->wclk_late = *((s32*)evtp) - app->wclk_min_cmp;
            }
            break;
#ifdef CEU_TIMEMACHINE
        case CEU_IN__WCLOCK_:
            app->wclk_min_cmp_ = app->wclk_min_set_;
            app->wclk_min_set_ = CEU_WCLOCK_INACTIVE;
            if (app->wclk_min_cmp_ <= *((s32*)evtp)) {
                app->wclk_late_ = *((s32*)evtp) - app->wclk_min_cmp_;
            }
            break;
#endif
#endif
    }

    stack_init(&go);
    {
        tceu_stk stk;
                 stk.evt  = evt;
#ifdef CEU_ORGS
                 stk.org  = app->data;
#endif
                 stk.trl  = &app->data->trls[0];
#ifdef CEU_CLEAR
                 stk.stop = NULL;  /* traverse all (don't stop) */
#endif
                 stk.evt_sz = sizeof(evtp);
        stack_push(&go, &stk, &evtp);
    }

    app->seqno++;

    for (;;)    /* STACK */
    {
        for (;;) /* TRL // TODO(speed): only range of trails that apply */
        {        /* (e.g. events that do not escape an org) */
            if (STK->evt == CEU_IN__NONE) {
                break;  /* invalidated emit or freed organism */
            }

#ifdef CEU_DEBUG_TRAILS
printf("STACK[%d]: evt=%d : seqno=%d\n", stack_curi(&go), STK->evt, app->seqno);
#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
printf("\torg=%p/%d : [%d/%p]\n", STK_ORG, STK_ORG==app->data, STK_ORG->n, STK_ORG->trls);
#else
printf("\tntrls=%d\n", CEU_NTRAILS);
#endif
#endif

#ifdef CEU_CLEAR
            if (STK->trl == STK->stop) {    /* bounded trail traversal? */
                STK->stop = NULL;           /* back to default */
/* TODO: precisa desse NULL? */
                break;                      /* pop stack */
            }
#endif

            /* STK_ORG has been traversed to the end? */
            if (STK->trl ==
                &STK_ORG->trls[
#if defined(CEU_ORGS) || defined(CEU_OS_KERNEL)
                    STK_ORG->n
#else
                    CEU_NTRAILS
#endif
                ])
            {
                /* end of traversal, reached the end of top org */
                if (STK_ORG == app->data) {
                    break;  /* pop stack */
                }

#ifdef CEU_ORGS
                else {
                    /* save current org before setting the next traversal */
                    tceu_org* old = STK_ORG;
                    int to_kill_free = (STK->evt==CEU_IN__CLEAR && old->n!=0);

                    /* should pop this level as it was a
                     * bounded CLEAR on the given ORG */
                    if (to_kill_free && STK->stop==(void*)old) {
                        stack_pop(&go);
#ifdef CEU_ORGS_POOL_ITERATOR
                        ceu_pool_iterator_kill(old);
#endif
                            /* remove myself from all "nxt" iterations from all
                             * pools (point to the one in sequence) */
                        ceu_sys_org_kill(app, &go, old);
#ifdef CEU_ORGS_NEWS
                        ceu_sys_org_free(old);
#endif
                        continue;
                    }

                    /* traverse next org */
                    STK_ORG_ATTR = old->nxt;
                    STK->trl = &((tceu_org*)old->nxt)->trls [
                                (old->n == 0) ?
                                ((tceu_org_lnk*)old)->lnk : 0
                              ];
#ifdef CEU_ORGS_NEWS
                    if (to_kill_free) {
#if 0
                        "kill" only while in scope
#endif
#ifdef CEU_ORGS_WATCHING
                        tceu_stk stk = *stack_cur(&go);
                        stack_pop(&go); /* only if "kill" emit ok_killed */
#endif
                        ceu_sys_org_kill(app, &go, old);
                        ceu_sys_org_free(old);
#ifdef CEU_ORGS_WATCHING
                        stack_push(&go, &stk, NULL);
#endif
                    }
#endif
                    continue;
                }
#endif  /* CEU_ORGS */
            }

            /* continue traversing current org */

#ifdef CEU_DEBUG_TRAILS
#ifdef CEU_ORGS
if (STK->trl->evt==CEU_IN__ORG) {
    printf("\tTRY[%p] : evt=%d : seqno=%d : stk=%d : lbl=%d : org=%p->%p\n",
        STK->trl, STK->trl->evt, STK->trl->stk, STK->trl->seqno, STK_LBL,
        &STK->trl->lnks[0], &STK->trl->lnks[1]);
} else
#endif
{
    printf("\tTRY[%p] : evt=%d : seqno=%d : stk=%d : lbl=%d\n",
        STK->trl, STK->trl->evt, STK->trl->stk, STK->trl->seqno, STK_LBL);
}
#endif

            /* jump into linked orgs */
#ifdef CEU_ORGS
            if ( (STK->trl->evt == CEU_IN__ORG)
#ifdef CEU_PSES
              || (STK->trl->evt==CEU_IN__ORG_PSED && STK->evt==CEU_IN__CLEAR)
#endif
               )
            {
                if (STK->evt == CEU_IN__CLEAR) {
                    STK->trl->evt = CEU_IN__NONE;
                }
                /* TODO(speed): jump LST */
                STK_ORG_ATTR = STK->trl->lnks[0].nxt;   /* jump FST */
                STK->trl = &STK_ORG->trls[0];
                continue; /* restart */
            }
#endif /* CEU_ORGS */

            /* EXECUTE THIS TRAIL */
            if ( (STK->trl->evt != CEU_IN__NONE)
                        /* something to execute */
            &&   (
                   (STK->trl->evt==CEU_IN__STK && STK->trl->stk==stack_curi(&go))
                        /* stacked and in this level */
               ||  (STK->trl->evt==STK->evt && STK->evt!=CEU_IN__STK &&
                     (  STK->evt==CEU_IN__CLEAR
                     || STK->trl->seqno!=app->seqno )
                   )
                        /* same event and (clear||await-before) */
                 )
            ) {
                int _ret;
                STK->trl->evt = CEU_IN__NONE;  /* clear trail */

#if defined(CEU_OS_KERNEL) && defined(__AVR)
                CEU_APP_ADDR = app->addr;
#endif

                /*** CODE ***/
                _ret = app->code(app, &go);

#if defined(CEU_OS_KERNEL) && defined(__AVR)
                CEU_APP_ADDR = 0;
#endif

                switch (_ret) {
                    case RET_HALT:
                        break;
#if defined(CEU_INTS) || defined(CEU_CLEAR) || defined(CEU_ORGS)
                    case RET_RESTART:
                        continue; /* restart */
#endif
#ifdef CEU_ASYNCS
                    case RET_ASYNC:
#ifdef ceu_out_async
                        ceu_out_async(app);
#endif
                        app->pendingAsyncs = 1;
                        break;
#endif
#ifdef CEU_RET
                    case RET_QUIT:
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
                        app->isAlive = 0;
                        CEU_GC = 1;
#endif
#ifdef CEU_LUA
                        lua_close(app->lua);
#endif
                        goto _CEU_GO_QUIT_;
#endif
                    default:
#ifdef CEU_DEBUG
                        ceu_sys_assert(0);
#endif
                        break;
                }
            }

            /* DON'T EXECUTE THIS TRAIL */
            else
            {
                if (STK->evt==CEU_IN__CLEAR
#ifdef CEU_CLEAR
                    && STK->cnt!=STK->trl
#endif
                    ) {
                    STK->trl->evt = CEU_IN__NONE;    /* trail cleared */
                }
            }

            /* NEXT TRAIL */

            if (STK->trl->evt!=CEU_IN__STK && STK->trl->seqno!=app->seqno) {
                STK->trl->seqno = app->seqno-1;   /* keeps the gap tight */
            }

            STK->trl++;
        }

        stack_pop(&go);
        if (stack_empty(&go)) {
            break;      /* reaction has terminated */
        }
    }

_CEU_GO_QUIT_:;

#ifdef CEU_WCLOCKS
    if (evt==CEU_IN__WCLOCK) {
#ifdef ceu_out_wclock_set
        /* no new sets, signal inactive */
        if (app->wclk_min_set == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late = 0;
    }
#ifdef CEU_TIMEMACHINE
    if (evt==CEU_IN__WCLOCK_) {
#ifdef ceu_out_wclock_set
        if (app->wclk_min_set_ == CEU_WCLOCK_INACTIVE) {
            ceu_out_wclock_set(CEU_WCLOCK_INACTIVE);
        }
#endif
        app->wclk_late_ = 0;
    }
#endif
#endif
}

int ceu_go_all (tceu_app* app)
{
    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    app->init(app);     /* calls CEU_THREADS_MUTEX_LOCK() */

#ifdef CEU_IN_OS_START
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
    if (app->isAlive)
#endif
    {
        ceu_sys_go(app, CEU_IN_OS_START, NULL);
    }
#endif

#ifdef CEU_ASYNCS
    while(
#if defined(CEU_RET) || defined(CEU_OS_KERNEL)
            app->isAlive &&
#endif
            (
#ifdef CEU_THREADS
                app->threads_n>0 ||
#endif
                app->pendingAsyncs
            ) )
    {
        ceu_sys_go(app, CEU_IN__ASYNC, NULL);
#ifdef CEU_THREADS
        CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
        /* allow threads to also execute */
        CEU_THREADS_MUTEX_LOCK(&app->threads_mutex);
#endif
    }
#endif

#ifdef CEU_THREADS
    CEU_THREADS_MUTEX_UNLOCK(&app->threads_mutex);
#endif

#ifdef CEU_NEWS
#ifdef CEU_RUNTESTS
    ceu_out_assert(_ceu_dyns_ == 0, "memory leak");
#endif
#endif

#ifdef CEU_RET
    return app->ret;
#else
    return 0;
#endif
}

/**********************************************************************
 * Only the OS kernel needs any of the below.
 **********************************************************************/

#ifdef CEU_OS_KERNEL

/*
 * SYS_VECTOR:
 */
void* CEU_SYS_VEC[CEU_SYS_MAX] __attribute__((used)) = {
    (void*) &ceu_sys_assert,
    (void*) &ceu_sys_log,
    (void*) &ceu_sys_realloc,
    (void*) &ceu_sys_req,
    (void*) &ceu_sys_load,
#ifdef CEU_ISR
    (void*) &ceu_sys_isr,
#endif
#ifdef CEU_CLEAR
    (void*) &ceu_sys_clear,
#endif
    (void*) &ceu_sys_stack_push,
#ifdef CEU_ORGS
    (void*) &ceu_sys_stack_clear_org,
#endif
    (void*) &ceu_sys_org,
#ifdef CEU_ORGS
    (void*) &ceu_sys_org_trail,
    (void*) &ceu_sys_org_spawn,
#endif
    (void*) &ceu_sys_start,
    (void*) &ceu_sys_link,
    (void*) &ceu_sys_unlink,
    (void*) &ceu_sys_emit,
    (void*) &ceu_sys_call,
#ifdef CEU_WCLOCKS
    (void*) &ceu_sys_wclock,
#endif
    (void*) &ceu_sys_go
};

/*****************************************************************************
 * QUEUE
 * - 256 avoids doing modulo operations
 * - n: number of entries
 * - 0: next position to consume
 * - i: next position to enqueue
 */
#if CEU_QUEUE_MAX == 256
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u8   QUEUE_get = 0;
    u8   QUEUE_put = 0;
#else
    byte QUEUE[CEU_QUEUE_MAX] = {0};    /* {0} avoids .bss */
    int  QUEUE_tot = 0;
    u16  QUEUE_get = 0;
    u16  QUEUE_put = 0;
#endif

tceu_queue* ceu_sys_queue_get (void) {
    tceu_queue* ret;
    CEU_ISR_OFF();
    if (QUEUE_tot == 0) {
        ret = NULL;
    } else {
#ifdef CEU_DEBUG
        ceu_sys_assert(QUEUE_tot > 0);
#endif
        ret = (tceu_queue*) &QUEUE[QUEUE_get];
    }
    CEU_ISR_ON();
    return ret;
}

int ceu_sys_queue_put (tceu_app* app, tceu_nevt evt, int sz, byte* buf) {
    CEU_ISR_OFF();

    int n = sizeof(tceu_queue) + sz;

    if (QUEUE_tot+n > CEU_QUEUE_MAX) {
        return 0;   /* TODO: add event FULL when CEU_QUEUE_MAX-1 */
    }

    /* An event+data must be continuous in the QUEUE. */
    if (QUEUE_put+n+sizeof(tceu_queue)>=CEU_QUEUE_MAX && evt!=CEU_IN__NONE) {
        int fill = CEU_QUEUE_MAX - QUEUE_put - sizeof(tceu_queue);
        /*_ceu_sys_emit(app, CEU_IN__NONE, param, fill, NULL);*/
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = CEU_IN__NONE;
        qu->sz  = fill;
        QUEUE_put += sizeof(tceu_queue) + fill;
        QUEUE_tot += sizeof(tceu_queue) + fill;
    }

    {
        tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_put];
        qu->app = app;
        qu->evt = evt;
        qu->sz  = sz;
        memcpy(qu->buf, buf, sz);
    }
    QUEUE_put += n;
    QUEUE_tot += n;

    CEU_ISR_ON();
    return 1;
}

void ceu_sys_queue_rem (void) {
    CEU_ISR_OFF();
    tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get];
    QUEUE_tot -= sizeof(tceu_queue) + qu->sz;
    QUEUE_get += sizeof(tceu_queue) + qu->sz;
    CEU_ISR_ON();
}

/*****************************************************************************/

static tceu_app* CEU_APPS = NULL;
static tceu_lnk* CEU_LNKS = NULL;

#ifdef CEU_RET
    int ok  = 0;
    int ret = 0;
#endif

/* TODO: remove this indirection */
int ceu_sys_emit (tceu_app* app, tceu_nevt evt, int sz, void* param) {
    return ceu_sys_queue_put(app, evt, sz, param);
}

void* ceu_sys_call (tceu_app* app, tceu_nevt evt, void* param) {
    tceu_lnk* lnk = CEU_LNKS;
    for (; lnk; lnk=lnk->nxt)
    {
        if (app!=lnk->src_app || evt!=lnk->src_evt) {
            continue;
        }
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        void* __old = CEU_APP_ADDR; /* must remember to resume after call */
        CEU_APP_ADDR = lnk->dst_app->addr;
#endif
        void* ret = lnk->dst_app->calls(lnk->dst_app, lnk->dst_evt, param);
#if defined(CEU_OS_KERNEL) && defined(__AVR)
        CEU_APP_ADDR = __old;
#endif
        return ret;
    }
/* TODO: error? */
    return NULL;
}

static void _ceu_sys_unlink (tceu_lnk* lnk) {
    /* remove as head */
    if (CEU_LNKS == lnk) {
        CEU_LNKS = lnk->nxt;
/* TODO: prv */
    /* remove in the middle */
    } else {
        tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt!=NULL && cur->nxt!=lnk) {
			cur = cur->nxt;
        }
        if (cur->nxt != NULL) {
            cur->nxt = lnk->nxt;
        }
	}

    /*lnk->nxt = NULL;*/
    ceu_sys_realloc(lnk, 0);
}

static void __ceu_os_gc (void)
{
    if (! CEU_GC) return;
    CEU_GC = 0;

    /* remove pending events */
    {
        CEU_ISR_OFF();
        int i = 0;
        while (i < QUEUE_tot) {
            tceu_queue* qu = (tceu_queue*) &QUEUE[QUEUE_get+i];
            if (qu->app!=NULL && !qu->app->isAlive) {
                qu->evt = CEU_IN__NONE;
            }
            i += sizeof(tceu_queue) + qu->sz;
        }
        CEU_ISR_ON();
    }

    /* remove broken links */
    {
        tceu_lnk* cur = CEU_LNKS;
        while (cur != NULL) {
            tceu_lnk* nxt = cur->nxt;
            if (!cur->src_app->isAlive || !cur->dst_app->isAlive) {
                _ceu_sys_unlink(cur);
            }
            cur = nxt;
        }
    }

    /* remove dead apps */
    tceu_app* app = CEU_APPS;
    tceu_app* prv = NULL;
    while (app)
    {
        tceu_app* nxt = app->nxt;

        if (app->isAlive) {
            prv = app;

        } else {
            if (CEU_APPS == app) {
                CEU_APPS = nxt;     /* remove as head */
            } else {
                prv->nxt = nxt;     /* remove in the middle */
            }

            /* unlink all "from app" or "to app" */
            ceu_sys_unlink(app,0, 0,0);
            ceu_sys_unlink(0,0, app,0);

#ifdef CEU_RET
            ok--;
            ret += app->ret;
#endif

            /* free app memory */
            ceu_sys_realloc(app->data, 0);
            ceu_sys_realloc(app, 0);
        }

        app = nxt;
    }
}

#ifdef CEU_ISR

typedef struct {
    tceu_isr_f f;
    tceu_app*  app;
} tceu_isr;

#define CEU_ISR_MAX 40
tceu_isr CEU_ISR_VEC[CEU_ISR_MAX];

int ceu_sys_isr (int n, tceu_isr_f f, tceu_app* app) {
    tceu_isr* isr = &CEU_ISR_VEC[(n-1)];
    if (f==NULL || isr->f==NULL) {
        isr->f   = ((word)app->addr>>1) + f;
        isr->app = app;
                           /* "f" is relative to "app", make it absolute */
        return 1;
    } else {
        return 0;
    }
}
#endif

void ceu_os_init (void) {
#ifdef CEU_ISR
    int i;
    for (i=0; i<CEU_ISR_MAX; i++) {
        CEU_ISR_VEC[i].f = NULL;      /* TODO: is this required? (bss=0) */
    }
    CEU_ISR_ON();       /* enable global interrupts to start */
#endif
}

int ceu_os_scheduler (int(*dt)())
{
    /*
     * Intercalate DT->WCLOCK->ASYNC->QUEUE->...
     * QUEUE last to separate app->init() from OS_START.
     * QUEUE handles one event at a time to intercalate with WCLOCK.
     * __ceu_os_gc() only if QUEUE is emtpy: has to keep data from events 
     * accessible.
     */

#ifdef CEU_RET
    while (ok > 0)
#else
    while (1)
#endif
    {
#if defined(CEU_WCLOCKS) || defined(CEU_IN_OS_DT)
        s32 _dt = dt();
#endif

        /* DT */
#ifdef CEU_IN_OS_DT
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN_OS_DT, &dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_IN_OS_DT */

        /* WCLOCK */
#ifdef CEU_WCLOCKS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
/*
#error TODO: CEU_IN__WCLOCK_
*/
                ceu_sys_go(app, CEU_IN__WCLOCK, &_dt);
                app = app->nxt;
            }
        }
#endif	/* CEU_WCLOCKS */

        /* ASYNC */
#ifdef CEU_ASYNCS
        {
            tceu_app* app = CEU_APPS;
            while (app) {
                ceu_sys_go(app, CEU_IN__ASYNC, NULL);
                app = app->nxt;
            }
        }
#endif	/* CEU_ASYNCS */

        /* EVENTS */
        {
            /* clear the current size (ignore events emitted here) */
            CEU_ISR_OFF();
            int tot = QUEUE_tot;
            CEU_ISR_ON();
            if (tot > 0)
            {
                tceu_queue* qu = ceu_sys_queue_get();
                tot -= sizeof(tceu_queue) + qu->sz;
                if (qu->evt == CEU_IN__NONE) {
                    /* nothing; */
                    /* "fill event" */

                /* global events (e.g. OS_START, OS_INTERRUPT) */
                } else if (qu->app == NULL) {
                    tceu_app* app = CEU_APPS;
                    while (app) {
                        ceu_sys_go(app, qu->evt, qu->buf);
                        app = app->nxt;
                    }

                } else {
                    /* linked events */
                    tceu_lnk* lnk = CEU_LNKS;
                    while (lnk) {
                        if ( qu->app==lnk->src_app
                        &&   qu->evt==lnk->src_evt
                        &&   lnk->dst_app->isAlive ) {
                            ceu_sys_go(lnk->dst_app, lnk->dst_evt, qu->buf);
                        }
                        lnk = lnk->nxt;
                    }
                }

                ceu_sys_queue_rem();
            }
            else
            {
                __ceu_os_gc();     /* only when queue is empty */
            }
        }
    }

#ifdef CEU_RET
    return ret;
#else
    return 0;
#endif
}

/* LOAD / START */

tceu_app* ceu_sys_load (void* addr)
{
    uint       size;
    tceu_init* init;
#ifdef CEU_OS_LUAIFC
    char*      luaifc;
#endif

#ifdef __AVR
    ((tceu_export) ((word)addr>>1))(&size, &init);
#else
    ((tceu_export) addr)(&size, &init
#ifdef CEU_OS_LUAIFC
                        , &luaifc
#endif
                        );
#endif

    tceu_app* app = (tceu_app*) ceu_sys_realloc(NULL, sizeof(tceu_app));
    if (app == NULL) {
        return NULL;
    }

    app->data = (tceu_org*) ceu_sys_realloc(NULL, size);
    if (app->data == NULL) {
        return NULL;
    }

    app->sys_vec = CEU_SYS_VEC;
    app->nxt = NULL;

    /* Assumes sizeof(void*)==sizeof(WORD) and
        that gcc will word-align SIZE/INIT */
#ifdef __AVR
    app->init = (tceu_init) (((word)addr>>1) + (word)init);
#else
    app->init = (tceu_init) ((word)init);
#endif
    app->addr = addr;

#ifdef CEU_OS_LUAIFC
    app->luaifc = luaifc;
#endif

    return app;
}

void ceu_sys_start (tceu_app* app)
{
    /* add as head */
	if (CEU_APPS == NULL) {
		CEU_APPS = app;

    /* add to tail */
    } else {
		tceu_app* cur = CEU_APPS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
        cur->nxt = app;
    }

    /* MAX OK */
#ifdef CEU_RET
    ok++;
#endif

    /* INIT */

/*
printf(">>> %p %X %p[%x %x %x %x %x]\n", addr, size, init,
        ((unsigned char*)init)[5],
        ((unsigned char*)init)[6],
        ((unsigned char*)init)[7],
        ((unsigned char*)init)[8],
        ((unsigned char*)init)[9]);
printf("<<< %d %d\n", app->isAlive, app->ret);
*/

    app->init(app);

    /* OS_START */

#ifdef CEU_IN_OS_START
    ceu_sys_emit(NULL, CEU_IN_OS_START, 0, NULL);
#endif
}

/* LINK & UNLINK */

int ceu_sys_link (tceu_app* src_app, tceu_nevt src_evt,
                  tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* lnk = (tceu_lnk*) ceu_sys_realloc(NULL, sizeof(tceu_lnk));
    if (lnk == NULL) {
        return 0;
    }

    lnk->src_app = src_app;
    lnk->src_evt = src_evt;
    lnk->dst_app = dst_app;
    lnk->dst_evt = dst_evt;
    lnk->nxt = NULL;

    /* add as head */
	if (CEU_LNKS == NULL) {
		CEU_LNKS = lnk;

    /* add to tail */
    } else {
		tceu_lnk* cur = CEU_LNKS;
        while (cur->nxt != NULL) {
            cur = cur->nxt;
        }
		cur->nxt = lnk;
    }

    return 1;
}

int ceu_sys_unlink (tceu_app* src_app, tceu_nevt src_evt,
                    tceu_app* dst_app, tceu_nevt dst_evt)
{
    tceu_lnk* cur = CEU_LNKS;
    while (cur != NULL) {
        tceu_lnk* nxt = cur->nxt;
        if ( (src_app==0 || src_app==cur->src_app)
          && (src_evt==0 || src_evt==cur->src_evt)
          && (dst_app==0 || dst_app==cur->dst_app)
          && (dst_evt==0 || dst_evt==cur->dst_evt) ) {
            _ceu_sys_unlink(cur);
        }
        cur = nxt;
    }
    return 0;
}

#ifdef CEU_ISR

/* Foreach ISR, call ceu_sys_emit(CEU_IN_OS_INTERRUPT). */

#define GEN_ISR(n)                                                  \
    ISR(__vector_ ## n, ISR_BLOCK) {                                \
        tceu_isr* isr = &CEU_ISR_VEC[n-1];                          \
        if (isr->f != NULL) {                                       \
            CEU_APP_ADDR = isr->app->addr;                          \
            isr->f(isr->app, isr->app->data);                       \
            CEU_APP_ADDR = 0;                                       \
        }                                                           \
        ceu_sys_emit(NULL,CEU_IN_OS_INTERRUPT,CEU_EVTP(n),0,NULL); \
    }
#define _GEN_ISR(n)

GEN_ISR(20);
/*
GEN_ISR( 1) GEN_ISR( 2) GEN_ISR( 3) GEN_ISR( 4) GEN_ISR( 5)
GEN_ISR( 6) GEN_ISR( 7) GEN_ISR( 8) GEN_ISR( 9) GEN_ISR(10)
GEN_ISR(11) GEN_ISR(12) GEN_ISR(13) GEN_ISR(14) GEN_ISR(15)
GEN_ISR(16) GEN_ISR(17) _GEN_ISR(18) GEN_ISR(19) GEN_ISR(20)
GEN_ISR(21) GEN_ISR(22) GEN_ISR(23) GEN_ISR(24) GEN_ISR(25)
GEN_ISR(26) GEN_ISR(27) GEN_ISR(28) GEN_ISR(29) GEN_ISR(30)
GEN_ISR(31) GEN_ISR(32) GEN_ISR(33) GEN_ISR(34) GEN_ISR(35)
GEN_ISR(36) GEN_ISR(37) GEN_ISR(38) GEN_ISR(39) GEN_ISR(40)
*/

#endif /* CEU_ISR */

#endif /* ifdef CEU_OS_KERNEL */

#endif /* ifndef CEU_OS_APP */
]====],
    ceu_pool_h =
        [====[
#ifndef _CEU_POOL_H
#define _CEU_POOL_H

#include "ceu_os.h"     /* TODO: pool should not depend on tceu_* */
#include "ceu_types.h"

/* TODO: all "int" here, should evaluate the correct unsigned type */

typedef struct {
    tceu_org_lnk** lnks;
                    /* lnks at 0-offset to share same struct with dynamic */
                    /* TODO: "lnks" field is unused for adt */
                    /* TODO: "lnks" field makes no sense for non-Ceu pools */
                    /* TODO: move it to an enclosing struct */
    byte**  queue;
                    /* queue is in the next offset to distinguish dynamic(NULL)
                       from static pools(any-address) */
    int     size;
    int     free;
    int     index;
    int     unit;
    byte*   mem;
} tceu_pool;

#define CEU_POOL_DCL(name, type, size) \
    type*     name##_queue[size];      \
    type      name##_mem[size];        \
    tceu_pool name;

void ceu_pool_init (tceu_pool* pool, int size, int unit, tceu_org_lnk** lnks,
                    byte** queue, byte* mem);
byte* ceu_pool_alloc (tceu_pool* pool);
void ceu_pool_free (tceu_pool* pool, byte* val);
#endif
]====],
    ceu_pool_c =
        [====[
/*
 * Ceu pool.c is based on Contiki and TinyOS pools:
 * https://github.com/contiki-os/contiki/blob/master/core/lib/memb.c
 * https://github.com/tinyos/tinyos-main/blob/master/tos/system/PoolP.nc
 */
#ifndef _CEU_POOL_C
#define _CEU_POOL_C

#include <stdlib.h>
#include "ceu_pool.h"

void ceu_pool_init (tceu_pool* pool, int size, int unit, tceu_org_lnk** lnks,
                    byte** queue, byte* mem)
{
    int i;
    pool->size  = size;
    pool->free  = size;
    pool->index = 0;
    pool->unit  = unit;
    pool->lnks  = lnks;
    pool->queue = queue;
    pool->mem   = mem;
    for (i=0; i<size; i++) {
        queue[i] = &mem[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->size) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    int empty = pool->index + pool->free;
    if (empty >= pool->size) {
        empty -= pool->size;
    }
    pool->queue[empty] = val;
    pool->free++;
}

/*
int ceu_pool_inside (tceu_pool* pool, byte* val) {
    return ((byte*)val >= pool->mem)
        && ((byte*)val < pool->mem+(pool->size*pool->unit));
}
*/

#endif
]====],
}
OPTS_NPARAMS = {
    version   = 0,
    input     = nil,

    out_c     = 1,
    out_h     = 1,
    out_s     = 1,
    out_f     = 1,

    join      = 0,
    c_calls   = 1,

    cpp       = 0,
    cpp_exe   = 1,
    cpp_args  = 1,

    safety    = 1,

    tp_word   = 1,

    os        = 0,
    os_luaifc = 0,

    timemachine = 0,
}

OPTS = {
    input     = nil,

    out_c     = '_ceu_app.c',
    out_h     = '_ceu_app.h',
    out_s     = 'CEU_SIZE',
    out_f     = 'ceu_app_init',

    join      = true,
    c_calls   = nil,    -- [nil=accept]

    cpp       = true,
    cpp_exe   = 'cpp',
    cpp_args  = false,

    safety    = 0,

    tp_word   = 4,

    os        = false,
    os_luaifc = false,

    timemachine = false,
}

local params = {...}
local i = 1
while i <= #params
do
    local p = params[i]
    i = i + 1

    if p == '-' then
        OPTS.input = '-'

    elseif string.sub(p, 1, 2) == '--' then
        local no = false
        local opt = string.gsub(string.sub(p,3), '%-', '_')
        if string.find(opt, '^no_') then
            no = true
            opt = string.sub(opt, 4)
        end
        if OPTS_NPARAMS[opt]==0 or OPTS_NPARAMS[opt]==nil then
            OPTS[opt] = not no
        else
            local opt = string.gsub(string.sub(p,3), '%-', '_')
            OPTS[opt] = string.match(params[i], "%'?(.*)%'?")
            i = i + 1
        end

    else
        OPTS.input = p
    end
end

if OPTS.version then
    print 'ceu 0.9'
    os.exit(0)
end

if OPTS.safety then
    OPTS.safety = assert(tonumber(OPTS.safety), '`--safety´ must be a number')
end

if OPTS.os_luaifc then
    assert(OPTS.os, '`--os-luaifc´ requires `--os´')
end

if not OPTS.input then
    io.stderr:write([[

    ./ceu <filename>           # Ceu input file, or `-´ for stdin
    
        --out-c <filename>     # C output source file (_ceu_app.c)
        --out-h <filename>     # C output header file (_ceu_app.h)
        --out-s <NAME>         # TODO (CEU_SIZE)
        --out-f <NAME>         # TODO (ceu_app_init)
    
        --join (--no-join)     # join lines enclosed by /*{-{*/ and /*}-}*/ (join)
        --c-calls              # TODO

        --cpp (--no-cpp)       # preprocess the input with `cpp´ (no-cpp)
        --cpp-exe              # preprocessor executable (cpp)
        --cpp-args             # preprocess the input with `cpp´ passing arguments in between `"´ (no)

        --safety <LEVEL>       # safety checks (*0=none*, 1=event, 2=par)

        --tp-word <SIZE>       # sizeof a word in bytes (4)

        --version              # version of Ceu

        --os                   # TODO
        --os-luaifc            # TODO

        --timemachine          # TODO
]])
    os.exit(1)
end

-- C_CALLS
if OPTS.c_calls then
    local t = {}
    for v in string.gmatch(OPTS.c_calls, "([_%w]+)") do
        t[v] = true
    end
    OPTS.c_calls = t
end


-- INPUT
local inp
if OPTS.input == '-' then
    inp = io.stdin
else
    inp = assert(io.open(OPTS.input))
end
local source = inp:read'*a'

OPTS.source = source

-- PARSE
do
    
do
TP = {
    types = {}
}

local __empty = {}
function TP.get (id)
    return TP.types[id] or __empty
end

function TP.new (me, dont_generate)
    if me.tag == 'Type' then
        local id, ptr, arr, ref, opt = unpack(me)

        me.id  = id
        me.ptr = ptr
        me.arr = arr
        me.ref = ref
        me.opt = opt
        me.ext = (id=='@') or
                 (string.sub(id,1,1)=='_' and string.sub(id,1,8)~='_Option_')
        me.hold = true      -- holds by default

        -- set from outside (see "types" above and Dcl_nat in env.lua)
        me.prim  = false     -- if primitive
        me.num   = false     -- if numeric
        me.len   = nil       -- sizeof type
        me.plain = false     -- if plain type (no pointers inside it)

-- TODO: remove?
        if ENV and me.ext and (not ENV.c[me.id]) then
            ENV.c[me.id] = { tag='type', id=me.id, len=nil, mod=nil }
        end

    else
        AST.asr(me, 'TupleType')
        me.id  = nil
        me.ptr = (#me==1 and 0) or 1
        me.arr = false
        me.ref = false
        me.ext = false

        me.tup = {}
        for i, t in ipairs(me) do
            local hold, tp, _ = unpack(t)
            tp.hold = hold

            if tp.id=='void' and tp.ptr==0 then
                ASR(#me==1, me, 'invalid type')
                me[1] = nil     -- empty tuple
                break
            end

            -- TODO: workaround: error when generating nested ADTs
            if ENV.adts[tp.id] then
                dont_generate = true
            end

            me.tup[#me.tup+1] = tp
        end

        if not (dont_generate or AST.par(me,'Dcl_fun')) then
            TP.types[TP.toc(me)] = me     -- dump typedefs
        end
    end
    return me
end

OPTS.tp_word = assert(tonumber(OPTS.tp_word),
    'missing `--tp-word´ parameter')

-- primitive / numeric / len
local types = {
    void  = { true, false, 0 },
    char  = { true, true, 1 },
    byte  = { true, true, 1 },
    bool  = { true, true, 1 },
    word  = { true, true, OPTS.tp_word },
    uint  = { true, true, OPTS.tp_word },
    int   = { true, true, OPTS.tp_word },
    u64   = { true, true, 8 },
    s64   = { true, true, 8 },
    u32   = { true, true, 4 },
    s32   = { true, true, 4 },
    u16   = { true, true, 2 },
    s16   = { true, true, 2 },
    u8    = { true, true, 1 },
    s8    = { true, true, 1 },
    float = { true, true, OPTS.tp_word },
    f32   = { true, true, 4 },
    f64   = { true, true, 8 },

    pointer   = { false, false, OPTS.tp_word },
    tceu_ncls = { false, false, true }, -- len set in "env.lua"
    tceu_nlbl = { false, false, true }, -- len set in "labels.lua"
}
for id, t in pairs(types) do
    TP.types[id] = TP.new{ tag='Type', id, 0, false, false }
    TP.types[id].prim = t[1]
    TP.types[id].num  = t[2]
    TP.types[id].len  = t[3]
end

function TP.n2bytes (n)
    if n < 2^8 then
        return 1
    elseif n < 2^16 then
        return 2
    elseif n < 2^32 then
        return 4
    end
    error'out of bounds'
end

function TP.copy (t)
    local ret = {}
    for k,v in pairs(t) do
        ret[k] = v
    end
    return ret
end

function TP.fromstr (str)
    local id, ptr, ref = string.match(str, '^(.-)(%**)(%&?)$')
    assert(id and ptr and ref)
    ptr = (id=='@' and 1) or string.len(ptr);
    ref = (ref=='&')
    return TP.new{ tag='Type', id, ptr, false, ref }
end

function TP.toc (tp)
    if tp.tup then
        local t = { 'tceu' }
        for _, v in ipairs(tp.tup) do
            t[#t+1] = TP.toc(v)
            if v.hold then
                t[#t] = t[#t] .. 'h'
            end
        end
        return string.gsub(table.concat(t,'__'),'%*','_')
    end

    local ret = tp.id

    if ENV.clss[tp.id] or ENV.adts[tp.id] then
        ret = 'CEU_'..ret
    end

    ret = ret .. string.rep('*',tp.ptr)

    if tp.arr then
        --error'not implemented'
        ret = ret .. '*'
    end

    if tp.ref then
        ret = ret .. '*'
    end

    return (string.gsub(ret,'^_', ''))
end

function TP.tostr (tp)
    if tp.tup then
        local ret = {}
        for _, t in ipairs(tp.tup) do
            ret[#ret+1] = TP.tostr(t)
        end
        return '('..table.concat(ret,',')..')'
    end

    local ret = tp.id
    ret = ret .. string.rep('*',tp.ptr)
    if tp.arr then
        ret = ret .. '[]'
    end
    if tp.ref then
        ret = ret .. '&'
    end
    return ret
end

function TP.isFloat (tp)
    return (tp.id=='float' or tp.id=='f32' or tp.id=='f64')
            and tp.ptr==0 and (not tp.arr)
end

function TP.isNumeric (tp)
    return TP.get(tp.id).num and tp.ptr==0 and (not tp.arr)
            or (tp.ext and tp.ptr==0)
            or tp.id=='@'
end

function TP.t2tup (t)
    local tup = {}
    for _, v in ipairs(t) do
        tup[#tup+1] = v.tp
        assert(v.tp)
    end
    return tup
end

local function __err (tp1, tp2)
    return 'types mismatch (`'..TP.tostr(tp1)..'´ <= `'..TP.tostr(tp2)..'´)'
end
function TP.contains (tp1, tp2)
    if tp1.tup or tp2.tup then
        if tp1.tup and tp2.tup then
            if #tp1.tup == #tp2.tup then
                for i=1, #tp1.tup do
                    local t1 = tp1.tup[i]
                    local t2 = tp2.tup[i]
                    local ok, msg = TP.contains(t1,t2)
                    if not ok then
                        return false, 'wrong argument #'..i..' : '..msg
                    end
                end
                return true
            end
        end
        return false, 'arity mismatch'
    end

    -- same type
    if tp1.id==tp2.id and tp1.ptr==tp2.ptr then
        if (tp1.arr==false) and (tp2.arr==false) then
            return true
        elseif tp1.ref then
            if tp1.arr==true and tp2.arr then
                -- pool int[10] arr
                -- pool int[]&  ref = arr;
                return true
            elseif type(tp1.arr)=='table' and type(tp2.arr)=='table' then
                -- pool int[10]  arr
                -- pool int[10]& ref = arr;
                if tp1.arr[1] == tp2.arr[2] then
                    return true
                end
            end
            return true
        end
    end

    -- var tp& v = &/*/<any-ext-value>
    if tp1.ref and tp2.id=='@' then
        return true
    end

    -- tp[] = tp*
    -- tp*  = tp[]
    if tp1.id==tp2.id and ((tp1.ptr==1 and tp2.arr) or (tp2.ptr==1 and tp1.arr))
                      and tp1.ref==tp2.ref then
        return true
    end

    -- any type (calls, Lua scripts)
    if tp1.id=='@' or tp2.id=='@' then
        return true
    end

    -- both are numeric
    if TP.isNumeric(tp1) and TP.isNumeric(tp2) then
        return true
    end

    -- compatible classes (same classes is handled above)
    local cls1 = ENV.clss[tp1.id]
    local cls2 = ENV.clss[tp2.id]
    if cls1 and cls2 then
        if tp1.ref or tp2.ref or (tp1.ptr>0 and tp2.ptr>0) then
            if tp1.ptr == tp2.ptr then
                local ok = cls1.is_ifc and ENV.ifc_vs_cls_or_ifc(cls1,cls2)
                return ok, (ok or __err(tp1,tp2))
            end
        end
        return false, __err(tp1, tp2)
    end

    -- both are pointers
    local ptr2 = (tp2.ptr>0 and tp2.ptr) or (tp2.arr and tp2.ptr+1) or 0
    if tp1.ptr>0 and ptr2>0 then
        if tp1.id=='char' and tp1.ptr==1 -- cast to char*
        or tp1.id=='void' and tp1.ptr==1 -- cast to void*
        or tp1.ext or tp2.ext then       -- let gcc handle
            return true
            -- TODO: void* too???
        end
        if tp2.id == 'null' then
            return true     -- any pointer can be assigned "null"
        end
        return false, __err(tp1,tp2)
    elseif tp1.ptr>0 or ptr2>0 then
        if tp1.ptr>0 and tp2.ext then
            return true
        elseif ptr2>0 and tp1.ext then
            return true
        else
            return false, __err(tp1, tp2)
        end
    end

    -- let external types be handled by gcc
    if tp1.ext or tp2.ext then
        return true
    end

    return false, __err(tp1, tp2)
end

function TP.max (tp1, tp2)
    if TP.contains(tp1, tp2) then
        return tp1
    elseif TP.contains(tp2, tp1) then
        return tp2
    else
        return nil
    end
end

end

    
do
m = require 'lpeg'
m.setmaxstack(1000)

local CNT  = 1
local LINE = 1
local FILE = OPTS.input
local patt

LINES = {
    i2l = {},
}

local open = m.Cmt('/*{-{*/',
    function ()
        if OPTS.join then
            CNT = CNT - 1
        end
        return true
    end )
local close = m.Cmt('/*}-}*/',
    function ()
        if OPTS.join then
            CNT = CNT + 1
        end
        return true
    end )

local line = m.Cmt('\n',
    function (s,i)
        for i=#LINES.i2l, i do
            LINES.i2l[i] = { FILE, LINE }
        end
        if CNT > 0 then
            LINE = LINE + 1
        end
        return true
    end )

local S = (m.S'\t\r ' + m.P'\\'*(1-m.P'\n')^0*'\n')
local SS = S^0

-- #line N "file" :: directive to set line/filename
local dir_lins = m.Cmt( m.P'#' *SS* m.P'line'^-1
                          *SS* m.C(m.R'09'^1)             -- line
                          *SS* ( m.P'"' * m.C((1-m.P'"')^0) * m.P'"'
                              + m.Cc(false) )            -- file
                          * (S + (m.P(1)-'\n'))^0 * '\n' -- \n
                 ,
    function (s,i, line, file)
        LINE = line
        FILE = file
        return true
    end )

patt = (line + open + close + dir_lins + 1)^0

OPTS.source = '#line 1 "'..OPTS.input..'"\n'..OPTS.source

if OPTS.cpp or OPTS.cpp_args then
    local args = OPTS.cpp_args or ''
    if OPTS.timemachine then
        args = args .. ' -DCEU_TIMEMACHINE'
    end
    local orig = (OPTS.input=='-' and 'tmp.ceu')
                    or OPTS.input
    local base, name = string.match(orig, '(.*/)(.*)')
    if not base then
        base = ''
        name = orig
    end

    -- fin, fout, ferr
    local fout = base..'_ceu_cpp_'..name
    local ferr = fout..'.err'
    local fin  = fout..'.in'
    local f = assert( io.open(fin,'w') )
    f:write(OPTS.source)
    f:close()

    -- execute cpp
    local ret = os.execute(OPTS.cpp_exe..' -C -dD '..args..' '..fin
                            ..' > '..fout..' 2>'..ferr)
            -- "-C":  keep comments (because of nesting)
            -- "-dD": repeat #define's (because of macros used as C functions)
    os.remove(fin)
    assert(ret == 0 or ret == true, assert(io.open(ferr)):read'*a')
    os.remove(ferr)

    -- remove blank lines of #define's (because of "-dD")
    OPTS.source = assert(io.open(fout)):read'*a'
    --OPTS.source = string.gsub(OPTS.source, '(#define[^\n]*)(\n)(\n)', '%1%3')
    os.remove(fout)
    --print(OPTS.source)
end

patt:match(OPTS.source..'\n')

-------------------------------------------------------------------------------

function DBG (...)
    local t = {}
    for i=1, select('#',...) do
        t[#t+1] = tostring( select(i,...) )
    end
    if #t == 0 then
        t = { [1]=debug.traceback() }
    end
    io.stderr:write(table.concat(t,'\t')..'\n')
end

function MAX (v1, v2)
    return (v1 > v2) and v1 or v2
end

function WRN (cond, ln, code, msg)
    if cond then
        return cond
    end

    if msg==nil then
        msg = code
        code = '0000'
    end
    ln = (AST.isNode(ln) and ln.ln) or ln
    msg = 'WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg

    if RUNTESTS_file and tonumber(code)>1100 then
        RUNTESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[

==============
]])
    end

    DBG('WRN ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg)
    return cond
end
function ASR (cond, ln, code, msg)
    if cond then
        return cond
    end

    if msg==nil then
        msg = code
        code = '0000'
    end
    ln = (AST.isNode(ln) and ln.ln) or ln
    msg = 'ERR ['..code..'] : '..ln[1]..' : line '..ln[2]..' : '..msg

    if RUNTESTS_file and tonumber(code)>1100 then
        RUNTESTS_file:write([[
==============
]]..msg..[[

--------------
]]..T[1]..[[
--------------
]]..debug.traceback()..[[
==============
]])
    end

    if RUNTESTS then
        return assert(false, msg)
                -- TODO: error(msg) ???
    else
        DBG(msg)
        os.exit(1)
    end
end

end

    
do
local P, C, V, Cc, Ct = m.P, m.C, m.V, m.Cc, m.Ct

local S = V'__SPACES'

local ERR_msg
local ERR_i
local LST_i

local I2TK

local f = function (s, i, tk)
    if tk == '' then
        tk = '<BOF>'
        LST_i = 1           -- restart parsing
        ERR_i = 0           -- ERR_i < 1st i
        ERR_msg = '?'
        I2TK = { [1]='<BOF>' }
    elseif i > LST_i then
        LST_i = i
        I2TK[i] = tk
    end
    return true
end
local K = function (patt, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    ERR_msg = '?'
    return #P(1) * m.Cmt(patt*key, f) * S
end
local CK = function (patt, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    ERR_msg = '?'
    return C(m.Cmt(patt*key, f))*S
end
local EK = function (tk, key)
    key = key and -m.R('09','__','az','AZ','\127\255')
            or P(true)
    return K(P(tk)*key) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected `'..tk.."´"
            end
            return false
        end) * P(false)
end

local KEY = function (str)
    return K(str,true)
end
local EKEY = function (str)
    return EK(str,true)
end
local CKEY = function (str)
    return CK(str,true)
end

local _V2NAME = {
    __Exp = 'expression',
    --__StmtS = 'statement',
    --__StmtB = 'statement',
    --__LstStmt = 'statement',
    --__LstStmtB = 'statement',
    Ext = 'event',
    Var = 'variable/event',
    __ID_nat  = 'identifier',
    __ID_var  = 'identifier',
    __ID_ext  = 'identifier',
    __ID_cls  = 'identifier',
    Type = 'type',
    __ID_field = 'identifier',
    _Dcl_var = 'declaration',
    _Dcl_int = 'declaration',
    _Dcl_pool = 'declaration',
    __Dcl_nat  = 'declaration',
    _Dcl_nat   = 'declaration',
    Dcl_adt_tag = 'declaration',
    _TupleType_1 = 'type list',
    _TupleType_2 = 'param list',
    __adt_expitem = 'parameter',
}
for i=1, 13 do
    _V2NAME['__'..i] = 'expression'
end
local EV = function (rule)
    return V(rule) + m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. _V2NAME[rule]
            end
            return false
        end) * P(false)
end

local EM = function (msg)
    return m.Cmt(P'',
        function (_,i)
            if i > ERR_i then
                ERR_i = i
                ERR_msg = 'expected ' .. msg
                return false
            end
            return true
        end)
end

TYPES = P'void' + 'char' + 'byte' + 'bool' + 'word'
      + 'int' + 'uint'
      + 'u8' + 'u16' + 'u32' + 'u64'
      + 's8' + 's16' + 's32' + 's64'
      + 'float' + 'f32' + 'f64'

KEYS = P'and'     + 'async'    + 'await'    + 'break'    + 'native' + 'native/pre'
     + 'continue' + 'do'
     + 'else'     + 'else/if'  + 'emit'     + 'end'      + 'event'
     + 'every'    + 'finalize' + 'FOREVER'  + 'if'       + 'input'
     + 'loop'     + 'not'      + 'nothing'  + 'null'
     + 'or'       + 'output'   + 'par'      + 'par/and'  + 'par/or'
     + 'pause/if' + 'escape'   + 'sizeof'   + 'then'
     + 'until'    + 'var'      + 'with'
     + TYPES
-- ceu-orgs only
     + 'class'    + 'global'   + 'interface'
     + 'kill'     + 'this' + 'outer'
     + 'spawn'
--
-- export / version
     + 'thread'   + 'sync'
-- functions
     + 'function' + 'call' + 'return' + 'call/rec'
-- isrs
     + 'isr' + 'atomic'
-- bool
     + 'true' + 'false'
-- requests
     + 'input/output' + 'output/input'
-- time
     --+ 'h' + 'min' + 's' + 'ms' + 'us'
-- loop/every
     + 'in'
-- pool
     + 'pool'
     + 'watching'
-- traverse
     + 'traverse'
--
     + P'@' * (
         P'const' + 'hold' + 'nohold' + 'plain' + 'pure' + 'rec' + 'safe'
       )

KEYS = KEYS * -m.R('09','__','az','AZ','\127\255')

local Alpha    = m.R'az' + '_' + m.R'AZ'
local Alphanum = Alpha + m.R'09'
local ALPHANUM = m.R'AZ' + '_' + m.R'09'
local alphanum = m.R'az' + '_' + m.R'09'

NUM = CK(m.R'09'^1) / tonumber

GG = { [1] = CK'' * V'_Stmts' * P(-1)-- + EM'expected EOF')

                -- "Ct" as a special case to avoid "too many captures" (HACK_1)
    , _Stmts  = Ct (( V'__StmtS' * (EK';'*K';'^0) +
                      V'__StmtB' * (K';'^0)
                   )^0
                 * ( V'__LstStmt' * (EK';'*K';'^0) +
                     V'__LstStmtB' * (K';'^0)
                   )^-1
                 * V'Host'^0 )
    , Block  = V'_Stmts'

    , Do     = V'__Do'
    , __Do    = KEY'do' * V'Block' * KEY'end'

    , _GlobalDo = KEY'global' * V'__Do'

    , Nothing = KEY'nothing'

    , __StmtS = V'Await'
             + V'EmitExt'  + V'_EmitInt'
             + V'_Dcl_nat' + V'_Dcl_ext0'
             + V'_Dcl_int' + V'_Dcl_var' + V'_Dcl_pool'
             + V'Dcl_det'
             --+ V'Call'
             + V'_Set'
             + V'Spawn'    + V'Kill'
             + V'_DoOrg'
             + V'Nothing'
             + V'RawStmt'
             + V'_TraverseRec'
             + V'_Dcl_fun0'
             + V'CallStmt' -- last
             --+ EM'statement'-- (missing `_´?)'
             + EM'statement (usually a missing `var´ or C prefix `_´)'

    , __StmtB = V'Do'   + V'Host'    + V'_GlobalDo'
             + V'Async' + V'_Thread' + V'Sync' + V'Atomic'
             + V'ParOr' + V'ParAnd'  + V'_Watching'
             + V'If'    + V'_Loop'   + V'_Every'
             + V'_Pause'
             + V'_Dcl_ifc' + V'Dcl_cls'
             + V'Dcl_adt'
             + V'Finalize'
             + V'_Dcl_fun1' + V'_Dcl_ext1'
             + V'_LuaStmt'
             + V'_TraverseLoop'

    , __LstStmt  = V'_Escape' + V'Break' + V'_Continue' + V'AwaitN' + V'Return'
    , __LstStmtB = V'ParEver' + V'_Continue'

    , __SetBlock  = V'Do' + V'ParEver' + V'If' + V'_Loop' + V'_Every'

    , VarList = ( K'(' * EV'Var' * (EK',' * EV'Var')^0 * EK')' )

    , _Set  = (V'__Exp' + V'VarList') * V'__Sets'
    , __Sets = (CK'='+CK':=') * (
                Cc'await'      * V'Await'
              + Cc'thread'     * V'_Thread'
              + Cc'emit-ext'   * (V'EmitExt' + K'('*V'EmitExt'*EK')')
              + Cc'spawn'      * V'Spawn'
              + Cc'adt-constr' * V'Adt_constr_root'
              + Cc'do-org'     * V'_DoOrg'
              + Cc'block'      * V'__SetBlock'
              + Cc'exp'        * V'__Exp'
              + Cc'lua'        * V'_LuaExp'
              + Cc'__trav_loop' * V'_TraverseLoop'  -- before Rec
              + Cc'__trav_rec'  * V'_TraverseRec'   -- after Loop
              + EM'expression'
              )

    , Finalize = KEY'finalize' * (V'_Set'*EK';'*K';'^0 + Cc(false))
               * EKEY'with' * EV'Finally' * EKEY'end'
    , Finally  = V'Block'

    , Kill  = KEY'kill' * EV'__Exp' * (EK'=>'*EV'__Exp' + Cc(false))
    , Spawn = KEY'spawn' * EV'__ID_cls' * (KEY'in'*EV'__Exp' + Cc(false))
            * (EKEY'with'*V'Dcl_constr'* EKEY'end' + Cc(false))

    , _DoOrg = KEY'do' * EV'__ID_cls'
             * (EKEY'with'*V'Dcl_constr'* EKEY'end' + Cc(false))


    , CallStmt = V'__Exp'

    , Atomic  = KEY'atomic' * V'__Do'
    , Sync    = KEY'sync'   * V'__Do'
    , _Thread = KEY'async/thread'          * (V'VarList'+Cc(false)) * V'__Do'
    , Async   = KEY'async' * (-P'/thread') * (V'VarList'+Cc(false)) * V'__Do'

    , _Escape = KEY'escape' * EV'__Exp'

    , _Watching = KEY'watching' * ( (EV'Var'+V'VarList') * EKEY'in'
                                  + Cc(false) )
                * V'__awaits'
                * V'__Do'

    , ParOr     = KEY'par/or' * EKEY'do' *
                      V'Block' * (EKEY'with' * V'Block')^1 *
                  EKEY'end'

    , ParAnd  = KEY'par/and' * EKEY'do' *
                    V'Block' * (EKEY'with' * V'Block')^1 *
                EKEY'end'
    , ParEver = KEY'par' * EKEY'do' *
                    V'Block' * (EKEY'with' * V'Block')^1 *
                EKEY'end'

    , If      = KEY'if' * EV'__Exp' * EKEY'then' *
                    V'Block' *
                (KEY'else/if' * EV'__Exp' * EKEY'then' *
                    V'Block')^0 *
                (KEY'else' *
                    V'Block' + Cc(false)) *
                EKEY'end'-- - V'_Continue'

    , Break     = KEY'break'
    , _Continue = KEY'continue'

    , _Loop   = KEY'loop' * ('/'*EV'__Exp' + Cc(false)) *
                    (V'Var' * (EKEY'in'*EV'__Exp' + Cc(false))
                    + Cc(false)*Cc(false)) *
                V'__Do'

    , _TraverseLoop = KEY'traverse' * V'Var' * EKEY'in' * EV'__Exp'
                    * (KEY'with'*V'_BlockI' + Cc(false))
                    * V'__Do'
    , _TraverseRec  = KEY'traverse' * ('/'*V'NUMBER'+Cc(false)) * EV'__Exp'
                    * (KEY'with'*V'Block'*EKEY'end' + Cc(false))

--[[
loop/N i in <e-num> do
    ...
end
loop (T*)i in <e-pool-org> do
    ...
end
loop i in <e-rec-data> do
    ...
end
loop (a,b,c) in <e-evt> do
    ...
end
    , _Iter   = KEY'loop' * K'('*EV'Type'*EK')'
              *     V'__ID_var' * KEY'in' * EV'__Exp'
              * V'__Do'
]]

    , _Every  = KEY'every' * ( (EV'Var'+V'VarList') * EKEY'in'
                            + Cc(false) )
              * V'__awaits'
              * V'__Do'

    , __Exp    = V'__1'
    , __1      = V'__2'  * (CKEY'or'  * EV'__2')^0
    , __2      = V'__3'  * (CKEY'and' * EV'__3')^0
    , __3      = V'__4'  * ((CK'|'-'||') * EV'__4')^0
    , __4      = V'__5'  * (CK'^' * EV'__5')^0
    , __5      = V'__6'  * (CK'&' * EV'__6')^0
    , __6      = V'__7'  * ((CK'!='+CK'==') * EV'__7')^0
    , __7      = V'__8'  * ((CK'<='+CK'>='+(CK'<'-'<<')+(CK'>'-'>>')) * EV'__8')^0
    , __8      = V'__9'  * ((CK'>>'+CK'<<') * EV'__9')^0
    , __9      = V'__10' * ((CK'+'+CK'-') * EV'__10')^0
    , __10     = V'__11' * ((CK'*'+(CK'/'-'//'-'/*')+CK'%') * EV'__11')^0
    , __11     = ( Cc(false) * (CKEY'not'+CK'&'+CK'-'+CK'+'+ CK'~'+CK'*'
                             + Cc'cast'*(K'('*V'Type'*K')') )
                )^0 * V'__12'
    , __12     = V'__13' *
                    (
                        K'(' * Cc'call' * EV'ExpList' * EK')' *
                            ( KEY'finalize' * EKEY'with' * V'Finally' * EKEY'end'
                              + Cc(false)) +
                        K'[' * Cc'idx'  * EV'__Exp'    * EK']' +
                        (CK':' + CK'.') * EV'__ID_field' +
                        CK'?'
                    )^0
    , __13     = V'__Prim'
    , __Prim   = V'__Parens' + V'SIZEOF'
              + V'Var'     + V'Nat'
              + V'NULL'    + V'NUMBER' + V'STRING'
              + V'Global'  + V'This'   + V'Outer'
              + V'RawExp'
              + CKEY'call'     * EV'__Exp'
              + CKEY'call/rec' * EV'__Exp'

    , Adt_constr_root = (CKEY'new'+Cc(false)) * V'Adt_constr_one'
    , Adt_constr_one = V'Adt' * EK'(' * EV'_Adt_explist' * EK')'
    , Adt         = V'__ID_adt' * (K'.'*V'__ID_tag' + Cc(false))

    , __adt_expitem = (V'Adt_constr_one' + V'__Exp')
    , _Adt_explist = ( V'__adt_expitem'*(K','*EV'__adt_expitem')^0 )^-1

    , ExpList = ( V'__Exp'*(K','*EV'__Exp')^0 )^-1

    , __Parens  = K'(' * EV'__Exp' * EK')'

    , SIZEOF = KEY'sizeof' * EK'(' * (V'Type' + V'__Exp') * EK')'

    , NUMBER = CK( #m.R'09' * (m.R'09'+m.S'xX'+m.R'AF'+m.R'af'+'.'
                                      +(m.S'Ee'*'-')+m.S'Ee')^1 )
            + CK( "'" * (P(1)-"'")^0 * "'" )
            + KEY'false' / function() return 0 end
            + KEY'true'  / function() return 1 end

    , NULL = CKEY'null'     -- TODO: the idea is to get rid of this

    , WCLOCKK = #NUM *
                (NUM * K'h'   + Cc(0)) *
                (NUM * K'min' + Cc(0)) *
                (NUM * K's'   + Cc(0)) *
                (NUM * K'ms'  + Cc(0)) *
                (NUM * K'us'  + Cc(0)) *
                (NUM * EM'<h,min,s,ms,us>')^-1 * (CK'_' + Cc(false))
    , WCLOCKE = K'(' * V'__Exp' * EK')' * (
                    CK'h' + CK'min' + CK's' + CK'ms' + CK'us'
                  + EM'<h,min,s,ms,us>'
              ) * (CK'_' + Cc(false))

    , _Pause   = KEY'pause/if' * EV'__Exp' * V'__Do'

    , AwaitN   = KEY'await' * KEY'FOREVER'

    , __awaits = Cc(false) * (V'WCLOCKK'+V'WCLOCKE')  -- false,   wclock
               + (EV'Ext'+EV'__Exp') * Cc(false)      -- ext/int, false
    , Await    = KEY'await' * V'__awaits'
                    * (KEY'until'*EV'__Exp' + Cc(false))

    -- TODO: emit/await, move from "false"=>"_WCLOCK"
    , EmitExt  = (CKEY'call/rec'+CKEY'call'+CKEY'emit'+CKEY'request')
               * ( Cc(false) * (V'WCLOCKK'+V'WCLOCKE')
                 + EV'Ext' * V'__emit_ps' )
    , _EmitInt  = CKEY'emit' * EV'__Exp' * V'__emit_ps'
    , __emit_ps = ( K'=>' * (V'__Exp' + K'(' * V'ExpList' * EK')')
                +   Cc(false) )

    , __ID     = V'__ID_nat' + V'__ID_ext' + V'Var'
    , Dcl_det  = KEY'@safe' * EV'__ID' * EKEY'with' *
                     EV'__ID' * (K',' * EV'__ID')^0

    , __Dcl_nat = Cc'type' * V'__ID_nat' * K'=' * NUM
                + Cc'func' * V'__ID_nat' * '()' * Cc(false)
                + Cc'unk'  * V'__ID_nat'        * Cc(false)

    , _Dcl_nat = KEY'native' * (CKEY'@pure'+CKEY'@const'+CKEY'@nohold'+CK'@plain'+Cc(false))
                   * EV'__Dcl_nat' * (K',' * EV'__Dcl_nat')^0

    , __Dcl_ext_call = (CKEY'input'+CKEY'output')
                     * Cc(false)     -- spawn array
                     * (CKEY'@rec'+Cc(false))
                     * V'_TupleType_2' * K'=>' * EV'Type'
                     * EV'__ID_ext' * (K','*EV'__ID_ext')^0
    , __Dcl_ext_evt  = (CKEY'input'+CKEY'output')
                     * Cc(false)     -- spawn array
                     * Cc(false)     -- recursive
                     * (V'_TupleType_1'+EV'Type') * Cc(false)
                     * EV'__ID_ext' * (K','*EV'__ID_ext')^0
    , __Dcl_ext_io   = (CKEY'input/output'+CKEY'output/input')
                     * ('['*(V'__Exp'+Cc(true))*EK']'+Cc(false))
                     * Cc(false)     -- recursive
                     * V'_TupleType_2' * K'=>' * EV'Type'
                     * EV'__ID_ext' * (K','*EV'__ID_ext')^0

    , _Dcl_ext0 = V'__Dcl_ext_io' + V'__Dcl_ext_call' + V'__Dcl_ext_evt'
    , _Dcl_ext1 = V'_Dcl_ext0' * V'__Do'

    , _Dcl_int  = CKEY'event' * (V'_TupleType_1'+EV'Type') *
                    EV'__ID_var' * (K','*EV'__ID_var')^0

    -------

    , _Dcl_pool = CKEY'pool' * EV'Type' * V'__dcl_var' * (K','*EV'__dcl_var')^0
    , _Dcl_var  = CKEY'var'  * EV'Type' *
                 (
                    Cc(true)  * EV'__ID_var' * EKEY'with' * V'Dcl_constr' * EKEY'end'
                 +
                    Cc(false) * V'__dcl_var' * (K','*V'__dcl_var')^0
                 )

    , Dcl_constr = V'Block'

    , __dcl_var = EV'__ID_var' * (V'__Sets' +
                                Cc(false)*Cc(false)*Cc(false))
    -------

    , _Dcl_imp = KEY'interface' * EV'__ID_cls' * (K',' * EV'__ID_cls')^0

    , _Dcl_fun0 = KEY'function' * CKEY'isr' * EK'[' * NUM * EK']' * (CKEY'@rec'+Cc(false))
                + CKEY'function' * (CKEY'@rec'+Cc(false))
                               * EV'_TupleType_2' * EK'=>' * EV'Type'
                               * V'__ID_var'

    , _Dcl_fun1 = V'_Dcl_fun0' * V'__Do'
    , Return  = KEY'return' * EV'__Exp'^-1

    , _BlockI = ( (EV'_Dcl_var'+V'_Dcl_int'+V'_Dcl_pool'+V'_Dcl_fun0'+V'_Dcl_imp')
                  * (EK';'*K';'^0)
               )^0
    , _Dcl_ifc = KEY'interface' * Cc(true)
               * EV'__ID_cls'
               * EKEY'with' * V'_BlockI' * EKEY'end'
    , Dcl_cls  = KEY'class'     * Cc(false)
               * EV'__ID_cls'
               * EKEY'with' * V'_BlockI' * V'__Do'
    -------

    , __Dcl_adt_struct = Cc'struct' * (V'_Dcl_var' * (EK';'*K';'^0))^1
    , __Dcl_adt_union  = Cc'union'  * V'Dcl_adt_tag' * (EKEY'or' * EV'Dcl_adt_tag')^0
    , Dcl_adt_tag    = KEY'tag' * EV'__ID_tag' * EKEY'with'
                      *   (V'_Dcl_var' * (EK';'*K';'^0))^0
                      * EKEY'end'
                      + KEY'tag' * EV'__ID_tag' * (EK';'*K';'^0)

    , Dcl_adt = KEY'data' * EV'__ID_adt' * EKEY'with'
               *    (V'__Dcl_adt_struct' + V'__Dcl_adt_union')
               * EKEY'end'
    -------

    , Global  = KEY'global'
    , This    = KEY'this' * Cc(false)
    , Outer   = KEY'outer'

    , Ext     = V'__ID_ext'
    , Var     = V'__ID_var'
    , Nat     = V'__ID_nat'

    , __ID_cls  = -KEYS * CK(m.R'AZ'*Alphanum^0)
    , __ID_ext  = -KEYS * CK(m.R'AZ'*ALPHANUM^0)
    , __ID_var  = (-KEYS * CK(m.R'az'*Alphanum^0) + CK('_'*-Alphanum))
    , __ID_nat  = CK(  P'_' *Alphanum^1)
    , __ID_type = CK(TYPES) + V'__ID_nat' + V'__ID_cls'

    , __ID_adt = -KEYS * CK(m.R'AZ'*Alphanum^0)
    , __ID_tag = -KEYS * CK(m.R'AZ'*ALPHANUM^0)

-- TODO: ([*,[],&,?])^0
    , Type = V'__ID_type'
           * (P'*'^0 / function (s)
                        return string.len(s)
                       end) *S
           * (K'['*(V'__Exp'+Cc(true))*K']' + Cc(false))
           * (CK'&' + Cc(false))
           * (CK'?' + Cc(false))
            -- id, *^0, [k], &, ?

    , __ID_field = CK(Alpha * (Alphanum)^0)

    -- (int, void*)
    , _TupleTypeItem_1 = Cc(false) * EV'Type' * Cc(false)
    , _TupleType_1 = K'(' * EV'_TupleTypeItem_1' * (EK','*V'_TupleTypeItem_1')^0 * EK')'

    -- (int v, nohold void* ptr)
    , _TupleTypeItem_2 = (CKEY'@hold'+Cc(false)) * EV'Type' * (EV'__ID_var'+Cc(false))
    , _TupleType_2 = K'(' * EV'_TupleTypeItem_2' * (EK','*V'_TupleTypeItem_2')^0 * EK')'

    , STRING = CK( CK'"' * (P(1)-'"'-'\n')^0 * EK'"' )

    , Host    = (KEY'native/pre'*Cc(true) + KEY'native'*Cc(false))
                * (#EKEY'do')*'do' * --m.S' \n\t'^0 *
                    ( C(V'_C') + C((P(1)-(m.S'\t\n\r '*'end'*P';'^0*'\n'))^0) )
                *S* EKEY'end'

    , RawStmt = K'{' * C((P(1)-'}')^0) * EK'}'
    , RawExp  = K'{' * C((P(1)-'}')^0) * EK'}'

    --, _C = '/******/' * (P(1)-'/******/')^0 * '/******/'
    , _C      = m.Cg(V'_CSEP','mark') *
                    (P(1)-V'_CEND')^0 *
                V'_CEND'
    , _CSEP = '/***' * (1-P'***/')^0 * '***/'
    , _CEND = m.Cmt(C(V'_CSEP') * m.Cb'mark',
                    function (s,i,a,b) return a == b end)

    , __SPACES = (  m.S'\t\n\r '
                + ('//' * (P(1)-'\n')^0 * P'\n'^-1)
                + ('#'  * (P(1)-'\n')^0 * P'\n'^-1) -- TODO: set of #'s/only after spaces
                + V'__comm'
                )^0

    , __comm    = '/' * m.Cg(P'*'^1,'comm') * (P(1)-V'__commcmp')^0 * 
                    V'__commcl'
                    / function () end
    , __commcl  = C(P'*'^1) * '/'
    , __commcmp = m.Cmt(V'__commcl' * m.Cb'comm',
                    function (s,i,a,b) return a == b end)

    -- Stmt/Exp differ only by the "return" and are re-unified in "adj.lua"
    , _LuaStmt = V'__lua'
    , _LuaExp  = Cc'return ' * V'__lua'

    , __lua    = K'[' * m.Cg(P'='^0,'lua') * '[' *
                ( V'__luaext' + C((P(1)-V'__luaext'-V'__luacmp')^1) )^0
                 * (V'__luacl'/function()end) *S
    , __luaext = K'@' * V'__Exp'
    , __luacl  = ']' * C(P'='^0) * EK']'
    , __luacmp = m.Cmt(V'__luacl' * m.Cb'lua',
                    function (s,i,a,b) return a == b end)
}

function err ()
    local x = (ERR_i<LST_i) and 'before' or 'after'
--DBG(LST_i, ERR_i, ERR_msg, _I2L[LST_i], I2TK[LST_i])
    local file, line = unpack(LINES.i2l[LST_i])
    return 'ERR : '..file..
              ' : line '..line..
              ' : '..x..' `'..(I2TK[LST_i] or '?').."´"..
              ' : '..ERR_msg
end

if RUNTESTS then
    assert(m.P(GG):match(OPTS.source), err())
else
    if not m.P(GG):match(OPTS.source) then     -- TODO: match only in ast.lua?
        DBG(err())
        os.exit(1)
    end
end

end

    
do
AST = {
    root = nil,
}

local MT = {}

local STACK = {}

function AST.isNode (node)
    return (getmetatable(node) == MT) and node.tag
end

AST.tag2id = {
    EmitInt = 'emit',
    Spawn   = 'spawn',
    Kill    = 'kill',
    Await   = 'await',
    AwaitN  = 'await',
    Async   = 'async',
    Thread  = 'async/thread',
    ParOr   = 'par/or',
    ParAnd  = 'par/and',
    ParEver = 'par',
    Loop    = 'loop',
    Dcl_cls = 'class',
}

function AST.isParent (n1, n2)
    return n1 == n2
        or n2.__par and AST.isParent(n1, n2.__par)
end

local _N = 0
function AST.node (tag, ln, ...)
    local me
    if tag == '_Stmts' then
        -- "Ct" as a special case to avoid "too many captures" (HACK_1)
        tag = 'Stmts'
        me = setmetatable((...), MT)
    else
        me = setmetatable({ ... }, MT)
    end
    me.n = _N
    --me.xxx = debug.traceback()
    _N = _N + 1
    me.ln  = ln
    --me.ln[2] = me.n
    me.tag = tag
    return me
end

function AST.copy (node, ln)
    if not AST.isNode(node) then
        return node
    end

    local ret = setmetatable({}, MT)
    local N = _N
    _N = _N + 1

    for k, v in pairs(node) do
        if type(k) ~= 'number' then
            ret[k] = v
        else
            ret[k] = AST.copy(v, ln)
            if AST.isNode(v) then
                ret[k].ln = ln or ret[k].ln
            end
        end
    end
    ret.n = N
    return ret
end

function AST.get (me, tag, ...)
    local idx, tag2 = ...

    if not (AST.isNode(me) and (me.tag==tag or tag=='')) then
        return nil, tag, ((AST.isNode(me) and me.tag) or 'none')
    end

    if idx then
        return AST.get(me[idx], tag2, select(3,...))
    else
        return me
    end
end

function AST.asr (me, tag, ...)
    local ret, tag1, tag2 = AST.get(me, tag, ...)
    if not ret then
        DBG(debug.traceback())
        error('bug (expected: '..tag1..' | found: '..tag2..')')
    end
    return ret
end

function AST.pred_async (me)
    local tag = me.tag
    return tag=='Async' or tag=='Thread'
end
function AST.pred_par (me)
    local tag = me.tag
    return tag=='ParOr' or tag=='ParAnd' or tag=='ParEver'
end
function AST.pred_true (me) return true end

function AST.par (me, pred)
    if type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    if not me.__par then
        return nil
    elseif pred(me.__par) then
        return me.__par
    else
        return AST.par(me.__par, pred)
    end
end

function AST.child (me, pred)
    if type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    if pred(me) then
        return me
    end
    for i, sub in ipairs(me) do
        if AST.isNode(sub) then
            local child = AST.child(sub,pred)
            if child then
                return child
            end
        end
    end
end

function AST.iter (pred, inc)
    if pred == nil then
        pred = AST.pred_true
    elseif type(pred) == 'string' then
        local tag = pred
        pred = function(me) return me.tag==tag end
    end
    local from = (inc and 1) or #STACK
    local to   = (inc and #STACK) or 1
    local step = (inc and 1) or -1
    local i = from
    return function ()
        for j=i, to, step do
            local stmt = STACK[j]
            if pred(stmt) then
                i = j+step
                return stmt
            end
        end
    end
end

function AST.dump (me, spc)
    spc = spc or 0
    local ks = ''
--[[
    for k, v in pairs(me) do
        if type(k)~='number' then
            v = string.gsub(string.sub(tostring(v),1,8),'\n','\\n')
            ks = ks.. k..'='..v..','
        end
    end
]]
    --local t=0; for _ in pairs(me.aw.t) do t=t+1 end
    --ks = 'n='..(me.aw.n or '?')..',t='..t..',ever='..(me.aw.forever_ and 1 or 0)
    --ks = table.concat(me.trails,'-')
--
if me.ana then
    local f = function(v)
                return type(v)=='table'
                            and (type(v[1])=='table' and v[1].id or v[1])
                    or tostring(v)
              end
    local t = {}
    for k in pairs(me.ana.pre) do t[#t+1]=f(k) end
    ks = '['..table.concat(t,',')..']'
    local t = {}
    for k in pairs(me.ana.pos) do t[#t+1]=f(k) end
    ks = ks..'['..table.concat(t,',')..']'
end
--[[
]]
--
    --ks = me.ns.trails..' / '..tostring(me.needs_clr)
    DBG(string.rep(' ',spc)..me.tag..
--[[
        '')
]]
        ' (ln='..me.ln[2]..' n='..me.n..
                           --' d='..(me.__depth or 0)..
                           --' p='..(me.__par and me.__par.n or '')..
                           ') '..ks)
--DBG'---'
--DBG(me.xxx)
--DBG'---'
    for i, sub in ipairs(me) do
        if AST.isNode(sub) then
            AST.dump(sub, spc+2)
        else
            DBG(string.rep(' ',spc+2) .. '['..tostring(sub)..']')
        end
    end
end

local function FF (F, str)
    local f = F[str]
    if type(f) == 'string' then
        return FF(F, f)
    end
    assert(f==nil or type(f)=='function')
    return f
end

local function visit_aux (me, F)
    local _me = me
    me.__par   = STACK[#STACK]
    me.__depth = (me.__par and me.__par.__depth+1) or 0
    ASR(me.__depth < 0xFF, me, 'max depth of 0xFF')

    local pre, mid, pos = FF(F,me.tag..'_pre'), FF(F,me.tag), FF(F,me.tag..'_pos')
    local bef, aft = FF(F,me.tag..'_bef'), FF(F,me.tag..'_aft')

    if F.Node_pre then
        me = F.Node_pre(me) or me
        if me ~= _me then
            --DBG('Node_pre', me.tag, me)
            return visit_aux(me, F)
        end
    end
    if pre then
        me = pre(me) or me
        if me ~= _me then
            --DBG('XXXX_pre', me.tag, me, _me.tag, _me)
            return visit_aux(me, F)
        end
    end

    STACK[#STACK+1] = me

    for i, sub in ipairs(me) do
        if bef then assert(bef(me, sub, i)==nil) end
        if AST.isNode(sub) then
            sub = visit_aux(sub, F)
            me[i] = sub
        end
        if aft then assert(aft(me, sub, i)==nil) end
    end

    if mid then
        assert(mid(me) == nil, me.tag)
    end
    if F.Node then
        assert(F.Node(me) == nil)
    end

    STACK[#STACK] = nil

    if pos then
        me = pos(me) or me
        if AST.isNode(me) then
            me.__par = STACK[#STACK]
            me.__depth = (me.__par and me.__par.__depth+1) or 0
        end
    end
    if F.Node_pos then
        me = F.Node_pos(me) or me
        if AST.isNode(me) then
            me.__par = STACK[#STACK]
            me.__depth = (me.__par and me.__par.__depth+1) or 0
        end
    end

    return me
end
AST.visit_aux = visit_aux

function AST.visit (F, node)
    assert(AST)
    --STACK = {}
    return visit_aux(node or AST.root, F)
end

local function i2l (p)
    return LINES.i2l[p]
end

for tag, patt in pairs(GG) do
    if string.sub(tag,1,2) ~= '__' then
        GG[tag] = m.Cc(tag) * (m.Cp()/i2l) * patt / AST.node
    end
end

local function f (ln, v1, op, v2, v3, ...)
    --DBG('2',ln[2],v1,op,v2,v3,...)
    local ret
    if not op then
        ret = v1
    elseif v1=='call' or v1=='call/rec' then
        -- Prim call
        ASR(op.tag=='Op2_call', ln, 'invalid call')
        op[1] = v1  -- change modifier
        ret = op
    elseif v1 then
        -- Op2_*
        if op == 'call' then
            ret = f(ln, AST.node('Op2_'..op,ln,op,v1,v2,v3), ...)
        elseif op == '?' then
            ret = f(ln, AST.node('Op1_'..op,ln,op,v1) ,v2, v3, ...)
        else
            ret = f(ln, AST.node('Op2_'..op,ln,op,v1,v2), v3, ...)
        end
    else
        -- Op1_*
        if op == 'cast' then
            -- consume the type
            ret = AST.node('Op1_'..op, ln, v2, f(ln,v3,...))
        else
            ret = AST.node('Op1_'..op, ln, op, f(ln,v2,v3,...))
        end
    end
    return ret
end

for i=1, 12 do
    local tag = '__'..i
    GG[tag] = (m.Cp()/i2l) * GG[tag] / f
end

AST.root = m.P(GG):match(OPTS.source)
AST.visit({})

end

    
do
local node = AST.node

-- TODO: remove
MAIN = nil

function REQUEST (me)
    --[[
    --      (err, v) = (request LINE=>10);
    -- becomes
    --      var _reqid id = _ceu_sys_request();
    --      var _reqid id';
    --      emit _LINE_request => (id, 10);
    --      finalize with
    --          _ceu_sys_unrequest(id);
    --          emit _LINE_cancel => id;
    --      end
    --      (id', err, v) = await LINE_return
    --                      until id == id';
    --]]

    local to, op, _, emit
    if me.tag == 'EmitExt' then
        to   = nil
        emit = me
    else
        -- _Set
        to, op, _, emit = unpack(me)
    end

    local op_emt, e, ps = unpack(emit)
    local id_evt = e[1]
    local id_req  = '_reqid_'..me.n
    local id_req2 = '_reqid2_'..me.n

    local tp_req = node('Type', me.ln, 'int', 0, false, false)

    if ps then
        -- insert "id" into "emit REQUEST => (id,...)"
        if ps.tag == 'ExpList' then
            table.insert(ps, 1, node('Var',me.ln,id_req))
        else
            ps = node('ExpList', me.ln,
                    node('Var', me.ln, id_req),
                    ps)
        end
    end

    local awt = node('Await', me.ln,
                    node('Ext', me.ln, id_evt..'_RETURN'),
                    false,
                    node('Op2_==', me.ln, '==',
                        node('Var', me.ln, id_req),
                        node('Var', me.ln, id_req2)))
    if to then
        -- v = await RETURN

        -- insert "id" into "v = await RETURN"
        if to.tag ~= 'VarList' then
            to = node('VarList', me.ln, to)
        end
        table.insert(to, 1, node('Var',me.ln,id_req2))

        awt = node('_Set', me.ln, to, op, 'await', awt)
    else
-- TODO: bug (removing session check)
        awt[3] = false
    end

    return node('Stmts', me.ln,
            node('Dcl_var', me.ln, 'var', tp_req, id_req),
            node('Dcl_var', me.ln, 'var', tp_req, id_req2),
            node('Set', me.ln, '=', 'exp',
                node('RawExp', me.ln, 'ceu_out_req()'),
                node('Var', me.ln, id_req)),
            node('EmitExt', me.ln, 'emit',
                node('Ext', me.ln, id_evt..'_REQUEST'),
                ps),
            node('Finalize', me.ln,
                false,
                node('Finally', me.ln,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Nothing', me.ln), -- TODO: unrequest
                            node('EmitExt', me.ln, 'emit',
                                node('Ext', me.ln, id_evt..'_CANCEL'),
                                node('Var', me.ln, id_req)))))),
            awt
    )
end

F = {
-- 1, Root --------------------------------------------------

    ['1_pre'] = function (me)
        local spc, stmts = unpack(me)

        local BLK_IFC = node('Block', me.ln, stmts)
        local RET = BLK_IFC

        -- for OS: <par/or do [blk_ifc_body] with await OS_STOP; escape 1; end>
        if OPTS.os then
            RET = node('ParOr', me.ln,
                        AST.asr(RET, 'Block'),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('Await', me.ln,
                                    node('Ext',me.ln,'OS_STOP'),
                                    false,
                                    false),
                                node('_Escape', me.ln,
                                    node('NUMBER',me.ln,1)))))
        end

        --[[
        -- Prepare request loops to run in "par/or" with the STMT above:
        -- par/or do
        --      <RET>
        -- with
        --      par do
        --          every REQ1 do ... end
        --      with
        --          every REQ2 do ... end
        --      end
        -- end
        --]]
        do
            local ORIG = RET
            RET = node('Stmts', me.ln,
                    node('ParEver', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                RET)),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('XXX',me.ln)))))
                                -- XXX = ParEver or Stmts
            ADJ_REQS = {
                me   = RET,
                orig = ORIG,
                reqs = AST.asr(RET,'Stmts', 1,'ParEver', 2,'Block', 1,'Stmts', 1,'XXX')
            }
                --[[
                -- Use "ADJ_REQS" to hold the "par/or", which can be
                -- substituted by the original "stmts" if there are no requests
                -- in the program (avoiding the unnecessary "par/or->par").
                -- See also ['Root'].
                --]]
        end

        -- enclose the program with the "Main" class
        MAIN = node('Dcl_cls', me.ln, false,
                    'Main',
                    node('BlockI', me.ln,
                        node('Stmts', me.ln)),
                    node('Block', me.ln,        -- same structure of
                        node('Stmts', me.ln,    -- other classes
                            RET)))
        MAIN.blk_ifc  = BLK_IFC
        MAIN.blk_body = BLK_IFC

        -- [1] => ['Root']
        AST.root = node('Root', me.ln, MAIN)
        return AST.root
    end,

    Root = function (me)
        if #ADJ_REQS.reqs == 0 then
            -- no requests, substitute the "par/or" by the original "stmts"
            ADJ_REQS.me[1] = ADJ_REQS.orig
        elseif #ADJ_REQS.reqs == 1 then
            ADJ_REQS.reqs.tag = 'Stmts'
        else
            ADJ_REQS.reqs.tag = 'ParEver'
        end
    end,

-- Dcl_cls/_ifc --------------------------------------------------

    -- global do end

    _GlobalDo_pos = function (me)
        local cls = AST.iter'Dcl_cls'()
        AST.asr(me,'', 1,'Block', 1,'Stmts')
        if cls == MAIN then
            return me[1][1]
                    -- remove "global do ... end" and Block
        else
            cls.__globaldos[#cls.__globaldos+1] = me[1][1]
                    -- remove "global do ... end" and Block
            return AST.node('Nothing', me.ln)
        end
    end,

    Dcl_cls_pre = function (me)
        local is_ifc, id, blk_ifc, blk_body = unpack(me)
-- TODO
me.blk_body = me.blk_body or blk_body

        me.__globaldos = {}

        -- enclose the main block with <ret = do ... end>
        blk_body = node('Block', me.ln,
                    node('Stmts', me.ln,
                        node('Dcl_var', me.ln, 'var',
                            node('Type', me.ln, 'int', 0, false, false),
                            '_ret'),
                        node('SetBlock', me.ln,
                            blk_body,
                            node('Var', me.ln,'_ret'),
                            true))) -- true=cls-block
        me[4] = blk_body
    end,

    Dcl_cls_pos = function (me)
        local par = AST.iter'Dcl_cls'()
        assert(me ~= par)
        if par then
            if par == MAIN then
                return node('Stmts', me.ln, me, unpack(me.__globaldos))
            else
                for _, v in ipairs(me.__globaldos) do
                    par.__globaldos[#par.__globaldos+1] = v
                end
                return node('Stmts', me.ln, me)
            end
        end
    end,

    _Dcl_ifc = 'Dcl_cls',
    Dcl_cls = function (me)
        local is_ifc, id, blk_ifc, blk_body = unpack(me)
        local blk = node('Block', me.ln,
                         node('Stmts',me.ln,blk_ifc,blk_body))
        me.blk_ifc  = me.blk_ifc  or blk
        me.blk_body = me.blk_body or blk_body
        me.tag = 'Dcl_cls'  -- Dcl_ifc => Dcl_cls
        me[3]  = blk        -- both blocks 'ifc' and 'body'
        me[4]  = nil        -- remove 'body'

-- TODO
        if is_ifc then
            return
        end

        -- remove SetBlock if no escapes
        if id~='Main' and (not me.has_escape) then
            local setblock = AST.asr(blk_body,'Block', 1,'Stmts', 2,'SetBlock')
            blk_body[1] = node('Stmts', me.ln, setblock[1])
        end

        -- insert class pool for orphan spawn
        local stmts = AST.asr(blk_ifc,'BlockI', 1,'Stmts')
        if me.__ast_has_malloc then
            table.insert(stmts, 1,
                node('Dcl_pool', me.ln, 'pool',
                    node('Type', me.ln, '_TOP_POOL', 0, true, false),
                    '_top_pool'))
        end
    end,

-- Escape --------------------------------------------------

    _Escape_pos = function (me)
        local exp = unpack(me)

        local cls = AST.par(me, 'Dcl_cls')
        local set = AST.par(me, 'SetBlock')
        cls.has_escape = (set[3] == true);
        ASR(set and set.__depth>cls.__depth,
            me, 'invalid `escape´')

        local _,to = unpack(set)
        local to = AST.copy(to)    -- escape from multiple places
            to.ln = me.ln

        --[[
        --  a = do
        --      var int a;
        --      escape 1;   -- "set" block (outer)
        --  end
        --]]
        to.__ast_blk = set

        --[[
        --      a = do ...; escape 1; end
        -- becomes
        --      do ...; a=1; escape; end
        --]]

        return node('Stmts', me.ln,
                    node('Set', me.ln, '=', 'exp', exp, to, fr),
                    node('Escape', me.ln))
    end,

-- Watching --------------------------------------------------

    _Watching_pre = function (me)
        --[[
        --      watching <v> in <EVT> do
        --          ...
        --      end
        -- becomes
        --      par/or do
        --          <v> = await <EVT>;  // strong abortion
        --      with
        --          ...                 // no chance to execute on <EVT>
        --      end
        --
        -- TODO: because the order is inverted, if the same error occurs in
        -- both sides, the message will point to "..." which appears after in
        -- the code
        --]]
        local to, e, dt, blk = unpack(me)

        local awt = node('Await', me.ln, e, dt, false)
        local set
        if to then
            set = node('_Set', me.ln, to, '=', 'await', awt)
        else
            set = awt
        end

        local ret = node('ParOr', me.ln,
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                set)),
                        blk)
        ret.__adj_watching = (e or dt)
        return ret
    end,

-- Every --------------------------------------------------

    _Every_pre = function (me)
        local to, e, dt, body = unpack(me)

        --[[
        --      every a=EXT do ... end
        -- becomes
        --      loop do a=await EXT; ... end
        --]]

        local awt = node('Await', me.ln, e, dt, false)
        awt.isEvery = true  -- refuses other "awaits"

        local set
        if to then
            set = node('_Set', me.ln, to, '=', 'await', awt)
        else
            set = awt
        end

        local ret = node('_Loop', me.ln, false, to, AST.copy(e or dt), body)
        AST.asr(body[1], 'Stmts')
        table.insert(body[1], 1, set)
        ret.isEvery = true  -- refuses other "awaits"
                            -- auto declares "to"
        return ret
    end,

-- Loop --------------------------------------------------

    This_pre = function (me)
        local in_rec = unpack(me)
        if AST.par(me,'Dcl_constr') or in_rec then
            return  -- inside constructor or already recognized as in_rec
        end

        -- "this" inside "loop/adt" should refer to outer class
        local cls = AST.par(me, 'Dcl_cls')
        if cls.__adj_out then
            return node('Op2_.', me.ln, '.',
                    node('This', me.ln, true),
                    '_out')
        end
    end,

    Outer_pre = function (me)
        local in_rec = unpack(me)
        if in_rec then
            return  -- already recognized as in_rec
        end

        -- "outer" inside "traverse" should refer to outer class
        local cls = AST.par(me, 'Dcl_cls')
        if cls.__adj_out then
            return node('Var', me.ln, '_out')
        end
    end,

    _TraverseLoop_pre = function (me)
        --[[
        --  ret = traverse <n> in <adt> with
        --      <interface>
        --  do
        --      <body>
        --          traverse <exp>;
        --  end;
        --      ... becomes ...
        --  class Body with
        --      pool Body[?]&   loops;
        --      var  Body*      parent;       // TODO: should be "Body*?" (opt)
        --      var  <adt_t>*[] <n>;
        --      var  Outer&     out;
        --      <interface>
        --  do
        --      watching *this.parent do
        --          <body>
        --              traverse <exp>;
        --      end
        --      escape 0;
        --  end
        --  pool Body[?] loops;
        --  ret = do Body with
        --      this.loops  = loops;
        --      this.parent = &this;    // watch myself
        --      this.<n>    = <n>;
        --  end;
        --]]

        local to, root, ifc, body, ret = unpack(me)
        local out = AST.par(me, 'Dcl_cls')

        -- unpacked below
        ifc = ifc or node('Stmts',me.ln)

        local tp = node('Type', me.ln, 'TODO-ADT-TYPE', 1, true, false)
        local cls = node('Dcl_cls', me.ln, false, 'Body_'..me.n,
                        node('BlockI', me.ln,
                            node('Stmts', me.ln,
                                node('Dcl_pool', me.ln, 'pool',
                                    node('Type', me.ln, 'Body_'..me.n, 0, true, true),
                                    '_bodies'),
                                node('Dcl_var', me.ln, 'var',
                                    node('Type', me.ln, 'Body_'..me.n, 1, false, false),
                                        -- TODO: should be opt type
                                    '_parent'),
                                node('_Dcl_pool', me.ln, 'pool',
                                    tp,
                                    to[1]),
                                node('Dcl_var', me.ln, 'var',
                                    node('Type', me.ln, out[2], 0, false, true),
                                    '_out'),
                                unpack(ifc))),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('_Watching', me.ln,
                                    false,
                                    node('Op1_*', me.ln, '*',
                                        node('Var', me.ln, '_parent')),
                                    false,
                                    node('Block', me.ln,
                                        node('Stmts', me.ln,
                                            body))),
                                node('_Escape', me.ln,
                                    node('NUMBER', me.ln, '0')))))
        cls.__adj_out = AST.par(me, 'Block')

        local pool = node('Dcl_pool', me.ln, 'pool',
                        node('Type', me.ln, 'Body_'..me.n, 0, true, false),
                        '_pool_'..me.n)
        local doorg = node('_DoOrg', me.ln, 'Body_'..me.n,
                        node('Dcl_constr', me.ln,
                            node('Block', me.ln,
                                node('Stmts', me.ln,
                                    node('_Set', me.ln,
                                        node('Op2_.', me.ln, '.',
                                            node('This', me.ln, true),
                                            '_bodies'),
                                        '=', 'exp',
                                        node('Var', me.ln, '_pool_'..me.n)),
                                    node('_Set', me.ln,
                                        node('Op2_.', me.ln, '.',
                                            node('This', me.ln, true),
                                            '_parent'),
                                        '=', 'exp',
                                        node('Op1_&', me.ln, '&',
                                            node('This', me.ln, true))),
                                    node('_Set', me.ln,
                                        node('Op2_.', me.ln, '.',
                                            node('This', me.ln, true),
                                            to[1]),
                                        '=', 'exp',
                                        root),
                                    node('_Set', me.ln,
                                        node('Op2_.', me.ln, '.',
                                            node('This', me.ln, true),
                                            '_out'),
                                        '=', 'exp',
                                        node('Outer', me.ln, true))))))
        if ret then
            doorg = node('_Set', me.ln, ret, '=', 'do-org', doorg)
        end

        -- HACK_5: figure out root type and dimension
        local root = node('_TMP_ITER', me.ln, AST.copy(root))
        local ret = node('Stmts', me.ln, root, cls, pool, doorg)
        return ret
    end,

    --[[
    --  ret = traverse <exp> with
    --      <constr>
    --  end;
    --      ... becomes ...
    --  var Body*? _body_;
    --  _body_ = spawn Body in _bodies with
    --      this._bodies = outer._bodies;
    --      this._parent = outer;
    --      this.<n>     = <exp>;
    --      <constr>
    --  if _body_? then
    --      ret = await *_body_;
    --  else
    --      ret = 0;    // TODO: how to get "ret" from a dead body?
    --  end
    --]]
    _TraverseRec_pre = function (me)
        local n, exp, constr, ret = unpack(me)

        -- unpacked below
        constr = constr or node('Block', me.ln,
                            node('Stmts', me.ln))
        constr = AST.asr(constr,'Block', 1,'Stmts')

        -- take n-th traverse above
        n = (n==false and 0) or (AST.asr(n,'NUMBER')[1])
        local it = AST.iter(
                    function (me)
                        return me.tag=='Dcl_cls' and me.__adj_out
                    end)
        local cls
        for i=0, n do
            cls = it()
            if not cls then
                break
            end
        end
        ASR(cls, me, 'missing enclosing `traverse´ block')

        local SET_AWAIT = node('Await', me.ln,
                            node('Op1_*', me.ln, '*',
                                node('Var', me.ln, '_body_'..me.n)),
                            false,
                            false)
        local SET_DEAD = node('Nothing', me.ln)
        if ret then
            SET_AWAIT = node('_Set', me.ln, ret, '=', 'await',
                            SET_AWAIT)
            SET_DEAD  = node('_Set', me.ln, ret, '=', 'exp',
                            node('NUMBER', me.ln, '0'))
        end

        local to_id  = AST.asr(cls,'Dcl_cls', 3,'BlockI', 1,'Stmts', 3,'Dcl_pool')[3]
        local cls_id = cls[2]

        local dcl = node('Dcl_var', me.ln, 'var',
                        node('Type', me.ln, cls_id, 1, false, false, true),
                        '_body_'..me.n)
        local set = node('_Set', me.ln,
                        node('Var', me.ln, '_body_'..me.n),
                        '=', 'spawn',
                        node('Spawn', me.ln, cls_id,
                            node('Var', me.ln, '_bodies'),
                            node('Dcl_constr', me.ln,
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                '_bodies'),
                                            '=', 'exp',
                                            node('Op2_.', me.ln, '.',
                                                node('Outer', me.ln, true),
                                                '_bodies')),
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                '_parent'),
                                            '=', 'exp',
                                            node('Op1_&', me.ln, '&',
                                                node('Outer', me.ln, true))),
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                to_id),
                                            '=', 'exp',
                                            exp),
                                        node('_Set', me.ln,
                                            node('Op2_.', me.ln, '.',
                                                node('This', me.ln, true),
                                                '_out'),
                                            '=', 'exp',
                                            node('Op2_.', me.ln, '.',
                                                node('Outer', me.ln, true),
                                                '_out')),
                                        unpack(constr))))))
        local if_ = node('If', me.ln,
                        node('Op1_?', me.ln, '?',
                            node('Var', me.ln, '_body_'..me.n)),
                        --node('Nothing', me.ln),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                SET_AWAIT)),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                SET_DEAD)))

        return node('Stmts', me.ln, dcl, set, if_)
    end,

    _Loop_pre = function (me)
        local max, to, iter, body = unpack(me)
        to = to or (max and node('Var', me.ln, '__ceu_i'..'_'..me.n))
        local loop = node('Loop', me.ln, max, iter, to, body)
        loop.isEvery      = me.isEvery
        loop.isAwaitUntil = me.isAwaitUntil

        return node('Block', me.ln,
                node('Stmts', me.ln,
                    node('Stmts', me.ln),   -- to insert all pre-declarations
                    loop))
    end,

-- Continue --------------------------------------------------

    _Continue_pos = function (me)
        local _if  = AST.par(me, 'If')
        local loop = AST.par(me, 'Loop')
        ASR(_if and loop, me, 'invalid `continue´')

        local _,_,_,body = unpack(loop)
        local _,_,_else  = unpack(_if)

        loop.hasContinue = true
        _if.hasContinue = true
        ASR( _else.tag=='Nothing'          and   -- no else
            me.__depth  == _if.__depth+3   and   -- If->Block->Stmts->Continue
             _if.__depth == body.__depth+2 , -- Block->Stmts->If
            me, 'invalid `continue´')
        return AST.node('Nothing', me.ln)
    end,

    Loop_pos = function (me)
        local _,_,_,body = unpack(me)
        if not me.hasContinue then
            return
        end
        -- start from last to first continue
        local stmts = unpack(body)
        local N = #stmts
        local has = true
        while has do
            has = false
            for i=N, 1, -1 do
                local n = stmts[i]
                if n.hasContinue then
                    has = true
                    N = i-1
                    local _else = AST.node('Stmts', n.ln)
                    n[3] = _else
                    for j=i+1, #stmts do
                        _else[#_else+1] = stmts[j]
                        stmts[j] = nil
                    end
                end
            end
        end
    end,

-- If --------------------------------------------------

    -- "_pre" because of "continue"
    If_pre = function (me)
        if #me==3 and me[3] then
            return      -- has no "else/if" and has "else" clause
        end
        local ret = me[#me] or node('Nothing', me.ln)
        for i=#me-1, 1, -2 do
            local c, b = me[i-1], me[i]
            ret = node('If', c.ln, c, b, ret)
        end
        return ret
    end,

-- Thread ---------------------------------------------------------------------

    _Thread_pre = function (me)
        me.tag = 'Thread'
        local raw = node('RawStmt', me.ln, nil)    -- see code.lua
              raw.thread = me
        return node('Stmts', me.ln,
                    node('Finalize', me.ln,
                        false,
                        node('Finally', me.ln,
                            node('Block', me.ln,
                                node('Stmts', me.ln,raw)))),
                    me,
                    node('Async', me.ln, node('VarList', me.ln),
                                      node('Block', me.ln, node('Stmts', me.ln))))
                    --[[ HACK_2:
                    -- Include <async do end> after it to enforce terminating
                    -- from the main program.
                    --]]
    end,

-- Spawn ------------------------------------------------------------

    -- implicit pool in enclosing class if no "in pool"
    Spawn = function (me)
        local _,pool = unpack(me)
        if not pool then
            AST.par(me,'Dcl_cls').__ast_has_malloc = true
            me[2] = node('Var', me.ln, '_top_pool')
        end
    end,

-- DoOrg ------------------------------------------------------------

    _DoOrg_pre = function (me, to)
        --[[
        --  x = do T ... (handled on _Set_pre)
        --
        --  do T with ... end;
        --
        --      becomes
        --
        --  do
        --      var T t with ... end;
        --      x = await t;
        --  end
        --]]
        local id_cls, constr = unpack(me);

        local awt = node('Await', me.ln,
                        node('Var', me.ln, '_org_'..me.n),
                        false,
                        false)
        if to then
            awt = node('_Set', me.ln, to, '=', 'await', awt)
        end

        return node('Do', me.ln,
                node('Block', me.ln,
                    node('Stmts', me.ln,
                        node('Dcl_var', me.ln, 'var',
                            node('Type', me.ln, id_cls, 0, false, false),
                            '_org_'..me.n,
                            constr),
                        awt)))
    end,

-- BlockI ------------------------------------------------------------

    _BlockI_pre = function (me)
        return node('BlockI', me.ln,
                node('Stmts', me.ln,
                    unpack(me)))
    end,

    -- expand collapsed declarations inside Stmts
    BlockI_pos = function (me)
        local stmts = AST.asr(me,'', 1,'Stmts')
        local new = {}
        for _, dcl in ipairs(stmts) do
            if dcl.tag == 'Stmts' then
                for _, v in ipairs(dcl) do
                    new[#new+1] = v
                end
            else
                new[#new+1] = dcl
            end
        end
--[[
        if #new > #me then
            for i,v in ipairs(new) do
                me[i] = v
            end
        end
]]
        -- changes the node reference
        me[1] = node('Stmts', me.ln, unpack(new))
    end,

-- Dcl_fun, Dcl_ext --------------------------------------------------------

    _Dcl_ext1_pre = '_Dcl_fun1_pre',
    _Dcl_fun1_pre = function (me)
        local dcl, blk = unpack(me)
        dcl[#dcl+1] = blk           -- include body on DCL0
        return dcl
    end,

    _Dcl_fun0_pre = function (me)
        me.tag = 'Dcl_fun'

        local isr, n, rec, blk = unpack(me)

        -- ISR: include "ceu_out_isr(id)"
        if isr == 'isr' then
            -- convert to 'function'
                --me[1] = 'function'
                me[2] = rec
                me[3] = node('TupleType', me.ln,
                            node('TupleTypeItem', me.ln, false,
                                node('Type', me.ln, 'void', 0, false, false),
                                false))
                me[4] = node('Type', me.ln, 'void', 0, false, false)
                me[5] = n
                me[6] = blk

            --[[
            -- _ceu_out_isr(20, rx_isr)
            --      finalize with
            --          _ceu_out_isr(20, null);
            --      end
            --]]
            return node('Stmts', me.ln,
                me,
                node('CallStmt', me.ln,
                    node('Op2_call', me.ln, 'call',
                        node('Nat', me.ln, '_ceu_out_isr'),
                        node('ExpList', me.ln,
                            node('NUMBER', me.ln, n),
                            node('Var', me.ln, n)),
                        node('Finally', me.ln,
                            node('Block', me.ln,
                                node('Stmts', me.ln,
                                    node('CallStmt', me.ln,
                                        node('Op2_call', me.ln, 'call',
                                            node('Nat', me.ln, '_ceu_out_isr'),
                                            node('ExpList', me.ln,
                                                node('NUMBER', me.ln, n),
                                                node('NULL', me.ln))))))))))
        -- FUN
        else
            return me
        end
    end,

    _Dcl_ext0_pre = function (me)
        local dir, spw, rec, ins, out, id_evt, blk = unpack(me)

        -- Type => TupleType
        if ins.tag == 'Type' then
            local id, ptr, arr, ref = unpack(ins)
            if id=='void' and ptr=='' and arr==false and ref==false then
                ins = node('TupleType', ins.ln)
            else
                ins = node('TupleType', ins.ln,
                            node('TupleTypeItem', ins.ln, false, ins, false))
            end
            me[4] = ins
        end

        if me[#me].tag == 'Block' then
            -- refuses id1,i2 + blk
            ASR(me[#me]==blk, me, 'same body for multiple declarations')
            -- removes blk from the list of ids
            me[#me] = nil
        else
            -- blk is actually another id_evt, keep #me
            blk = nil
        end

        local ids = { unpack(me,6) }  -- skip dir,spw,rec,ins,out

        local ret = {}
        for _, id_evt in ipairs(ids) do
            if dir=='input/output' or dir=='output/input' then
                --[[
                --      output/input (T1,...)=>T2 LINE;
                -- becomes
                --      input  (tceu_req,T1,...) LINE_REQUEST;
                --      input  tceu_req          LINE_CANCEL;
                --      output (tceu_req,u8,T2)  LINE_RETURN;
                --]]
                local d1, d2 = string.match(dir, '([^/]*)/(.*)')
                assert(out)
                assert(rec == false)
                local tp_req = node('Type', me.ln, 'int', 0, false, false)

                local ins_req = node('TupleType', me.ln,
                                    node('TupleTypeItem', me.ln,
                                        false,AST.copy(tp_req),false),
                                    unpack(ins))                -- T1,...
                local ins_cancel = node('TupleType', me.ln,
                                    node('TupleTypeItem', me.ln,
                                        false,AST.copy(tp_req),false))
                local ins_ret = node('TupleType', me.ln,
                                    node('TupleTypeItem', me.ln,
                                        false,AST.copy(tp_req),false),
                                    node('TupleTypeItem', me.ln,
                                        false,node('Type',me.ln,'u8',0,false,false),false),
                                    node('TupleTypeItem', me.ln,
                                        false, out, false))

                ret[#ret+1] = node('Dcl_ext', me.ln, d1, false,
                                   ins_req, false, id_evt..'_REQUEST')
                ret[#ret+1] = node('Dcl_ext', me.ln, d1, false,
                                   ins_cancel, false, id_evt..'_CANCEL')
                ret[#ret+1] = node('Dcl_ext', me.ln, d2, false,
                                   ins_ret, false, id_evt..'_RETURN')
            else
                if out then
                    ret[#ret+1] = node('Dcl_fun',me.ln,dir,rec,ins,out,id_evt, blk)
                end
                ret[#ret+1] = node('Dcl_ext',me.ln,dir,rec,ins,out,id_evt)
            end
        end

        if blk and (dir=='input/output' or dir=='output/input') then
            --[[
            -- input/output (int max)=>char* LINE [10] do ... end
            --
            --      becomes
            --
            -- class Line with
            --     var _reqid id;
            --     var int max;
            -- do
            --     finalize with
            --         emit _LINE_return => (this.id,XX,null);
            --     end
            --     par/or do
            --         ...
            --     with
            --         var int v = await _LINE_cancel
            --                     until v == this.id;
            --     end
            -- end
            --]]
            local id_cls = string.sub(id_evt,1,1)..string.lower(string.sub(id_evt,2,-1))
            local tp_req = node('Type', me.ln, 'int', 0, false, false)
            local id_req = '_req_'..me.n

            local ifc = {
                node('Dcl_var', me.ln, 'var', tp_req, id_req)
            }
            for _, t in ipairs(ins) do
                local mod, tp, id = unpack(t)
                ASR(tp.id=='void' or id, me, 'missing parameter identifier')
                --id = '_'..id..'_'..me.n
                ifc[#ifc+1] = node('Dcl_var', me.ln, 'var', tp, id)
            end

            local cls =
                node('Dcl_cls', me.ln, false, id_cls,
                    node('BlockI', me.ln,
                        node('Stmts', me.ln,
                            unpack(ifc))),
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Finalize', me.ln,
                                false,
                                node('Finally', me.ln,
                                    node('Block', me.ln,
                                        node('Stmts', me.ln,
                                            node('EmitExt', me.ln, 'emit',
                                                node('Ext', me.ln, id_evt..'_RETURN'),
                                                node('ExpList', me.ln,
                                                    node('Var', me.ln, id_req),
                                                    node('NUMBER', me.ln, 2),
                                                            -- TODO: err=2?
                                                    node('NUMBER', me.ln, 0))))))),
                            node('ParOr', me.ln,
                                node('Block', me.ln,
                                    node('Stmts', me.ln, blk)),
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('Dcl_var', me.ln, 'var', tp_req, 'id_req'),
                                        node('_Set', me.ln,
                                            node('Var', me.ln, 'id_req'),
                                            '=', 'await',
                                            node('Await', me.ln,
                                                node('Ext', me.ln, id_evt..'_CANCEL'),
                                                false,
                                                node('Op2_==', me.ln, '==',
                                                    node('Var', me.ln, 'id_req'),
                                                    node('Op2_.', me.ln, '.',
                                                        node('This',me.ln),
                                                        id_req))),
                                            false)))))))
            cls.__ast_req = {id_evt=id_evt, id_req=id_req}
            ret[#ret+1] = cls

            --[[
            -- Include the request loop in parallel with the top level
            -- stmts:
            --
            -- do
            --     pool Line[10] _Lines;
            --     var tp_req id_req_;
            --     var tpN, idN_;
            --     every (id_req,idN) = _LINE_request do
            --         var Line*? new = spawn Line in _Lines with
            --             this.id_req = id_req_;
            --             this.idN    = idN_;
            --         end
            --         if not new? then
            --             emit _LINE_return => (id_req,err,0);
            --         end
            --     end
            -- end
            ]]

            local dcls = {
                --node('Dcl_var', me.ln, 'var', tp_req, id_req)
            }
            local vars = node('VarList', me.ln, node('Var',me.ln,id_req))
            local sets = {
                node('_Set', me.ln,
                    node('Op2_.', me.ln, '.', node('This',me.ln), id_req),
                    '=', 'exp',
                    node('Var', me.ln, id_req))
            }
            for _, t in ipairs(ins) do
                local mod, tp, id = unpack(t)
                ASR(tp.id=='void' and tp.ptr==0 or id, me,
                    'missing parameter identifier')
                local _id = '_'..id..'_'..me.n
                --dcls[#dcls+1] = node('Dcl_var', me.ln, 'var', tp, _id)
                vars[#vars+1] = node('Var', me.ln, _id)
                sets[#sets+1] = node('_Set', me.ln,
                                    node('Op2_.', me.ln, '.',
                                        node('This',me.ln),
                                        id),
                                    '=', 'exp',
                                    node('Var', me.ln, _id))
            end

            local reqs = ADJ_REQS.reqs
            reqs[#reqs+1] =
                node('Do', me.ln,
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Dcl_pool', me.ln, 'pool',
                                node('Type', me.ln, id_cls, 0, (spw or true), false),
                                '_'..id_cls..'s'),
                            node('Stmts', me.ln, unpack(dcls)),
                            node('_Every', me.ln, vars,
                                node('Ext', me.ln, id_evt..'_REQUEST'),
                                false,
                                node('Block', me.ln,
                                    node('Stmts', me.ln,
                                        node('Dcl_var', me.ln, 'var',
                                            node('Type', me.ln, 'void', 1, false, false, true),
                                            'ok_'),
                                        node('_Set', me.ln,
                                            node('Var', me.ln, 'ok_'),
                                            '=', 'spawn',
                                            node('Spawn', me.ln, id_cls,
                                                node('Var', me.ln, '_'..id_cls..'s'),
                                                node('Dcl_constr', me.ln, unpack(sets)))),
                                        node('If', me.ln,
                                            node('Op1_not', me.ln, 'not',
                                                node('Op1_?', me.ln, '?',
                                                    node('Var', me.ln, 'ok_'))),
                                            node('Block', me.ln,
                                                node('EmitExt', me.ln, 'emit',
                                                    node('Ext', me.ln, id_evt..'_RETURN'),
                                                    node('ExpList', me.ln,
                                                        node('Var', me.ln, id_req),
                                                        node('NUMBER', me.ln, 1),
                                                                -- TODO: err=1?
                                                        node('NUMBER', me.ln, 0)))),
                                            false)))))))
        end

        return node('Stmts', me.ln, unpack(ret))
    end,

    Return_pre = function (me)
        local cls = AST.par(me, 'Dcl_cls')
        if cls and cls.__ast_req then
            --[[
            --      return ret;
            -- becomes
            --      emit RETURN => (this.id, 0, ret);
            --]]
            return node('EmitExt', me.ln, 'emit',
                        node('Ext', me.ln, cls.__ast_req.id_evt..'_RETURN'),
                        node('ExpList', me.ln,
                            node('Var', me.ln, cls.__ast_req.id_req),
                            node('NUMBER', me.ln, 0), -- no error
                            me[1])  -- return expression
                    )
        end
    end,

-- Dcl_nat, Dcl_ext, Dcl_int, Dcl_pool, Dcl_var ---------------------

    _Dcl_nat_pre = function (me)
        local mod = unpack(me)
        local ret = {}
        local t = { unpack(me,2) }  -- skip "mod"

        for i=1, #t, 3 do   -- pure/const/false, type/func/var, id, len
            ret[#ret+1] = node('Dcl_nat', me.ln, mod, t[i], t[i+1], t[i+2])
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

    _Dcl_int_pre = function (me)
        local pre, tp = unpack(me)

        -- Type => TupleType
        if tp.tag == 'Type' then
            tp = node('TupleType', tp.ln,
                        node('TupleTypeItem', tp.ln, false, tp, false))
            me[2] = tp
        end

        local ret = {}
        local t = { unpack(me,3) }  -- skip "pre","tp"
        for i=1, #t do
            ret[#ret+1] = node('Dcl_int', me.ln, pre, tp, t[i])
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

    _Dcl_pool_pre = function (me)
        local pre, tp = unpack(me)
        local ret = {}
        local t = { unpack(me,3) }  -- skip "pre","tp"

        -- id, op, tag, exp
        for i=1, #t, 4 do
            ret[#ret+1] = node('Dcl_pool', me.ln, pre, AST.copy(tp), t[i])
            if t[i+1] then
                ret[#ret+1] = node('_Set', me.ln,
                                node('Var', me.ln, t[i]),  -- var
                                t[i+1],                 -- op
                                t[i+2],                 -- tag
                                t[i+3] )                -- exp    (fr)
            end
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

    -- "_pre" because of SetBlock assignment
    _Dcl_var_pre = function (me)
        local pre, tp, hasConstr = unpack(me)
        local ret = {}
        local t = { unpack(me,4) }  -- skip pre,tp,hasConstr

        if hasConstr then
            table.remove(me, 3)
            me.tag = 'Dcl_var'
            return
        end

        -- id, op, tag, exp
        for i=1, #t, 4 do
            ret[#ret+1] = node('Dcl_var', me.ln, pre, AST.copy(tp), t[i])
            if t[i+1] then
                ret[#ret+1] = node('_Set', me.ln,
                                node('Var', me.ln, t[i]),  -- var
                                t[i+1],                 -- op
                                t[i+2],                 -- tag
                                t[i+3] )                -- exp    (fr)
            end
        end
        return node('Stmts', me.ln, unpack(ret))
    end,

-- Tuples ---------------------

    _TupleTypeItem_2 = '_TupleTypeItem_1',
    _TupleTypeItem_1 = function (me)
        me.tag = 'TupleTypeItem'
    end,
    _TupleType_2 = '_TupleType_1',
    _TupleType_1 = function (me)
        me.tag = 'TupleType'
    end,

    --  <v> = await <E> until <CND>
    --      -- becomes --
    --  loop do
    --      <v> = await <E>;
    --      if <CND> then
    --          break;
    --      end
    --  end
    __await_until = function (me, stmt)
        local _, _, cnd = unpack(me)
        if cnd then
            me[3] = nil
            local ret = node('_Loop', me.ln, false, false, false,
                            node('Stmts', me.ln,
                                stmt,
                                node('If', me.ln, cnd,
                                    node('Break', me.ln),
                                    node('Nothing', me.ln))))
            ret.isAwaitUntil = true -- see tmps/fins
            return ret
        else
            return nil
        end
    end,

    __await_opts = function (me, stmt)
        local e, dt, cnd, ok = unpack(me)

        -- TODO: ugly hack
        if ok then return end
        me[4] = true

        -- HACK_6: figure out if OPT-1 or OPT-2 or OPT-3:
        --      await <EVT>
        --      await <ADT>
        --      await <ORG>
        local var = e or dt     -- TODO: hacky
        local tst = node('_TMP_AWAIT', me.ln, var)

        local SET_KILL = node('Nothing', me.ln)
        local SET_DEAD = node('Nothing', me.ln)
        if stmt.tag == 'Set' then
            local to = AST.asr(stmt,'Set', 4,'VarList', 1,'Var')
            SET_KILL = node('Set', me.ln, '=', 'exp',
                        node('Op2_.', me.ln, '.',
                            node('Op1_*', me.ln, '*',
                                node('Var', me.ln, '__awk_org_'..me.n)),
                            'ret'),
                        AST.copy(to))
            SET_DEAD = node('Set', me.ln, '=', 'exp',
                        node('Op1_cast', me.ln,
                            node('Type', me.ln, 'int', 0, false, false),
                            node('Op2_.', me.ln, '.',
                                node('Op1_*', me.ln, '*',
                                    node('Op1_cast', me.ln,
                                        node('Type', me.ln, '_tceu_org', 1, false, false),
                                        node('Op1_&', me.ln, '&',
                                            AST.copy(var)))),
                                'ret')),
                        AST.copy(to))
        end

        return
            node('Stmts', me.ln,
                -- HACK_6: figure out if OPT-1 or OPT-2 or OPT-3
                tst,  -- "var" needs to be parsed before OPT-[123]

                -- OPT-1
                stmt,

                -- OPT-2
                node('If', me.ln,
                    node('Op2_.', me.ln, '.',
                        node('Op1_*', me.ln, '*',
                            AST.copy(var)),
                        'HACK_6-NIL'),
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Nothing', me.ln))),
                    node('Block', me.ln,
                        node('Stmts', me.ln,
                            node('Dcl_var', me.ln, 'var',
                                node('Type', me.ln, 'void', 1, false, false),
                                '__old_adt_'..me.n),
                            node('Set', me.ln, '=', 'exp',
                                node('Op1_cast', me.ln,
                                    node('Type', me.ln, 'void', 1, false, false),
                                    AST.copy(var)),
                                node('Var', me.ln, '__old_adt_'..me.n)),
                            node('Dcl_var', me.ln, 'var',
                                node('Type', me.ln, 'void', 1, false, false),
                                '__awk_adt_'..me.n,
                                false,
                                true), -- isTmp
                            node('_Set', me.ln,
                                node('Var', me.ln, '__awk_adt_'..me.n),
                                '=', 'await',
                                node('Await', me.ln,
                                    node('Ext', me.ln, '_ok_killed'),
                                    false,
                                    node('Op2_==', me.ln, '==',
                                        node('Var', me.ln, '__old_adt_'..me.n),
                                        node('Var', me.ln, 
                                        '__awk_adt_'..me.n)),
                                    true))))),

                -- OPT-3
-- TODO: workaround bug do IF-then-else com await no then e ptr no else
-- *not* isAlive para inverter then/else
                node('Stmts', me.ln,
                    node('If', me.ln,
                        node('Op1_not', me.ln, 'not',
                            node('Op2_.', me.ln, '.',
                                node('Op1_*', me.ln, '*',
                                    -- this cast confuses acc.lua (see Op1_* there)
                                    -- TODO: HACK_3
                                    node('Op1_cast', me.ln,
                                        node('Type', me.ln, '_tceu_org', 1, false, false),
                                        AST.copy(var))),
                                'isAlive')),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                SET_DEAD)),
                        node('Block', me.ln,
                            node('Stmts', me.ln,
                                node('Dcl_var', me.ln, 'var',
                                    node('Type', me.ln, 'u32', 0, false, false),
                                    '__org_id_'..me.n),
                                node('_Set', me.ln,
                                    node('Var', me.ln, '__org_id_'..me.n),
                                    '=', 'exp',
                                    node('Op2_.', me.ln, '.',
                                        node('Op1_*', me.ln, '*',
                                            node('Op1_cast', me.ln,
                                                node('Type', me.ln, '_tceu_org', 1, false, false),
                                                AST.copy(var))),
                                        'id')),
                                node('Dcl_var', me.ln, 'var',
                                    node('Type', me.ln, '_tceu_org_kill', 1, false, false),
                                    '__awk_org_'..me.n,
                                    false,
                                    true),  -- isTmp
                                node('_Set', me.ln,
                                    node('Var', me.ln, '__awk_org_'..me.n),
                                    '=', 'await',
                                    node('Await', me.ln,
                                        node('Ext', me.ln, '_ok_killed'),
                                        false,
                                        node('Op2_==', me.ln, '==',
                                            node('Op2_.', me.ln, '.',
                                                node('Op1_*', me.ln, '*',
                                                    node('Var', me.ln, '__awk_org_'..me.n)),
                                                'org'),
                                            node('Var', me.ln, '__org_id_'..me.n)),
                                        true)),
                                SET_KILL)))))
    end,

    Await_pre = function (me)
        local e, dt, cnd = unpack(me)

        -- wclock event, change "e" and insert "dt"
        if dt then
            me[1] = node('Ext', me.ln, '_WCLOCK')
        end

        --  await <E> until <CND>
        --      -- becomes --
        --  loop do
        --      await <E>;
        --      if <CND> then
        --          break;
        --      end
        --  end
        local ret = F.__await_until(me,me)
        if ret then
            return ret
        end

        return F.__await_opts(me, me)
    end,

    _Set_pre = function (me)
        local to, op, tag, fr = unpack(me)

        if tag == 'exp' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag == 'await' then
            local ret   -- Set or Loop (await-until)

            --local ret
            --local awt = fr
            --local T = node('Stmts', me.ln)

            if to.tag ~= 'VarList' then
                to = node('VarList', me.ln, to)
            end
            ret = node('Set', me.ln, op, tag, fr, to)

            ret = F.__await_until(fr,ret) or ret
            ret = F.__await_opts(fr,ret)  or ret

            return ret

        elseif tag == 'block' then
            return node('SetBlock', me.ln, fr, to)

        elseif tag == 'thread' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag == 'emit-ext' then
            AST.asr(fr, 'EmitExt')
            local op_emt, e, ps = unpack(fr)
            if op_emt == 'request' then
                return REQUEST(me)

            else
                return node('Set', me.ln, op, tag, fr, to)
            end

        elseif tag=='spawn' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag=='adt-constr' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag == 'do-org' then
            return F._DoOrg_pre(fr, to)

        elseif tag == 'lua' then
            return node('Set', me.ln, op, tag, fr, to)

        elseif tag == '__trav_rec' then
            local rec = AST.asr(me,'_Set', 4,'_TraverseRec')
            assert(op == '=', 'bug found')
            rec[#rec+1] = to;
            return rec

        elseif tag == '__trav_loop' then
            local rec = AST.asr(me,'_Set', 4,'_TraverseLoop')
            assert(op == '=', 'bug found')
            rec[#rec+1] = to;
            return rec

        else
            error 'not implemented'
        end
    end,

-- Lua --------------------------------------------------------

    _LuaExp = function (me)
        --[[
        -- a = @a ; b = @b
        --
        -- __ceu_1, __ceu_2 = ...
        -- a = __ceu_1 ; b = __ceu_2
        --]]
        local params = {}
        local code = {}
        local names = {}
        for _, v in ipairs(me) do
            if type(v) == 'table' then
                params[#params+1] = v
                code[#code+1] = '_ceu_'..#params
                names[#names+1] = code[#code]
            else
                code[#code+1] = v;
            end
        end

        -- me.ret:    node to assign result ("_Set_pre")
        -- me.params: @v1, @v2
        -- me.lua:    code as string

        me.params = params
        if #params == 0 then
            me.lua = table.concat(code,' ')
        else
            me.lua = table.concat(names,', ')..' = ...\n'..
                     table.concat(code,' ')
        end

        me.tag = 'Lua'
    end,
    _LuaStmt = '_LuaExp',

-- EmitExt --------------------------------------------------------

    EmitExt_pre = function (me)
        local op, e, ps = unpack(me)

        -- wclock event, set "e"
        if e == false then
            me[2] = node('Ext', me.ln, '_WCLOCK')
        end

        -- adjust to ExpList
        if ps == false then
            -- emit A;
            -- emit A => ();
            ps = node('ExpList', me.ln)
        elseif ps.tag == 'ExpList' then
            -- ok
        else
            -- emit A => 1;
            -- emit A => (1);
            ps = node('ExpList', me.ln, ps)
        end
        me[3] = ps

        if op == 'request' then
            return REQUEST(me)
        end
    end,
    _EmitInt_pre = function (me)
        me.tag = 'EmitInt'
        me = F.EmitExt_pre(me) or me
        --[[
        -- TODO-RESEARCH-1:
        -- If an "emit" is on the stack and its enclosing block "self-aborts",
        -- we need to remove the "emit" from the stack because its associated
        -- payload may have gone out of scope:
        --
        --  par/or do
        --      par/or do
        --          var int x;
        --          emit e => &x;
        --      with
        --          await e;    // aborts "emit" block w/ "x"
        --      end
        --  with
        --      px = await e;
        --      *px;            // "x" is out of scope
        --  end
        --
        -- To remove, we need to "finalize" the "emit" removing itself from the
        -- stack:

        --  emit x;
        --      ... becomes ...
        --  do
        --      var int fin = stack_nxti() + sizeof(tceu_stk);
        --                      /* TODO: two levels up */
        --      finalize with
        --          if (fin != CEU_STACK_MAX) then
        --              stack_get(fin)->evt = IN_NONE;
        --          end
        --      end
        --      emit x;
        --      fin = CEU_STACK_MAX;
        --  end
        --
        -- Alternatives:
        --      - forbid pointers in payloads: we could then allow an "emit" to
        --        stay in the stack even if its surrounding block aborts
        --      - statically detect if an "emit" can be aborted
        --          - generate a warning ("slow code") and the code above if it
        --            is the case
        --
        -- TODO: this may have solved the problem with await/awake in the same reaction
        --]]
        return
            node('Block', me.ln,
                node('Stmts', me.ln,
                    node('_Dcl_nat', me.ln, '@plain', 'unk', '_tceu_nstk', false),
                    node('Dcl_var', me.ln, 'var',
                        node('Type', me.ln, '_tceu_nstk', 0, false, false),
                        '_emit_fin_'..me.n),
                    node('_Set', me.ln,
                        node('Var', me.ln, '_emit_fin_'..me.n),
                        '=', 'exp',
                        node('RawExp', me.ln,
                            '(stack_nxti(_ceu_go)+sizeof(tceu_stk))',
                            true)),
                    node('Finalize', me.ln,
                        false,
                        node('Finally', me.ln,
                            node('Block', me.ln,
                                node('Stmts', me.ln,
                                    node('_Dcl_nat', me.ln, '@nohold', 'func', '_stack_get', false),
                                    node('If', me.ln,
                                        node('Op2_==', me.ln, '==',
                                            node('Var', me.ln, '_emit_fin_'..me.n),
                                            node('Nat', me.ln, '_CEU_STACK_MAX')),
                                        node('Block', me.ln,
                                            node('Stmts', me.ln,
                                                node('Nothing', me.ln))),
                                        node('Block', me.ln,
                                            node('Stmts', me.ln,
                                                node('_Set', me.ln,
                                                    node('Op2_.', me.ln, '.',
                                                        node('Op1_*', me.ln, '*',
                                                            node('Op2_call', 
                                                                me.ln,
                                                                'call',
                                                                node('Nat', me.ln, '_stack_get', true),
                                                                node('ExpList', me.ln,
                                                                    node('Nat', me.ln, '__ceu_go', true),
                                                                    node('Var', me.ln, '_emit_fin_'..me.n)))),
                                                        'evt'),
                                                    '=', 'exp',
                                                    node('Nat', me.ln, '_CEU_IN__NONE', true))))))))),
                    me,
                    node('_Set', me.ln,
                        node('Var', me.ln, '_emit_fin_'..me.n),
                        '=', 'exp',
                        node('Nat', me.ln, '_CEU_STACK_MAX'))))
    end,

-- Finalize ------------------------------------------------------

    Finalize_pos = function (me)
        local sub = unpack(me)
        if sub then
            local _,set,fr,to = unpack(sub)
            ASR(set=='exp', me, 'invalid `finalize´')
        end
    end,

-- Pause ---------------------------------------------------------

    _Pause_pre = function (me)
        local evt, blk = unpack(me)
        local cur_id  = '_cur_'..blk.n
        local cur_dcl = node('Dcl_var', me.ln, 'var',
                            node('Type', me.ln, 'bool', 0, false, false),
                            cur_id)

        local PSE = node('Pause', me.ln, blk)
        PSE.dcl = cur_dcl

        local on  = node('PauseX', me.ln, 1)
            on.blk  = PSE
        local off = node('PauseX', me.ln, 0)
            off.blk = PSE

        return
            node('Block', me.ln,
                node('Stmts', me.ln,
                    cur_dcl,    -- Dcl_var(cur_id)
                    node('Set', me.ln, '=', 'exp',
                        node('NUMBER', me.ln, 0),
                        node('Var', me.ln, cur_id)),
                    node('ParOr', me.ln,
                        node('_Loop', me.ln, false, false, false,
                            node('Stmts', me.ln,
                                node('_Set', me.ln,
                                    node('Var', me.ln, cur_id),
                                    '=', 'await',
                                    node('Await', me.ln, evt, false)),
                                node('If', me.ln,
                                    node('Var', me.ln, cur_id),
                                    on,
                                    off))),
                        PSE)))
    end,
--[=[
        var u8 psed? = 0;
        par/or do
            loop do
                psed? = await <evt>;
                if psed? then
                    PauseOff()
                else
                    PauseOn()
                end
            end
        with
            pause/if (cur) do
                <blk>
            end
        end
]=]

-- Op2_: ---------------------------------------------------

    ['Op2_:_pre'] = function (me)
        local _, ptr, fld = unpack(me)
        return node('Op2_.', me.ln, '.',
                node('Op1_*', me.ln, '*', ptr),
                fld)
    end,
}

AST.visit(F)

-- ADTs ----------------------------------------------------------------------
-- separate visit because of "?" types

-- ADTs created implicitly by "?" option type declarations
local ADTS = {}

G = {
    Stmts_pos = function (me)
        if me.__add then
            for i=#me.__add, 1, -1 do
                table.insert(me, 1, me.__add[i])
            end
            me.__add = nil
        end
    end,

    Type_pre = function (me)
        local id, ptr, arr, ref, opt = unpack(me)
        if not opt then
            return
        end

        me[5] = nil
        local cpy = AST.copy(me)    -- w/o opt

        local tp = id..'__'..ptr..'__'..tostring(arr)..'__'..tostring(ref)
        local n = ADTS[tp]
        if not n then
            n = #ADTS + 1
            ADTS[tp] = n
            local adt = node('Dcl_adt', me.ln, '_Option_'..n,
                            'union',
                            node('Dcl_adt_tag', me.ln, 'NIL'),
                            node('Dcl_adt_tag', me.ln, 'SOME',
                                node('Stmts', me.ln,
                                    node('Dcl_var', me.ln, 'var', cpy, 'v'))))
            ADTS[n] = adt
            adt.__adj_opt = me

            -- add declarations on enclosing "Stmts"
            local stmts = assert(AST.par(me,'Stmts'))
            stmts.__add = stmts.__add or {}
            stmts.__add[#stmts.__add+1] = adt
        end
        me[5] = node('Type', me.ln, '_Option_'..n, 0, false, false, false)
    end,
}

local CLSS = {}  -- holds all clss
local function id2ifc (id)
    for _, cls in ipairs(CLSS) do
        local _,id2 = unpack(cls)
        if id2 == id then
            return cls
        end
    end
    return nil
end

H = {
    -----------------------------------------------------------------------
    -- substitutes all Dcl_imp for the referred fields
    -----------------------------------------------------------------------
    Dcl_cls_pos = function (me)
        CLSS[#CLSS+1] = me
    end,
    Root = function (me)
        for _, cls in ipairs(CLSS) do
            if cls.tag=='Dcl_cls' and cls[2]~='Main' then   -- "Main" has no Dcl_imp's
                local dcls1 = AST.asr(cls.blk_ifc[1][1],'BlockI')[1]
                local i = 1
                while i <= #dcls1 do
                    local imp = dcls1[i]
                    if imp.tag == '_Dcl_imp' then
                        -- interface A,B,...
                        for _,dcl in ipairs(imp) do
                            local ifc = id2ifc(dcl)  -- interface must exist
                            ASR(ifc and ifc[1]==true,
                                imp, 'interface "'..dcl..'" is not declared')
                            local dcls2 = AST.asr(ifc.blk_ifc[1][1],'BlockI')[1]
                            for _, dcl2 in ipairs(dcls2) do
                                assert(dcl2.tag ~= 'Dcl_imp')   -- impossible because I'm going in order
                                if dcl2.tag == 'Dcl_adt' then
                                    -- skip ADT implicit declarations to avoid duplication
                                else
                                    local new = AST.copy(dcl2)
                                    dcls1[#dcls1+1] = new -- fields from interface should go to the end
                                    new.isImp = true      -- to avoid redeclaration warnings indeed
                                end
                            end
                        end
                        table.remove(dcls1, i) -- remove _Dcl_imp
                        i = i - 1                    -- repeat
                    else
                    end
                    i = i + 1
                end
            end
        end
    end,

    -----------------------------------------------------------------------

    Dcl_adt_pos = function (me)
        -- id, op, ...
        local _, op = unpack(me)

        if op == 'struct' then
            local n = #me

            -- variable declarations require a block
            me[3] = node('Block', me.ln,
                        node('Stmts', me.ln, select(3,unpack(me))))

            for i=4, n do
                me[i] = nil -- all already inside block
            end

        else
            assert(op == 'union')
            for i=3, #me do
                AST.asr(me[i], 'Dcl_adt_tag')
                local n = #me[i]
                -- variable declarations require a block
                if n == 1 then
                    -- void enum: include empty Stmts (Block requires them)
                    me[i][2] = node('Block', me.ln, node('Stmts',me.ln))
                else
                    -- non-void enum
                    me[i][2] = node('Block', me.ln, select(2,unpack(me[i])))
                end
                for j=3, n do
                    me[i][j] = nil  -- all already inside block
                end
            end
        end
    end,

    _Adt_explist_pos = function (me)
        me.tag = 'ExpList'
    end,
}
AST.visit(G)
AST.visit(H)

end

    
do
ENV = {
    clss     = {},  -- { [1]=cls, ... [cls]=0 }
    clss_ifc = {},
    clss_cls = {},

    adts = {},      -- { [1]=adt, ... [adt]=0 }

    calls = {},     -- { _printf=true, _myf=true, ... }

    -- f=fields, e=events
    ifcs  = {
        flds = {}, -- {[1]='A',[2]='B',A=0,B=1,...}
        evts = {}, -- ...
        funs = {}, -- ...
        trls = {}, -- ...
    },

    exts = {
        --[1]=ext1,         [ext1.id]=ext1.
        --[N-1]={_ASYNC},   [id]={},
        --[N]={_WCLOCK},    [id]={},
    },

    -- TODO: move to TP
    -- "len" is used to sort fields on generated "structs"
    -- TODO: try to remove ENV.c, a lot is shared w/ Type (e.g. hold)
    c = {
        void = 0,

        word     = OPTS.tp_word,
        pointer  = OPTS.tp_word,

        bool     = 1,
        byte     = 1,
        char     = 1,
        int      = OPTS.tp_word,
        uint     = OPTS.tp_word,
        u8=1, u16=2, u32=4, u64=8,
        s8=1, s16=2, s32=4, s64=8,

        float    = OPTS.tp_word,
        f32=4, f64=8,

        tceu_ncls = true,    -- env.lua
        tceu_nlbl = true,    -- labels.lua
    },
    dets  = {},

    max_evt = 0,    -- max # of internal events (exts+1 start from it)
}

for k, v in pairs(ENV.c) do
    if v == true then
        ENV.c[k] = { tag='type', id=k, len=nil }
    else
        ENV.c[k] = { tag='type', id=k, len=v }
    end
end

function CLS ()
    return AST.iter'Dcl_cls'()
end
function ADT ()
    return AST.iter'Dcl_adt'()
end

function var2ifc (var)
    local tp
    if var.pre=='var' or var.pre=='pool' then
        tp = TP.toc(var.tp)
    elseif var.pre == 'event' then
        tp = TP.toc(var.evt.ins)
    elseif var.pre == 'function' then
        tp = TP.toc(var.fun.ins)..'$'..TP.toc(var.fun.out)
    else
        error 'not implemented'
    end
    tp = var.pre..'__'..tp
    return table.concat({
        var.id,
        tp,
        tostring(var.pre),
        var.tp.arr and '[]' or '',
    }, '$')
end

function ENV.ifc_vs_cls_or_ifc (ifc, cls)
    assert(ifc.is_ifc)
    -- check if they have been checked
    if ifc.matches[cls] ~= nil then
        return ifc.matches[cls]
    end

    -- check if they match
    for _, v1 in ipairs(ifc.blk_ifc.vars) do
        v2 = cls.blk_ifc.vars[v1.id]
        if v2 then
            v2.ifc_id = v2.ifc_id or var2ifc(v2)
        end
        if (not v2) or (v1.ifc_id~=v2.ifc_id) then
            ifc.matches[cls] = false
            return false
        end
    end

    -- yes, they match
    ifc.matches[cls] = true
    if not cls.is_ifc then
        cls.matches[ifc] = true
    end
    return true
end

-- unique numbers for vars and events
local _N = 0
local _E = 1    -- 0=NONE

local function check (me, pre, tp)
    if tp.tag == 'TupleType' then
        for _, item in ipairs(tp) do
            check(me, pre, AST.asr(item,'', 2,'Type'))
        end
        return
    end

    local top = ASR(ENV.c[tp.id] or ENV.clss[tp.id] or ENV.adts[tp.id],
                    me, 'undeclared type `'..(tp.id or '?')..'´')

    if tp.ptr==0 and (not tp.ref) then
        ASR(not AST.isParent(top,me), me,
            'undeclared type `'..(tp.id or '?')..'´')
        if top.is_ifc then
            ASR(pre == 'pool', me,
                'cannot instantiate an interface')
        end
    else
        top = nil
    end

    local void_ok = (tp.id=='void' and
                    (pre=='event' or pre=='function' or pre=='input' or
                     pre=='output' or pre=='isr'))

    ASR(tp.ptr>0 or tp.ref or TP.get(tp.id).len~=0 or void_ok,
        me, 'cannot instantiate type "'..tp.id..'"')
    --ASR((not arr) or arr>0, me, 'invalid array dimension')

    return top
end

function ENV.v_or_ref (tp, cls_or_adt)
    if cls_or_adt == 'cls' then
        return (tp.ptr==0) and ENV.clss[tp.id]
    elseif cls_or_adt == 'adt' then
        return (tp.ptr==0) and ENV.adts[tp.id]
    else
        return (tp.ptr==0) and (ENV.clss[tp.id] or ENV.adts[tp.id])
    end
end

function newvar (me, blk, pre, tp, id, isImp, isEvery)
    local ME = CLS() or ADT()  -- (me can be a "data" declaration)
    for stmt in AST.iter() do
        if stmt.tag=='Dcl_cls' or stmt.tag=='Dcl_adt' or
           stmt.tag=='Async' or stmt.tag=='Thread'
        then
            break   -- search boundaries
        elseif stmt.tag == 'Block' then
            for _, var in ipairs(stmt.vars) do
                --ASR(var.id~=id or var.blk~=blk, me,
                    --'variable/event "'..var.id..
                    --'" is already declared at --line '..var.ln)
                if var.id == id then
                    local fun = pre=='function' and stmt==ME.blk_ifc -- dcl
                                                and blk==ME.blk_ifc  -- body
                    if fun or id=='_ok' or isImp then
                        -- no problem with hide
                    elseif isEvery then
                        ASR(false, me,
                            'implicit declaration of "'..id..'" hides the one at line '
                                ..var.ln[2])
                    else
                        WRN(false, me,
                            'declaration of "'..id..'" hides the one at line '
                                ..var.ln[2])
                    end
                    --if (blk==ME.blk_ifc or blk==ME.blk_body) then
                        --ASR(false, me, 'cannot hide at top-level block' )
                end
            end
        end
    end

    local top = check(me, pre, tp)

    -- Class definitions take priority over interface definitions:
    --      * consts
    --      * rec => norec methods
    if blk.vars[id] and (blk==ME.blk_ifc) then
        return true, blk.vars[id]
    end

    local var = {
        ln    = me.ln,
        id    = id,
        blk   = blk,
        tp    = tp,
        cls   = (top and top.tag=='Dcl_cls' and top) or (id=='_top_pool'),
        adt   = (top and top.tag=='Dcl_adt' and top),
        pre   = pre,
        inTop = (blk==ME.blk_ifc) or (blk==ME.blk_body) or AST.par(me,'Dcl_adt'),
                -- (never "tmp")
        isTmp = false,
        --arr   = arr,
        n     = _N,
    }

    if pre=='var' and (not tp.arr) then
        var.lval = var
    elseif pre=='pool' and (ENV.adts[tp.id] or tp.ref) then
        var.lval = var
    else
        var.lval = false
    end

    _N = _N + 1
    blk.vars[#blk.vars+1] = var
    blk.vars[id] = var -- TODO: last/first/error?
    -- TODO: warning in C (hides)

    return false, var
end

function newint (me, blk, pre, tp, id, isImp)
    local has, var = newvar(me, blk, pre,
                        {id='void',ptr=0,arr=false,ref=false,ext=false},
                        id, isImp)
    if has then
        return true, var
    end
    local evt = {
        id  = id,
        idx = _E,
        ins = tp,
        pre = pre,
    }
    var.evt = evt
    _E = _E + 1
    return false, var
end

function newfun (me, blk, pre, rec, ins, out, id, isImp)
    rec = not not rec
    local old = blk.vars[id]
    if old then
        ASR(TP.toc(ins)==TP.toc(old.fun.ins) and
            TP.toc(out)==TP.toc(old.fun.out) and
            (rec==old.fun.mod.rec or (not old.fun.mod.rec)),
            me, 'function declaration does not match the one at "'..
                old.ln[1]..':'..old.ln[2]..'"')
        -- Accept rec mismatch if old is not (old is the concrete impl):
        -- interface with rec f;
        -- class     with     f;
        -- When calling from an interface, call/rec is still required,
        -- but from class it is not.
    end

    check(me, pre, ins)
    check(me, pre, out)

    local has, var = newvar(me, blk, pre,
                        TP.fromstr('___typeof__(CEU_'..CLS().id..'_'..id..')'),
                        -- TODO: TP.toc eats one '_'
                        id, isImp)
    if has then
        return true, var
    end
    local fun = {
        id  = id,
        ins = ins,
        out = out,
        pre = pre,
        mod = { rec=rec },
        isExt = string.upper(id)==id,
    }
    var.fun = fun
    return false, var
end

local function __vars_check (vars, id)
    if vars.__cache then
        return vars.__cache[id]
    else
        vars.__cache = {}
        for _,var in ipairs(vars) do
            local id = unpack(var)
            vars.__cache[id] = true
        end
        return __vars_check(vars,id)
    end
end

function ENV.getvar (id, blk)
    local blk = blk or AST.iter('Block')()
    while blk do
        if blk.tag=='Dcl_cls' or blk.tag=='Dcl_adt' then
            return nil      -- class/adt boundary
        elseif blk.tag=='Async' or blk.tag=='Thread' then
            local vars = unpack(blk)    -- VarList
            if not (vars and __vars_check(vars,id)) then
                return nil  -- async boundary: stop unless declared with `&´
            end
        elseif blk.tag == 'Block' then
            for i=#blk.vars, 1, -1 do   -- n..1 (hidden vars)
                local var = blk.vars[i]
                if var.id == id then
                    return var
                end
            end
        end
        blk = blk.__par
    end
    return nil
end

-- identifiers for ID_c / ID_ext (allow to be defined after annotations)
-- variables for Var
function det2id (v)
    if type(v) == 'string' then
        return v
    else
        return v.var
    end
end

local STACK_N_E = { }

F = {
    Type = function (me)
        TP.new(me)
    end,
    TupleType_pos = 'Type',

    Root_pre = function (me)
        -- TODO: NONE=0
        -- TODO: if PROPS.* then ... end

        local t = {
        -- runtime
            { '_STK',       nil,        nil },
            { '_ORG',       nil,        nil },
            { '_ORG_PSED',  nil,        nil },
            { '_CLEAR',     nil,        nil },
            { '_ok_killed', 'void',     1   },
        -- input / runtime
            { '_INIT',      nil,        nil, 'seqno' },      -- _INIT = HIGHER EXTERNAL
            { '_ASYNC',     nil,        nil, 'seqno' },
            { '_THREAD',    nil,        nil, 'seqno' },
            { '_WCLOCK',    's32',      0,   'seqno' },
        }

        if OPTS.timemachine then
            t[#t+1] = { '_WCLOCK_', 's32', 0, 'seqno' }
        end

        -- input / user
        if OPTS.os then
            t[#t+1] = { 'OS_START',     'void', 0, 'seqno' }
            t[#t+1] = { 'OS_STOP',      'void', 0, 'seqno' }
            t[#t+1] = { 'OS_DT',        'int',  0, 'seqno' }
            t[#t+1] = { 'OS_INTERRUPT', 'int',  0, 'seqno' }
        end

        for _, v in ipairs(t) do
            local id, tp, ptr, seqno = unpack(v)
            local _tp = tp and AST.node('Type', me.ln, tp, ptr, false, false)
            local evt = {
                ln  = me.ln,
                id  = id,
                pre = 'input',
                ins = tp and AST.node('TupleType', me.ln,
                                AST.node('TupleTypeItem', me.ln, false, _tp, false)),
                mod = { rec=false },
                seqno = seqno,
                os  = true,     -- do not generate #define with OPTS.os==true
            }
            if tp then
                TP.new(_tp)
                TP.new(evt.ins)
            end
            ENV.exts[#ENV.exts+1] = evt
            ENV.exts[id] = evt
        end
        ENV.exts._WCLOCK.op = 'emit'
    end,

    Root = function (me)
        TP.types.tceu_ncls.len = TP.n2bytes(#ENV.clss_cls*2)
        -- Tkachov & fsantanna, July 31, 2015:           *2 (signed => unsigned)
        ASR(ENV.max_evt+#ENV.exts < 255, me, 'too many events')
                                    -- 0 = NONE

        -- matches all ifc vs cls/ifc
        for _, ifc in ipairs(ENV.clss_ifc) do
            for _, cls in ipairs(ENV.clss) do
                local matches = ENV.ifc_vs_cls_or_ifc(ifc, cls)
                -- TODO: HACK_4: delayed declaration until use
                if matches then
                    ifc.__env_last_match = cls
                        -- interface must be declared only after last class
                end
            end
        end
        local glb = ENV.clss.Global
        if glb then
            ASR(glb.is_ifc and glb.matches[ENV.clss.Main], me,
                'interface "Global" must be implemented by class "Main"')
        end
    end,

    Block_pre = function (me)
        me.vars = {}

        -- include arguments into function block
        local fun = AST.iter()()
        local _, _, inp, out = unpack(fun)
        if fun.tag == 'Dcl_fun' then
            for i, v in ipairs(inp) do
                local _, tp, id = unpack(v)
                if tp ~= 'void' then
                    local has,var = newvar(fun, me, 'var', tp, id, false)
                    assert(not has)
                    var.isTmp  = true -- TODO: var should be a node
                    var.isFun  = true
                    var.funIdx = i
                end
            end
        end
    end,

    Dcl_cls_pos = function (me)
        _N, _E = unpack(STACK_N_E[#STACK_N_E])
        STACK_N_E[#STACK_N_E] = nil
    end,
    Dcl_cls_pre = function (me)
        local ifc, id, blk = unpack(me)
        me.c       = {}      -- holds all "native _f()"
        me.is_ifc  = ifc
        me.id      = id
        me.tp      = TP.fromstr(id)
        me.matches = {}

        -- restart variables/events counting
        STACK_N_E[#STACK_N_E+1] = { _N, _E }

        ASR(not (ENV.clss[id] or ENV.adts[id]), me,
            'top-level identifier "'..id..'" already taken')
        ENV.clss[id] = me
        ENV.clss[#ENV.clss+1] = me

        if me.is_ifc then
            me.n = #ENV.clss_ifc   -- TODO: n=>?
            ENV.clss_ifc[id] = me
            ENV.clss_ifc[#ENV.clss_ifc+1] = me
        else
            me.n = #ENV.clss_cls   -- TODO: remove Main?   -- TODO: n=>?
            ENV.clss_cls[id] = me
            ENV.clss_cls[#ENV.clss_cls+1] = me
        end
    end,
    Dcl_cls = function (me)
        ENV.max_evt = MAX(ENV.max_evt, _E)

        -- all identifiers in all interfaces get a unique (sequential) N
        if me.is_ifc then
            for _, var in pairs(me.blk_ifc.vars) do
                var.ifc_id = var.ifc_id or var2ifc(var)
                if not ENV.ifcs[var.ifc_id] then
                    if var.pre=='var' or var.pre=='pool' then
                        ENV.ifcs.flds[var.ifc_id] = #ENV.ifcs.flds
                        ENV.ifcs.flds[#ENV.ifcs.flds+1] = var.ifc_id
                    elseif var.pre == 'event' then
                        ENV.ifcs.evts[var.ifc_id] = #ENV.ifcs.evts
                        ENV.ifcs.evts[#ENV.ifcs.evts+1] = var.ifc_id
                    elseif var.pre == 'function' then
                        ENV.ifcs.funs[var.ifc_id] = #ENV.ifcs.funs
                        ENV.ifcs.funs[#ENV.ifcs.funs+1] = var.ifc_id
                    end
                end
            end
        end
    end,

    Dcl_adt_pre = function (me)
        local id, op = unpack(me)
-- TODO: is it possible to remove __adj_opt?
        me.tp = TP.fromstr(id, me.__adj_opt)
        me.tp.opt = me.__adj_opt
                    -- recover this information from implicitly created ADTs

        ASR(not (ENV.adts[id] or ENV.clss[id]), me,
            'top-level identifier "'..id..'" already taken')
        ENV.adts[id] = me
        ENV.adts[#ENV.adts+1] = me
    end,
    Dcl_adt = function (me)
        local id_adt, op = unpack(me)
        me.id = id_adt

        if op == 'struct' then
            -- convert vars=>tuple (to check constructors)
            me.tup = AST.node('TupleType', me.ln)

            -- Dcl_adt[3]->Block[1]->Stmts[*]->Stmts
            local STMTS = AST.asr(me,'', 3,'Block', 1,'Stmts')
            for _, stmts in ipairs(STMTS) do
                AST.asr(stmts, 'Stmts')
                for _, dclvar in ipairs(stmts) do
                    AST.asr(dclvar, 'Dcl_var')
                    local _, var_tp, var_id = unpack(dclvar)
                    local item = AST.node('TupleTypeItem', me.ln,
                                    false,var_tp,false)
                    me.tup[#me.tup+1] = item
                    item.var_id = var_id
                end
            end

            TP.new(me.tup)

        else
            assert(op == 'union')
            me.tags = {} -- map tag=>{blk,tup}
            for i=3, #me do
                AST.asr(me[i], 'Dcl_adt_tag')
                local id_tag, blk = unpack(me[i])
                local tup = AST.node('TupleType',me.ln)
                me.tags[id_tag] = { blk=blk, tup=tup }
                me.tags[#me.tags+1] = id_tag

                if blk then -- skip void enums
                    for _, stmts in ipairs(blk) do
                        AST.asr(stmts, 'Stmts')
                        local dclvar = unpack(stmts)
                        if dclvar then
                            local _, var_tp, var_id = unpack(dclvar)
                            local item = AST.node('TupleTypeItem', me.ln,
                                            false,var_tp,false)
                            if var_tp.id == id_adt then
                                me.is_rec = true
                                item.is_rec = true
                            end
                            tup[#tup+1] = item
                            item.var_id = var_id
                        end
                    end
                end

                TP.new(tup, true)
            end
        end
    end,

    Dcl_det = function (me)                 -- TODO: verify in ENV.c
        local id1 = det2id(me[1])
        local t1 = ENV.dets[id1] or {}
        ENV.dets[id1] = t1
        for i=2, #me do
            local id2 = det2id(me[i])
            local t2 = ENV.dets[id2] or {}
            ENV.dets[id2] = t2
            t1[id2] = true
            t2[id1] = true
        end
    end,

    Global = function (me)
        ASR(ENV.clss.Global and ENV.clss.Global.is_ifc, me,
            'interface "Global" is not defined')
        me.tp   = TP.fromstr'Global*'
        me.lval = false
        me.blk  = AST.root
    end,

    Outer = function (me)
        local cls = CLS()
            --ASR(cls ~= MAIN, me, 'invalid access')
        ASR(cls, me, 'undeclared class')
        me.tp   = cls.tp
        me.lval = false
        me.blk  = cls.blk_ifc
    end,

    This = function (me)
        -- if inside constructor, change scope to the class being created
        local constr = AST.iter'Dcl_constr'()
        local cls = constr and constr.cls or CLS()
        ASR(cls, me, 'undeclared class')
        me.tp   = cls.tp
        me.lval = false
        me.blk  = cls.blk_ifc
    end,

    Free = function (me)
        local exp = unpack(me)
        ASR(exp.tp.ptr==1 and ENV.clss[exp.tp.id], me, 'invalid `free´')
    end,

    Dcl_ext = function (me)
        local dir, rec, ins, out, id = unpack(me)
        local ext = ENV.exts[id]
        if ext then
            local eq = (ext.pre==dir and ext.mod.rec==rec and
                        ext.out==(out or 'int') and TP.contains(ext.ins,ins))
            WRN(eq, me, 'event "'..id..'" is already declared')
            return
        end

        me.evt = {
            ln  = me.ln,
            id  = id,
            pre = dir,
            ins = ins,
            out = out or 'int',
            mod = { rec=rec },
            op  = (out and 'call' or 'emit'),
            seqno = true,
        }
        ENV.exts[#ENV.exts+1] = me.evt
        ENV.exts[id] = me.evt
    end,

    __dcl_var = function (me)
        local pre, tp, id, constr, isTmp = unpack(me)

        if id == '_' then
            id = id..me.n   -- avoids clash with other '_'
        end

        local has
        has, me.var = newvar(me, AST.par(me,'Block'), pre, tp, id, me.isImp, me.isEvery)
        assert(not has or (me.var.read_only==nil))

        me.var.read_only = me.read_only

        if constr then
            ASR(me.var.cls, me, 'invalid type')
            constr.blk = me.var.blk
        end

        if isTmp then
            me.var.isTmp = true
        end
    end,

    Dcl_var = function (me)
        local _, tp, id, constr, _ = unpack(me)
        F.__dcl_var(me)

        if me.var.cls and me.var.tp.arr then
            -- var T[10] ts;  // needs _i_ to iterate for the constructor
            _, me.var.constructor_iterator =
                newvar(me, AST.par(me,'Block'), 'var', TP.fromstr'int', '_i_'..id, false)
        end
    end,

    __Dcl_pool_pre = function (me)
        local pre, tp, id, constr = unpack(me)

        if ENV.adts[tp[1]] then
            -- ADT has the type of the pool values
            me[2] = AST.copy(tp)
            me[2][3] = false
        else
            -- CLS has no type
            me[2] = TP.fromstr'void'

            local tp_ = TP.new(tp)
            local top = (tp_.ptr==0 and (not tp_.ref))
            ASR(tp_.id=='_TOP_POOL' or top,
                me, 'undeclared type `'..(tp_.id or '?')..'´')
        end
    end,

    Dcl_pool = function (me)
        local pre, tp, id, constr = unpack(me)
        ASR(tp.arr, me, 'missing `pool´ dimension')
        F.__dcl_var(me)
    end,

    Dcl_int = function (me)
        local pre, tp, id = unpack(me)
        if id == '_' then
            id = id..me.n   -- avoids clash with other '_'
        end
        ASR(tp.id=='void' or TP.isNumeric(tp) or
            tp.ptr>0      or tp.tup,
                me, 'invalid event type')
        ASR(not tp.ref, me, 'invalid event type')
        if tp.tup then
            for _, t in ipairs(tp.tup) do
                ASR((TP.isNumeric(t) or t.ptr>0) and (not t.ref),
                    me, 'invalid event type')
            end
        end
        local _
        _, me.var = newint(me, AST.iter'Block'(), pre, tp, id, me.isImp)
    end,

    Dcl_fun = function (me)
        local pre, rec, ins, out, id, blk = unpack(me)
        local cls = CLS()

        -- implementation cannot be inside interface, so,
        -- if it appears on blk_body, make it be in blk_ifc
        local up = AST.iter'Block'()
        if blk and cls.blk_body==up and cls.blk_ifc.vars[id] then
            up = cls.blk_ifc
        end

        local _
        _, me.var = newfun(me, up, pre, rec, ins, out, id, me.isImp)

        -- "void" as parameter only if single
        if #ins > 1 then
            for _, v in ipairs(ins) do
                local _, tp, _ = unpack(v)
                ASR(tp ~= 'void', me, 'invalid declaration')
            end
        end

        if not blk then
            return
        end

        -- full definitions must contain parameter ids
        for _, v in ipairs(ins) do
            local _, tp, id = unpack(v)
            ASR(tp=='void' or id, me, 'missing parameter identifier')
        end
    end,

    Ext = function (me)
        local id = unpack(me)
        me.evt = ASR(ENV.exts[id], me,
                    'event "'..id..'" is not declared')
    end,

    Var_pre = function (me)
        local id = unpack(me)
        local blk = me.__ast_blk and assert(AST.par(me.__ast_blk,'Block'))
                        or AST.iter('Block')()
        local var = me.var or ENV.getvar(id, blk)

        -- ADT pools:
        --  tceu_pool_     _x;  // 'pool'
        --  tceu_adt_root  x;   // 'root'       (me)
        --  x.root              // 'root_root'  (return this)
        if var and var.adt_par and (not me.__env_set) then
error'oi'
            me.__env_set = true     -- avoid infinite recursion
            local root_root = AST.node('Op1_cast', me.ln,
                                TP.fromstr(var.adt_par.adt_tp.id..'*'),
                                AST.node('Op2_.', me.ln, '.',
                                    me,
                                    'root'))
            root_root.adt_par = var.adt_par
            root_root.adt_rr_to_root = me
            return root_root
        end

        -- OUT access in recurse loops
        --  var int x;
        --  loop v in <adt> do
        --      x = 1;
        --  end
        --      ... becomes ...
        --      this.out.x
        if not var then
            local cls = CLS()
            local out = cls.__adj_out
            if out then
                var = ENV.getvar(id, out)
                if var then
                    local ret = AST.node('Op2_.', me.ln, '.',
                                    AST.node('Var', me.ln, '_out'),
                                    id)
                    ret.blk_out = out   -- HACK_7
                    return ret
                end
            end
        end

    end,

    Var = function (me)
        local id = unpack(me)
        local blk = me.__ast_blk and assert(AST.par(me.__ast_blk,'Block'))
                        or AST.iter('Block')()
        local var = me.var or ENV.getvar(id, blk)

        ASR(var, me, 'variable/event "'..id..'" is not declared')
        me.var  = var
        me.tp   = var.tp
        me.lval = var.lval
    end,

    VarList = function (me)
        me.tp   = me
        me.lval = me
        me.tp.tup = TP.t2tup(me)
    end,
    ExpList = function (me)
        me.tp   = me
        me.lval = false
        me.tp.tup = TP.t2tup(me)
    end,

    Dcl_nat = function (me)
        local mod, tag, id, len = unpack(me)
        if tag=='type' or mod=='@plain' then
            local tp = TP.fromstr(id)
            tp.len   = len
            tp.plain = (mod=='@plain')
            TP.types[id] = tp
        end
        -- TODO: remove
        ENV.c[id] = { tag=tag, id=id, len=len, mod=mod }
    end,

    Dcl_pure = function (me)
        ENV.pures[me[1]] = true
    end,

    _TMP_ITER = function (me)
        -- HACK_5: figure out iter type
        local pool = AST.asr(me[1], 'Var')

        local blki = AST.asr(me.__par,'Stmts', 2,'Stmts', 1,'Dcl_cls',
                                    3,'Block', 1,'Stmts', 1,'BlockI')

        local tp = AST.asr(blki,'', 1,'Stmts', 3,'Dcl_pool', 2,'Type')
        tp[1] = pool.tp.id

        AST.asr(blki,'', 1,'Stmts', 1,'Dcl_pool', 2,'Type')
                [3] = AST.copy(pool.tp[3]) -- array
        AST.asr(me.__par,'Stmts', 3,'Dcl_pool', 2,'Type')
                [3] = AST.copy(pool.tp[3]) -- array

        me.tag = 'Nothing'
    end,

    _TMP_AWAIT = function (me)
        -- HACK_6 [await]: detects if OPT-1 (evt) or OPT-2 (adt) or OPT-3 (org)
        local stmts = AST.asr(me.__par, 'Stmts')
        local tp = me[1].tp  -- type of Var
        if tp and ENV.clss[tp.id] then
            ASR(ENV.v_or_ref(tp,'cls'), me, 'organism must not be a pointer')
            stmts[2] = AST.node('Nothing', me.ln)       -- remove OPT-1
            stmts[3] = AST.node('Nothing', me.ln)       -- remove OPT-2
            me.__env_watching = true    -- see props.lua
        elseif tp and ENV.adts[tp.id] then
            --ASR(tp.ptr==1, me, 'data must be a pointer')
            local dot = AST.asr(stmts,'', 3,'If', 1,'Op2_.')
            assert(dot[3] == 'HACK_6-NIL')
            dot[3] = ENV.adts[tp.id].tags[1]
            stmts[2] = AST.node('Nothing', me.ln)       -- remove OPT-1
            stmts[4] = AST.node('Nothing', me.ln)       -- remove OPT-3
            me.__env_watching = tp.id   -- see props.lua
            dot.__env_watching = true   -- see adt.lua
        else
            stmts[3] = AST.node('Nothing', me.ln)       -- remove OPT-2
            stmts[4] = AST.node('Nothing', me.ln)       -- remove OPT-3
        end

        --AST.asr(stmts,'', 1,'_TMP_AWAIT')
        --stmts[1] = AST.node('Nothing', me.ln)   -- remove myself
        me.tag = 'Nothing'
        --me[1] = nil
    end,

    Await = function (me)
        local e = unpack(me)
        if e.tag == 'Ext' then
            if e.evt.id == '_ok_killed' then
                me.awt_tp = 'org/adt'
            else
                me.awt_tp = 'evt'
            end

            if e.evt.ins.tup then
                me.tp = TP.fromstr('_'..TP.toc(e.evt.ins)..'*') -- convert to pointer
            else
                me.tp = e.evt.ins
            end
        else
            me.awt_tp = 'evt'
            ASR(e.var and e.var.pre=='event', me,
                'event "'..(e.var and e.var.id or '?')..'" is not declared')
            if e.var.evt.ins.tup then
                me.tp = TP.fromstr('_'..TP.toc(e.var.evt.ins)..'*') -- convert to pointer
            else
                me.tp = e.var.evt.ins
            end
        end
    end,

    EmitInt = function (me)
        local _, int, ps = unpack(me)
        local var = int.var
        ASR(var and var.pre=='event', me,
            'event "'..(var and var.id or '?')..'" is not declared')
        local ok, msg = TP.contains(var.evt.ins, ps)
        ASR(ok, me, msg)
    end,

    EmitExt = function (me)
        local op, e, ps = unpack(me)

        ASR(e.evt.op == op, me, 'invalid `'..op..'´')
        local ok, msg = TP.contains(e.evt.ins, ps)
        ASR(ok, me, msg)

        if op == 'call' then
            me.tp = e.evt.out       -- return value
        else
            me.tp = TP.fromstr'int' -- [0,1] enqueued? (or 'int' return val)
        end
    end,

    --------------------------------------------------------------------------

    Set = function (me)
        local _, set, fr, to = unpack(me)
        to = to or AST.iter'SetBlock'()[1]

        local fr_tp = fr.tp

        if set == 'await' then
            local e = unpack(fr)
            fr_tp = (e.var or e).evt.ins

        elseif set == 'thread' then
            fr_tp = TP.fromstr'int'       -- 0/1

        elseif set == 'spawn' then
            -- var T*? = spawn T;
            ASR(to.tp.opt, me, 'must assign to option pointer')

        elseif set == 'adt-constr' then
            return  -- checked in adt.lua

        elseif ENV.adts[to.tp.id] and (not to.tp.opt) then
            if ENV.adts[to.tp.id].is_rec then
                if to.var and (to.var.tp.ref or to.var.tp.ptr>0) then
                    me[2] = 'adt-alias'
                else
                    me[2] = 'adt-mut'
                end
                return  -- checked in adt.lua
            else
                -- non-recursive ADT: fallback to normal 'exp' attribution
                me[2] = 'exp'
            end
        end

        local lua_str = false
        if set == 'lua' then
            ASR(not to.tp.ref, me, 'invalid attribution')

            lua_str = (to.tp.id=='char' and to.tp.arr)
            if not lua_str then
                ASR(to and to.lval, me, 'invalid attribution')
            end

            ASR(TP.isNumeric(to.tp) or TP.tostr(to.tp)=='bool' or to.tp.ptr==1 or lua_str,
                me, 'invalid attribution')
            fr.tp = to.tp -- return type is not known at compile time
        else
            local ok, msg = TP.contains(to.tp,fr_tp)
            ASR(ok, me, msg)
        end

        if not lua_str then
            ASR(to and to.lval, me, 'invalid attribution')
            ASR(me.read_only or (not to.lval.read_only), me,
                'read-only variable')
        end

        ASR(not CLS().is_ifc, me, 'invalid attribution')
    end,

    Free = function (me)
        local exp = unpack(me)
        local id = ASR(exp.tp.ptr>0, me, 'invalid `free´')
        me.cls = ASR( ENV.clss[id], me,
                        'class "'..id..'" is not declared')
    end,

    -- _pre: gives error before "set" inside it
    Spawn_pre = function (me)
        local id, pool, constr = unpack(me)
        me.cls = ENV.clss[id]
        ASR(me.cls, me, 'undeclared type `'..id..'´')
        ASR(not me.cls.is_ifc, me, 'cannot instantiate an interface')
        me.tp = TP.fromstr(id..'*')  -- class id

        if me.cls == CLS() then
            -- Recursive class:
            --  Implies an "await" in the beginning for "across await" checks
            --  (see fin.lua).
            me.cls.is_rec = true
        end
    end,

    Dcl_constr_pre = function (me)
        local spw = AST.iter'Spawn'()
        local dcl = AST.iter'Dcl_var'()

        -- type check for this.* inside constructor
        if spw then
            me.cls = ENV.clss[ spw[1] ]   -- checked on Spawn
        elseif dcl then
            me.cls = ENV.clss[ dcl[2].id ]   -- checked on Dcl_var
        end
        --assert(me.cls)
    end,

    CallStmt = function (me)
        local call = unpack(me)
        ASR(call.tag == 'Op2_call', me, 'invalid statement')
    end,

    Loop_aft = function (me, sub, i)
        if i ~= 2 then
            return      -- declarations after "iter"
        end

        local max, iter, to, _ = unpack(me)
        local is_num = (iter and (not me.isEvery) and TP.isNumeric(iter.tp))
                        or (to and (not iter))

        if max or is_num then
            local id = (is_num and to[1]) or '_i_'..me.n
            me.i_dcl = AST.node('Dcl_var', me.ln, 'var',
                        AST.node('Type', me.ln, 'int', 0, false, false),
                        id)
            me.i_dcl.read_only = true
            me.i_var = (is_num and to) or AST.node('Var',me.ln,id)
            AST.visit(F, me.i_dcl)
            local stmts = me.__par[1]
            stmts[#stmts+1] = me.i_dcl
            if not is_num then
                AST.visit(F, me.i_var)
                stmts[#stmts+1] = me.i_var
            end
        end

        local cls = iter and iter.tp and ENV.clss[iter.tp.id]

        if is_num then
            me.iter_tp = 'number'
            -- done above

        elseif me.isEvery then
            me[3] = false   -- "to" is set on the "await"
            me.iter_tp = 'event'
            if to then
                local evt = (iter.var or iter).evt
                local tup = (evt and evt.ins.tup) or { iter.tp }
                to = (to.tag=='VarList' and to) or { to }
                for i, tp in ipairs(tup) do
                    local dcl = AST.node('Dcl_var', me.ln, 'var', AST.copy(tp), to[i][1])
                    dcl.isEvery = true  -- implicit declaration: cannot hide other variables
                    AST.visit(F, dcl)
                    local stmts = AST.asr(me.__par[1],'Stmts')
                    stmts[#stmts+1] = dcl
                end
            end

        elseif cls then
            me.iter_tp = 'org'
            if to then
                local stmts = me.__par[1]

                local dcl_cur = AST.node('Dcl_var', me.ln, 'var',
                                    AST.node('Type', me.ln, cls.id, 1, false, false),
                                    to[1])
                dcl_cur.read_only = true
                AST.visit(F, dcl_cur)
                stmts[#stmts+1] = dcl_cur

                local dcl_nxt = AST.node('Dcl_var', me.ln, 'var',
                                    AST.node('Type', me.ln, '_tceu_pool_iterator', 0, false, false),
                                    '__it_'..me.n)
                local var_nxt = AST.node('Var', me.ln, '__it_'..me.n)
                AST.visit(F, dcl_nxt)
                AST.visit(F, var_nxt)
                stmts[#stmts+1] = dcl_nxt
                stmts[#stmts+1] = var_nxt
                me.var_nxt = var_nxt
            end

        elseif iter and iter.tp.ptr>0 then
            me.iter_tp = 'data'
            if to then
                local dcl = AST.node('Dcl_var', me.ln, 'var',
                                AST.copy(iter.tp),
                                to[1])
                dcl.read_only = true
                AST.visit(F, dcl)
                local stmts = me.__par[1]
                stmts[#stmts+1] = dcl
            end
        end
    end,
--[[
    Recurse = function (me)
        local exp = unpack(me)
        local loop = AST.par(me, 'Loop')
        if loop then
            local _,iter = unpack(loop)
            ASR(TP.contains(iter.tp,exp.tp), me, 'invalid `recurse´')
        end
    end,
]]

    --------------------------------------------------------------------------

    Adt_constr_root = function (me)
        local _, one = unpack(me)
        me.tp   = one.tp
        me.lval = false
    end,
    Adt_constr_one = function (me)
        local adt, params = unpack(me)
        local id_adt, id_tag = unpack(adt)
        me.tp = TP.fromstr(id_adt)

        local tup
        local tadt = ASR(ENV.adts[id_adt], me,
                        'data "'..id_adt..'" is not declared')
        if id_tag then
            local ttag = ASR(tadt.tags[id_tag], me,
                            'tag "'..id_tag..'" is not declared')

            -- Refuse recursive constructors that are not new data:
            --  data D with
            --      <...>
            --  or
            --      tag REC with
            --          var D* rec;
            --      end
            --  end
            --  <...> = new D.REC(ptr)      -- NO!
            --  <...> = new D.REC(D.xxx)    -- OK!
            for i, p in ipairs(params) do
                if ttag.tup[i] and ttag.tup[i].is_rec then
                    ASR(p.tag == 'Adt_constr_one', me,
                        'invalid constructor : recursive field "'..id_tag..'" must be new data')
                    p.tp.ptr = 1
                end
            end
            tup = ttag.tup
        else
            tup = tadt.tup
        end

        local ok, msg = TP.contains(tup, params.tp)
        ASR(ok, me, msg)
    end,

    Op2_call = function (me)
        local _, f, params, _ = unpack(me)
        me.tp  = f.var and f.var.fun and f.var.fun.out or TP.fromstr'@'
        local id
        if f.tag == 'Nat' then
            id = f[1]
            me.c = ENV.c[id]
        elseif f.tag == 'Op2_.' then
            id = f.id
            if f.org then   -- t._f()
                me.c = assert(ENV.clss[f.org.tp.id]).c[f.id]
            else            -- _x._f()
                me.c = f.c
            end
        else
            id = (f.var and f.var.id) or '$anon'
            me.c = { tag='func', id=id, mod=nil }
        end

        ASR((not OPTS.c_calls) or OPTS.c_calls[id], me,
                'native calls are disabled')

        local ins = f.var and f.var.fun and f.var.fun.ins
        if ins then
            local ok, msg = TP.contains(ins, params)
            ASR(ok, me, msg)
        end

        if not me.c then
            me.c = { tag='func', id=id, mod=nil }
            ENV.c[id] = me.c
        end
        --ASR(me.c and me.c.tag=='func', me,
            --'native function "'..id..'" is not declared')

        ENV.calls[id] = true
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        ASR(arr.tp.arr or arr.tp.ptr>0 or arr.tp.ext, me,
            'cannot index a non array')
        ASR(TP.isNumeric(idx.tp), me, 'invalid array index')

        me.tp = TP.copy(arr.tp)
            if arr.tp.arr then
                me.tp.arr = false
            elseif arr.tp.ptr>0 then
                me.tp.ptr = me.tp.ptr - 1
            end

        if ENV.v_or_ref(me.tp) then
            me.lval = false
        else
            me.lval = arr
        end
    end,

    Op2_int_int = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = TP.fromstr'int'
        ASR(TP.isNumeric(e1.tp) and TP.isNumeric(e2.tp), me,
                'invalid operands to binary "'..op..'"')
    end,
    ['Op2_-']  = 'Op2_int_int',
    ['Op2_+']  = 'Op2_int_int',
    ['Op2_%']  = 'Op2_int_int',
    ['Op2_*']  = 'Op2_int_int',
    ['Op2_/']  = 'Op2_int_int',
    ['Op2_|']  = 'Op2_int_int',
    ['Op2_&']  = 'Op2_int_int',
    ['Op2_<<'] = 'Op2_int_int',
    ['Op2_>>'] = 'Op2_int_int',
    ['Op2_^']  = 'Op2_int_int',

    Op1_int = function (me)
        local op, e1 = unpack(me)
        me.tp  = TP.fromstr'int'
        ASR(TP.isNumeric(e1.tp), me,
                'invalid operand to unary "'..op..'"')
    end,
    ['Op1_~'] = 'Op1_int',
    ['Op1_-'] = 'Op1_int',
    ['Op1_+'] = 'Op1_int',

    ['Op1_?'] = function (me)
        local op, e1 = unpack(me)
        me.tp  = TP.fromstr'bool'
        ASR(e1.tp.opt, me, 'not an option type')
    end,

    Op2_same = function (me)
        local op, e1, e2 = unpack(me)
        me.tp  = TP.fromstr'int'
        ASR(TP.max(e1.tp,e2.tp), me,
            'invalid operands to binary "'..op..'"')

        if not (e1.tp.opt and e1.tp.ptr>0) then
            ASR(not ENV.adts[TP.tostr(e1.tp)], me, 'invalid operation for data')
        end
        if not (e2.tp.opt and e2.tp.ptr>0) then
            ASR(not ENV.adts[TP.tostr(e2.tp)], me, 'invalid operation for data')
        end
    end,
    ['Op2_=='] = 'Op2_same',
    ['Op2_!='] = 'Op2_same',
    ['Op2_>='] = 'Op2_same',
    ['Op2_<='] = 'Op2_same',
    ['Op2_>']  = 'Op2_same',
    ['Op2_<']  = 'Op2_same',

    Op2_any = function (me)
        me.tp = TP.fromstr'int'
        ASR(not ENV.adts[TP.tostr(me.tp)], me, 'invalid operation for data')
    end,
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',
    ['Op1_not'] = 'Op2_any',

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        me.lval = e1.lval and e1
        me.tp = TP.copy(e1.tp)

        local ok = false

        if me.tp.ptr > 0 then
            me.tp.ptr = me.tp.ptr - 1
            ok = true
        end

        local is_adt_pool = ENV.adts[me.tp.id] and e1.var and e1.var.pre=='pool'
        if is_adt_pool then
            me.tp.arr = false
            ok = true
        end

        if not ok then
            ASR((me.tp.ext and (not me.tp.plain) and (not TP.get(me.tp.id).plain)),
                me, 'invalid operand to unary "*"')
        end
    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        ASR(e1.lval or ENV.clss[e1.tp.id] or ENV.adts[e1.tp.id], me,
            'invalid operand to unary "&"')
        me.lval = false
        me.tp   = TP.copy(e1.tp)
        me.tp.ptr = me.tp.ptr + 1
        me.tp[2] = me.tp.ptr
    end,

    ['Op2_._pos'] = function (me)
        local op, e1, id = unpack(me)
        local top = ENV.v_or_ref(e1.tp)
        local cls = top and (top.tag=='Dcl_cls') and top
        if cls and me.var then
            -- mimic process in "Var_pre" for ADT pools
            if me.var.adt_par then
error'oi'
                assert(me.tag == 'Field')
                local root_root = AST.node('Op1_cast', me.ln,
                                    TP.fromstr(me.var.adt_par.adt_tp.id..'*'),
                                    AST.node('Op2_.', me.ln, '.',
                                        me,
                                        'root'))
                root_root.adt_par = me.var.adt_par
                root_root.adt_rr_to_root = me
                return root_root
            end
        end
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)

        local cls = ENV.v_or_ref(e1.tp, 'cls')
        local adt = ENV.v_or_ref(e1.tp, 'adt')
        local BLK, VAR
        me.id = id
        if cls then
            me.org = e1
            me.org.cls = cls

            if e1.tag == 'This' then
                -- accept private "body" vars
                BLK = cls.blk_body
                VAR = BLK.vars[id]
                    --[[
                    -- class T with
                    -- do
                    --     var int a;
                    --     this.a = 1;
                    -- end
                    --]]
            end
            if not VAR then
                BLK = me.blk_out or cls.blk_ifc
                      -- HACK_7
                VAR = ASR(ENV.getvar(id,BLK), me,
                        'variable/event "'..id..'" is not declared')
            end

            -- Op2_. => Field
            me.tag = 'Field'
            me.var  = VAR
            me.tp   = VAR.tp
            me.lval = VAR.lval

        elseif adt then
            local ID, op, blk = unpack(adt)

            if op == 'struct' then
                local var = ASR(blk.vars[id], me,
                            'field "'..id..'" is not declared')
                me.tp = var.tp
                me.lval = var
                --BLK, VAR = blk, var
                -- TODO
            else
                assert(op == 'union')
                local blk = ASR(adt.tags[id] and adt.tags[id].blk, me,
                                'tag "'..id..'" is not declared')

                ASR(TP.contains(e1.tp,TP.fromstr(ID)), me,
                    'invalid access ('..TP.tostr(e1.tp)..' vs '..ID..')')

                -- [union.TAG]
                local tag = (me.__par.tag ~= 'Op2_.')
                if tag then
                    me.tp = TP.fromstr'bool'
                    me.__env_tag = 'test'

                -- [union.TAG].field
                else
                    me.__env_tag = 'assert'
                    me.union_tag_blk = blk
                    me.tp = blk
                end
            end

                -- [union.TAG.field]
        elseif e1.union_tag_blk then
            local var = ASR(e1.union_tag_blk.vars[id], me,
                        'field "'..id..'" is not declared')
            me.__env_tag = 'field'
            me.tp = var.tp
            me.lval = var
            --BLK, VAR = e1.union_tag_blk, var
            -- TODO

        else
            assert(not e1.tp.tup)
            ASR(e1.tp.ext, me, 'not a struct')
            -- rect.x = 1 (_SDL_Rect)
            me.tp = TP.fromstr'@'
            local tp = TP.get(e1.tp.id)
            if tp.plain and e1.tp.ptr==0 then
                me.tp.plain = true
                me.tp.ptr   = 0
            end
            me.lval = me--e1.lval
        end

        if VAR then
            local node = AST.node('Var', me.ln, '$'..id)
            node.var = VAR
            node.tp  = VAR.tp
            node.__ast_blk = BLK[1]
            me[3] = node
        end
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        me.tp   = tp
        me.lval = exp.lval
        if tp.ptr > 0 then
            me.lval = exp      -- *((u32*)0x100)=v
        end
    end,

    Nat = function (me)
        local id = unpack(me)
        local c = ENV.c[id] or {}
        ASR(c.tag~='type', me,
            'native variable/function "'..id..'" is not declared')
        me.id   = id
        me.tp   = TP.fromstr'@'
        me.lval = me
        me.c    = c
    end,
    RawExp = function (me)
        me.tp   = TP.fromstr'@'
        me.lval = me
    end,

    WCLOCKK = function (me)
        me.tp   = TP.fromstr'int'
        me.lval = false
    end,
    WCLOCKE = 'WCLOCKK',

    SIZEOF = function (me)
        me.tp   = TP.fromstr'int'
        me.lval = false
        me.const = true
    end,

    STRING = function (me)
        me.tp   = TP.fromstr'char*'
        me.lval = false
        me.const = true
    end,
    NUMBER = function (me)
        local v = unpack(me)
        ASR(string.sub(v,1,1)=="'" or tonumber(v), me, 'malformed number')
        if string.find(v,'%.') or string.find(v,'e') or string.find(v,'E') then
            me.tp = TP.fromstr'float'
        else
            me.tp = TP.fromstr'int'
        end
        me.lval = false
        me.const = true
    end,
    NULL = function (me)
        me.tp   = TP.fromstr'null*'
        me.lval = false
        me.const = true
    end,
}

AST.visit(F)

end

    
do
F = {
    Set = function (me)
        local _, set, fr, to = unpack(me)
        if set == 'spawn' then
            -- a = spawn T
            fr.blk = to.lst.var.blk   -- to = me.__par[3]

            -- refuses (x.ptr = spawn T;)
            ASR( AST.isParent(CLS(),to.lst.var.blk), me,
                    'invalid attribution (no scope)' )
        end
    end,

    Spawn = function (me)
        local _,pool,_ = unpack(me)
        ASR(pool and pool.lst and pool.lst.var and pool.lst.var.pre=='pool',
            me, 'invalid pool')
    end,
    Loop = function (me)
        local _, iter, _, _ = unpack(me)
        local cls = iter and iter.tp and ENV.clss[iter.tp.id]
        if cls then
            ASR(iter.lst and iter.lst.var and iter.lst.var.pre=='pool',
                me, 'invalid pool')
        end
    end,

-- EXPS --

    Node = function (me)
        me.fst = me.fst or me
        me.lst = me.lst or me
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        me.fst = arr.fst
        me.lst = arr.lst
    end,

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        me.fst = e1.fst
        me.lst = e1.lst
    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        me.fst = e1.fst
        me.lst = e1.lst
        me.lst.amp = true
    end,

    Field = function (me)
        local op, e1, var = unpack(me)
        me.fst = e1.fst
        me.lst = var    -- org.var => var
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)
        me.fst = e1.fst
--[[
        me.lst = (AST.isNode(id) and id) or e1.lst
                    -- org.field            _struct.field
                                        -- TODO: should be nil
]]
        me.lst = e1.lst
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        me.fst = exp.fst
        me.lst = exp.lst
        me.isConst = exp.isConst
    end,

    NUMBER = function (me)
        me.isConst = true
    end,
    STRING = 'NUMBER',
    NULL   = 'NUMBER',
}

AST.visit(F)

end

    
do
F = {
    Dcl_adt = function (me)
        local id, op = unpack(me)

        -- For recursive ADTs, ensure valid base case:
        --  - it is the first in the enum
        --  - it has no parameters
        if op == 'union' then
            local base = me.tags[me.tags[1]].tup
            for _, tag in ipairs(me.tags) do
                local tup = me.tags[tag].tup
                AST.asr(tup, 'TupleType')
                for _, item in ipairs(tup) do
                    AST.asr(item, 'TupleTypeItem')
                end
            end
            if me.is_rec then
                ASR(#base == 0, base,
                    'invalid recursive base case : no parameters allowed')
            end
        end
    end,

    Dcl_var = function (me)
        local adt = ENV.adts[me.var.tp.id]
        if adt and adt.is_rec then
            if me.var.pre == 'var' then
                -- Pointer to recursive ADT pool declaration:
                --      var List* l;
                --  becomes
                --      var tceu_adt_root l = {pool=x, root=y}
                ASR(me.var.tp.ptr==1, me,
                    'invalid recursive data declaration : variable "'..me.var.id..'" must be a pointer or pool')
            end
        end
    end,

    Adt_constr_root = function (me)
        local dyn, one  = unpack(me)
        local adt, _    = unpack(one)
        local id_adt, _ = unpack(adt)
        if ENV.adts[id_adt].is_rec then
            ASR(dyn, me,
                'invalid constructor : recursive data must use `new´')
        end
    end,

    Set = function (me)
        local _, set, fr, to = unpack(me)
    
        if not (set=='adt-constr' or set=='adt-mut') then
            return      -- handled in env.lua
        end

        local adt = ENV.adts[to.tp.id]
        if not (adt and adt.is_rec) then
            return  -- ignore non-adt or non-recursive-adt
        end

        if set == 'adt-constr' then
            if to.fst.var.pre == 'pool' then
                -- [OK]
                -- var pool[] L l;
                -- l = new (...)
                return
            elseif to.fst ~= to then
                -- [OK]
                -- var L* l = <...>;
                -- l:X.x = new (...)
                return
            else
                -- [NO]
                -- var L* l = <...>;
                -- l = new (...)
                ASR(false, me, 'invalid attribution : must assign to recursive field')
            end

        elseif set == 'adt-alias' then

        else -- set == 'adt-mut'
            -- [OK]: ptr  = l2.*
            -- [OK]: l1.* = l1.*
            -- [NO]: l1.* = l2.*
            ASR((to.tp.ptr==1 and to.lst.var==to.var) or
                 to.fst.var==fr.fst.var, me,
                'cannot mix recursive data sources')

            --  [OK]: "to" is prefix of "fr" (changing parent to a child)
            --      l = l:CONS.tail     // OK
            --      l:CONS.tail = l     // NO
            local prefix = (to.fst.__depth-to.__depth <= fr.fst.__depth-fr.__depth)
            ASR(prefix, me, 'cannot assign parent to child')
        end
    end,

    ['Op2_.'] = function (me)
        local op, e1, id = unpack(me)

        local adt = ENV.v_or_ref(e1.tp, 'adt')
        if adt then
            local ID, op, _ = unpack(adt)

            if op == 'union' then
                -- [union.TAG]
                local tag = (me.__par.tag ~= 'Op2_.')
                if tag then
                    if id==adt.tags[1] and (not me.__env_watching) then
                        for paror in AST.iter('ParOr') do
                            local var = paror.__adj_watching and
                                        paror.__adj_watching.lst and
                                        paror.__adj_watching.lst.var
                            if var and var==e1.lst.var then
                                local dot = e1.lst.__par.__par
                                if dot.tag=='Op2_.' and dot[3]==id then
                                    ASR(false, me,
                                        'ineffective use of tag "'..id..
                                        '" due to enclosing `watching´ ('..
                                        paror.ln[1]..' : '..paror.ln[2]..')')
                                end
                            end
                        end
                    end
                end
            end
        end
    end,
}

AST.visit(F)

end

    
do
function NODE2BLK (n)
    return n.fst and n.fst.blk or
           n.fst and n.fst.var and n.fst.var.blk or
           MAIN.blk_ifc
end

F = {
    -- before Var
    Set_pre = function (me)
        local _, _, _, to = unpack(me)
        local TO = (to.tag=='VarList' and to) or {to}
        for _, to in ipairs(TO) do
            F.__Set_pre(me, to)
        end
    end,
    __Set_pre = function (me, TO)
        local _, set, fr, _ = unpack(me)
        to = TO
        if not to.tp.ref then
            return
        end
        assert(to.lst.var, 'bug found')
        local cls = CLS()

        -- Detect source of assignment/binding:
        --  - internal:  assignment from body to normal variable (v, this.v)
        --  - constr:    assignment from constructor to interface variable (this.v)
        --  - interface: assignment from interface (var int v = <default value>)
        --  - outer:     assignment from outer body (t.v)

        local constr    = AST.par(me, 'Dcl_constr')
              constr    = constr and (constr.cls.blk_ifc.vars[to.lst.var.id]==to.lst.var) and constr
        local global    = to.tag=='Field' and to.org.cls.id=='Global' and cls.id=='Main'
        local outer     = (not constr) and to.tag=='Field' and to.org.cls~=cls and (not global)
        local interface = AST.par(me, 'BlockI')
        local internal  = not (constr or outer or interface)

        -- IGNORE NON-FIRST ASSIGNMENTS
        --  class T with
        --      var int& ref;
        --  do
        --      this.ref = <...>;   // this is not a first assignment
        --  end
        if (not constr) and to.lst.var.blk==cls.blk_ifc and (cls.id~='Main') then
            return
        end

        -- refuse first assignment inside loop with declaration outside it:
        --      var t& v;
        --      loop do
        --          v = <...>;      // rebindings are forbidden
        --          <...>
        --      end
        -- accept if inside a constructor:
        --      loop do
        --          var T with
        --              this.v = <...>;
        --          end;
        --      end
        local loop = AST.par(me, 'Loop')
        if loop then
            if (not to.lst.var.bind) and (not AST.par(me,'Dcl_constr')) then
                ASR(AST.isParent(loop, to.lst.var.blk), me,
                    'reference declaration and first binding cannot be separated by loops')
            end
        end

        -- ALREADY HAS INTERNAL BINDING

        if to.lst.var.bind=='internal' then
            assert(cls.id=='Main' or (to.blk ~= cls.blk_ifc))

        -- NO INTERNAL BINDING
        --  first assignment

        else
            local if_ = AST.par(me,'If')
            if if_ and (if_.__depth > to.lst.var.blk.__depth) and
               ((not constr) or if_.__depth > constr.__depth) and
               ((not to.lst.var.bind) or to.lst.var.bind=='partial')
            then else
                if_ = false
            end
            if if_ and AST.isParent(if_[2],me) then
                -- do not bind yet if inside a true branch of an if,
                -- force the else part to also set byRef
                to.lst.var.bind = 'partial'

            -- set source of binding
            elseif internal then
                to.lst.var.bind = 'internal'
                assert(cls.id=='Main' or (to.blk ~= cls.blk_ifc))
            elseif constr then
                if not to.lst.var.bind then
                    to.lst.var.bind = 'constr'
                end
                -- mark this field assigned inside this constructor
                -- later (Dcl_constr), we check if all unbounded fields have being assigned
                constr.__bounded = constr.__bounded or {}
                constr.__bounded[to.lst.var] = true
            elseif interface then
                to.lst.var.bind = 'interface'
            end

            -- save binds from if/else, check after
            if if_ then
                local T = if_.__ref_bounded or {}
                if_.__ref_bounded = T
                local t = T[to.lst.var] or {}
                T[to.lst.var] = t
                t[#t+1] = me
            end

            -- first assignment (and only first assignment) is "by ref"
            me.__ref_byref = true

            -- refuses first assignment from constants and dereferences:
            -- var int& i = 1;      // constant
            -- var int& i = *p;     // dereference
            -- var D& d = D(...);   // adt-constr
            if (not fr.tp.ref) then
                ASR(fr.lval or fr.tag=='Op1_&' or fr.tag=='Op2_call' or
                        (fr.lst and (fr.lst.tag=='Outer' or
                                     fr.lst.var and (fr.lst.var.cls or fr.lst.var.adt))),
                                               -- orgs/adts are not lval
                    me, 'invalid attribution (not a reference)')
-- TODO: err msg, separate with : inteado of (
                ASR(fr.tag ~= 'Op1_*', me, 'invalid attribution')
            end

            -- refuses first assignment from awaits:
            -- var int& i = await <...>;
            ASR(set~='await', me, 'invalid attribution')

            -- check scopes
-- TODO: this code is duplicated with "fin.lua"
            local fr_blk = NODE2BLK(fr)
            local to_blk = NODE2BLK(to)
            local org_blk
            if to.tag=='Field' and to[2].tag=='This' then
                local constr = AST.par(me, 'Dcl_constr')
                if constr then
                    local dcl = AST.par(constr, 'Dcl_var')
                    if dcl then
                        org_blk = dcl.var.blk
                    else
                        local spw = AST.par(constr, 'Spawn')
                        org_blk = spw[2].var.blk or MAIN.blk_body    -- pool.blk
                    end
                end
            end
            if not (
                fr.fst.tag == 'Nat'        or -- natives are globals
                (fr.tag=='Op2_call' and       -- native calls are globals
                 fr[2].fst.tag=='Nat')     or
                (fr.org and                   -- "global:*" is global
                 fr.org.cls.id=='Global')  or
                fr_blk == MAIN.blk_body    or
                (org_blk and
                 org_blk.__depth>=fr_blk.__depth) or
                (   -- same class and scope of "to" <= "fr"
                    (AST.par(to_blk,'Dcl_cls') == AST.par(fr_blk,'Dcl_cls')) and
                        (   to_blk.__depth >= fr_blk.__depth            -- to <= fr
                        or (to_blk.__depth==cls.blk_ifc.__depth and     --    or
                            fr_blk.__depth==cls.blk_body.__depth)       -- ifc/bdy
                        )
                )
            ) then
                ASR(false, me, 'attribution to reference with greater scope')
                    -- NO:
                    -- var int& r;
                    -- do
                    --     var int v;
                    --     r = v;
                    -- end
            end
        end
    end,

    If = function (me)
        -- prepare to pass to parent
        local if_ = AST.par(me,'If')
        local T2
        if if_ then
            T2 = if_.__ref_bounded or {}
            if_.__ref_bounded = T2
        end

        local T1 = me.__ref_bounded or {}
        for var,t in pairs(T1) do
            ASR(#t==2, t[1], 'reference must be bounded in the other if-else branch')

            -- pass to parent
            if if_ then
                T2[var] = t
            end
        end
    end,

    -- Constructors (static/dynamic):
    -- If a ref field (class.field&) is not bounded internally,
    --  it must be bounded in all constructors.
    -- Checks if all class.field& are bounded or assigned here.
    __constr = function (me, cls, constr)
        constr.__bounded = constr.__bounded or {}
        for _, var in ipairs(cls.blk_ifc.vars) do
            if var.tp.ref and (not var.tp.opt)
                          and (var.bind=='constr' or (not var.bind))
            then
                ASR(constr.__bounded[var], me,
                    'field "'..var.id..'" must be assigned')
            end
        end
    end,
    Dcl_var = function (me)
        if me.var.cls and me.var.tp.ptr==0 then
            local _,_,_,constr = unpack(me)
            F.__constr(me, me.var.cls, constr or {})
        end

        -- ensures that global "ref" vars are initialized
        local glb = ENV.clss.Global
        local cls = CLS()   -- might be an ADT declaration
        if me.var.tp.ref and glb and cls and cls.id=='Main' then
            local var = glb.blk_ifc.vars[me.var.id]
            if var then
                local set = me.__par and me.__par[1]==me and
                            me.__par[2] and me.__par[2].tag=='Set'
                ASR(set, me,
                    'global references must be bounded on declaration')
            end
        end
    end,
    Spawn = function (me)
        local _,_,constr = unpack(me)
        F.__constr(me, me.cls, constr or {})
    end,

    -- Ensures that &ref var is bound before use.
    Var = function (me)
        local cls = CLS()
        if me.var.tp.ref and (not me.var.tp.opt) then
            -- ignore interface variables outside Main
            -- (they are guaranteed to be bounded)
            local inifc = (me.var.blk == cls.blk_ifc)
            inifc = inifc and cls.id~='Main'

            -- ignore global variables
            -- (they are guaranteed to be bounded)
            local glb = ENV.clss.Global
            if glb then
                if cls.id == 'Main' then
                    -- id = <...>   // id is a global accessed in Main
                    glb = glb.blk_ifc.vars[me.var.id]
                else
                    local fld = me.__par
                    if fld and fld.tag=='Field' and fld.org then
                        -- global:id = <...>
                        glb = fld.org.cls==glb
                    end
                end
            end

            -- ignore field accesses:
            --      x.ref.v
            -- (they are guaranteed to be bounded)
            local fld = (me.__par.tag=='Field' and me.__par[3]==me)

            if not (inifc or glb or fld) then
                ASR(me.var.bind, me, 'reference must be bounded before use')
            end
        end
    end,
}

AST.visit(F)

end

    
do
local _ceu2c = { ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

--[[
-- Fills nodes with "sval" and "cval".
-- sval: static value
-- cval: C value
--]]

SVAL = {
    t2n = {
         us = 10^0,
         ms = 10^3,
          s = 10^6,
        min = 60*10^6,
          h = 60*60*10^6,
    },
}

F =
{
    Dcl_var = function (me)
        if me.var.cls then
            if me.var.tp.arr then
                ASR(me.var.tp.arr.sval, me, 'invalid static expression')
            end
        end
        if me.var.pre=='var' and me.var.tp.arr then
            ASR(type(me.var.tp.arr)=='table' and me.var.tp.arr.cval,
                me, 'invalid array dimension')
        end
    end,

    Op2_call = function (me)
        local _, f, ins = unpack(me)
        if not f.cval then
            return
        end
        local ps = {}
        for i, exp in ipairs(ins) do
            if not exp.cval then
                return
            end
            ps[i] = exp.cval
        end
        me.cval = f.cval..'('..table.concat(ps,',')..')'
    end,

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        if e1.cval and e2.cval then
            me.cval = '('..e1.cval..ceu2c(op)..e2.cval..')'
        end

        if e1.sval and e2.sval then
            local v = loadstring('return '..e1.sval..op..e2.sval)
            me.sval = v and tonumber(v())
        end
    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        if e1.cval then
            me.cval = '('..ceu2c(op)..e1.cval..')'
        end
        if e1.sval then
            local v = loadstring(op..e1.sval)
            me.sval = v and tonumber(v())
        end
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_+']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        if exp.cval then
            me.cval = '(('..TP.toc(tp)..')'..exp.cval..')'
        end
    end,

    RawExp = function (me)
        me.cval = unpack(me)
    end,

    WCLOCKK = function (me)
        local h,min,s,ms,us, tm = unpack(me)
        me.us = us*SVAL.t2n.us + ms*SVAL.t2n.ms   + s*SVAL.t2n.s
                               + min*SVAL.t2n.min + h*SVAL.t2n.h
        me.tm = tm
        ASR(me.us>0 and me.us<=2000000000, me, 'constant is out of range')
    end,
    WCLOCKE = function (me)
        local exp, unit, tm = unpack(me)
        me.us = nil
        me.tm = tm
    end,

    Nat = function (me)
        me.cval = string.sub(me[1], 2)
    end,
    STRING = function (me)
        me.cval = me[1]
    end,
    NUMBER = function (me)
        me.cval = me[1]
        me.sval = tonumber(me[1])
    end,
    NULL = function (me)
        me.cval = '((void *)0)'
        me.sval = '((void *)0)'
    end,
}

AST.visit(F)

end

    
do
--[[
-- If an ISR acesses a symbol (Var/Nat), then all accesses outside it must be
-- atomic.
-- In the first pass "F", we mark all symbols accessed in ISRs.
-- In the second pass "G", we check if all accesses are protected.
--
-- If an ISR accesses a pointer or makes a call, we warn that this breaks the
-- analysis.
-- If outside gets a reference to a symbol used in an ISR, we warn that this
-- breaks the analysis.
--]]

local accs = {}

local function inIsr (me)
    local fun = AST.par(me, 'Dcl_fun')
    return fun and fun.var.pre=='isr'
end

local msg = 'breaks the static check for `atomic´ sections'

F = {
    Var = function (me)
        if inIsr(me) then
            accs[me.var] = true
            local isPtr = me.var.tp.ptr>0 and (not me.var.tp.arr)
            WRN(not isPtr, me, 'pointer access '..msg)
        end
    end,
    Nat = function (me)
        if inIsr(me) and (me.c.mod~='@pure') then
            accs[me.id] = true
        end
    end,
    Op2_call = function (me)
        if inIsr(me) then
            WRN((me.c and me.c.mod=='@pure'), me,
                'call '..msg)
        end
    end,
}

G = {
    Var = function (me)
        if inIsr(me) or AST.par(me,'Dcl_var') then
            return  -- ignore isrs and var declarations
        end
        if accs[me.var] then
            ASR( AST.par(me,'Atomic'), me,
                    'access to "'..me.var.id..'" must be atomic' )
        end
    end,
    Nat = function (me)
        if inIsr(me) or AST.par(me,'Native') then
            return  -- ignore isrs and native declarations
        end
        if accs[me.id] then
            ASR( AST.par(me,'Atomic'), me,
                    'access to "'..me.id..'" must be atomic' )
        end
    end,
    ['Op1_&'] = function (me)
        if accs[me.lst.var] then
            WRN(false, me, 'reference access '..msg)
        end
    end,
}

AST.visit(F)
AST.visit(G)

end

    
do
TIGHT = false

function OR_all (me, t)
    t = t or me
    me.tl_awaits  = false
    me.tl_escapes = false
    me.tl_blocks  = false
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            me.tl_awaits  = me.tl_awaits  or sub.tl_awaits
            me.tl_escapes = me.tl_escapes or sub.tl_escapes
            me.tl_blocks  = me.tl_blocks  or sub.tl_blocks
        end
    end
end

function AND_all (me, t)
    t = t or me
    me.tl_awaits  = true
    me.tl_escapes = true
    me.tl_blocks  = true
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            me.tl_awaits  = me.tl_awaits  and sub.tl_awaits
            me.tl_escapes = me.tl_escapes and sub.tl_escapes
            me.tl_blocks  = me.tl_blocks  and sub.tl_blocks
        end
    end
end

function SAME (me, sub)
    me.tl_awaits  = sub.tl_awaits
    me.tl_escapes = sub.tl_escapes
    me.tl_blocks  = sub.tl_blocks
end

F = {
    Node_pre = function (me)
        me.tl_awaits  = false
        me.tl_escapes = false
        me.tl_blocks  = false
    end,
    Node = function (me)
        if not F[me.tag] then
            OR_all(me)
        end
    end,

    Stmts   = OR_all,

    ParEver = OR_all,
    ParAnd  = OR_all,
    ParOr   = AND_all,

    If = function (me)
        local c, t, f = unpack(me)
        AND_all(me, {t,f})
    end,

    Break = function (me)
        me.tl_blocks = true
    end,

    Loop = function (me)
        local max,iter,_,body = unpack(me)
        if max then
            ASR(max.cval, me, '`loop´ bound must be constant')
        end

        me.is_bounded = max or (iter and (iter.cval or
                                          iter.tp and (
                                            ENV.clss[iter.tp.id] or
                                            ENV.adts[iter.tp.id])))

        SAME(me, body)
        local isTight = (not AST.iter(AST.pred_async)())
                            and (not body.tl_blocks)
                            and (not me.is_bounded)
        WRN(not isTight, me, 'tight loop')
        TIGHT = TIGHT or isTight
        me.tl_blocks = me.is_bounded or (body.tl_awaits or body.tl_escapes)

        local dcl = AST.iter'Dcl_fun'()
        if dcl and isTight then
            dcl.var.fun.isTight = true
        end
    end,

    SetBlock = function (me)
        local blk,_ = unpack(me)
        SAME(me, blk)
        me.tl_escapes = false
    end,
    Escape = function (me)
        me.tl_escapes = true
        me.tl_blocks  = true
    end,

    Thread = 'Async',
    Async = function (me)
        local _,body = unpack(me)
        SAME(me, body)
        me.tl_awaits = true
        me.tl_blocks = true
    end,

    Await = function (me)
        me.tl_awaits = true
        me.tl_blocks = true
    end,
    AwaitN = 'Await',

    Op2_call = function (me)
        local op, f, _ = unpack(me)

        if not (f.var and f.var.fun) then
            return  -- ignore native and pointer calls
        end

        -- if calling a tight (or unknown) function,
        --  then the top function is also tight
        local dcl = AST.iter'Dcl_fun'()
        if dcl and (f.var.fun.isTight or f.var.fun.isTight==nil) then
            dcl.var.fun.isTight = true
            ASR(dcl.var.fun.mod.rec == true,
                dcl, 'function must be declared with `recursive´')
        end

        -- assert that the call is using call/rec correctly
        if f.var.fun.mod.rec then
            ASR(op=='call/rec',
                me, '`call/rec´ is required for "'..f.var.fun.id..'"')
        else
            ASR(op=='call',
                me, '`call/rec´ is not required for "'..f.var.fun.id..'"')
        end
    end,
    Dcl_fun = function (me)
        local _, rec, _, _, id, blk = unpack(me)
        if not blk then
            return          -- pure declarations
        end

        -- if I'm not discovered as tight, then I'm not tight
        if me.var.fun.isTight == nil then
            me.var.fun.isTight = false
        end
        if me.var.fun.isTight then
            ASR(me.var.fun.mod.rec == me.var.fun.isTight,
                me, 'function must be declared with `recursive´')
        else
            WRN(me.var.fun.mod.rec == me.var.fun.isTight,
                me, 'function may be declared without `recursive´')
        end

        -- copy isTight to all matching interfaces with method "id"
        local matches = CLS().matches or {}
        for ifc in pairs(matches) do
            local var = ifc.blk_ifc.vars[id]
            if var then
                assert(var.fun)
                local t = var.fun.__tights or {}
                var.fun.__tights = t
                t[#t+1] = me.var.fun.isTight
            end
        end
    end,

    Root = function (me)
        -- check if all interface methods have "mod.rec"
        -- respecting their implementations
        for _, ifc in pairs(ENV.clss_ifc) do
            for _,var in ipairs(ifc.blk_ifc.vars) do
                if var.fun then
                    local t = var.fun.__tights or {}

                    -- If "rec", at least one implementation should
                    -- not be isTight.
                    if var.fun.mod.rec then
                        local ok = false
                        for _, isTight in ipairs(t) do
                            if isTight then
                                ok = true
                                break
                            end
                        end
                        WRN(ok, var.ln,
                            'function may be declared without `recursive´')

                    -- If not "rec", all implementations should be
                    -- isTight.
                    else
                        for _, isTight in ipairs(t) do
                            ASR((not isTight), var.ln,
                                'function must be declared with `recursive´')
                        end
                    end
                end
            end
        end
    end,
}

AST.visit(F)

end

    
do
-- Track all declared pointers to assert that they are not accessed across
-- await statements:
local TRACK = {
    --[var] = true,   -- tracking but no await yet
    --[var] = await,  -- an "await" happened while tracking "var"
                      --   now, any access to "var" yields error
}

local function GET ()
    return TRACK[#TRACK]
end

local function JOIN (me)
    local TOP = GET()
    for T in pairs(me.__tojoin) do
        for k,v in pairs(T) do
            -- awaits have higher priority to catch more errors
            if type(TOP[k]) ~= 'table' then
                TOP[k] = v
            end
        end
    end
end


local function PUSH (me)
    local old = TRACK[#TRACK]
    local new = setmetatable({}, {__index=old})
    TRACK[#TRACK+1] = new
    if me then
        me.__tojoin[new] = true
    end
end
local function POP ()
    TRACK[#TRACK] = nil
end

function NOPTR (node_or_var)
    if node_or_var.tag == 'Adt_constr_root' then
        return false
    end

    local tp = node_or_var.tp
    return (tp.ptr==0 and
           ((not tp.ext) or TP.get(tp.id).plain or tp.plain or tp.ref))
                -- either native dcl or derived
end

F = {
    Dcl_cls_pre = function (me)
        PUSH()
        if me.is_rec then
            me.GET = GET()
            setmetatable(me.GET, {__index=function() return me end})
        end
    end,
    Dcl_cls_pos = function (me)
        POP()
    end,

    Set = function (me)
        local op, set, fr, to = unpack(me)
        to = to or AST.iter'SetBlock'()[1]

-- TODO
if set == 'await' then
    ASR(op == '=', me, 1103, 'wrong operator')
    return
end

        local cls = CLS()

    --
    -- NON-POINTER ATTRIBUTIONS (always safe)
    --

        -- _r.x = (int) ...;
        if NOPTR(to) and (not to.tp.ref) and (not to.tp.arr) or
           NOPTR(fr) and (not fr.tp.ref) and (not fr.tp.arr) then
            ASR(op == '=', me, 1101, 'wrong operator')
            ASR(not me.fin, me, 1102, 'attribution does not require `finalize´')
            return
        end

    --
    -- POINTER ATTRIBUTIONS
    --

        -- an attribution restarts tracking accesses to "to"
        -- variables or native symbols
        if (to.var and (not to.var.tp.ref)) or to.c then
                        -- do not track references
            GET()[to.var or to.id] = 'accessed'
        end

        -- constants are safe
        if fr.sval then
            ASR(op == '=', me, 1103, 'wrong operator')
            ASR(not me.fin, me, 1104, 'attribution does not require `finalize´')
            return
        end

    -- NON-CONSTANT ATTRIBUTIONS

        -- determine "to_blk": block/scope for "to"
        local to_blk
        local constr = AST.iter'Dcl_constr'()
        if constr then
            -- var T t with
            --  this.x = y;     -- blk of this is the same as block of t
            -- end;
            -- spawn T with
            --  this.x = y;     -- blk of this is the same spawn pool
            -- end
            local dcl = AST.iter'Dcl_var'()
            if dcl then
                to_blk = dcl.var.blk
            else
                AST.asr(constr.__par, 'Spawn')
                local _,pool,_ = unpack(constr.__par)
                assert(assert(pool.lst).var)
                to_blk = pool.lst.var.blk
            end
        else
            -- block where variable is defined
            to_blk = NODE2BLK(to)
        end

        local fr_blk = NODE2BLK(fr)

    -- CHECK IF "FINALIZE" IS REQUIRED

        local func_impure, input_call = false, false
        local T = fr.lst
        if T then
            if T.tag == 'Op2_call' then
                func_impure = (T.c.mod~='@pure')
            elseif T.tag == 'EmitExt' then
                local op, ext, param = unpack(T)
                input_call = op=='call' and ext.evt.pre=='input'
            end
        end

        if me.fin then
            ASR( AST.isParent(cls, to_blk), me,
                'cannot finalize a variable defined in another class' )
            --  class T with
            --  do
            --      finalize
            --          _GLB = <...>
            --      with
            --          <...>
            --      end
            --  end
        end

        -- TODO: move to exp/ref.lua
        if func_impure or input_call or fr.tag=='RawExp' then
            -- We assume that a impure function that returns a global pointer
            -- creates memory (e.g. malloc, fopen):
            --      var void&? pa = _fopen();
            -- We assume that a RawExp that returns a global pointer
            -- creates memory (e.g. { new T }):
            --      var void&? pa = { new T() };
            -- In these cases, the return memory would persist when
            -- the local goes out of scope, hence, we require finalization.
            -- The "to" pointers must be option types `&?´.

            if to.tp.ref and to.tp.opt then
                T.__fin_opt_tp = to.tp  -- return value must be packed in the "&?" type
            else
                ASR(to.tp.id == '@', me, 1105,
                    'must assign to a option reference (declared with `&?´)')
                -- var void* ptr = _malloc(1);  // no
                -- _ptr = _malloc(1);           // ok
            end

            ASR(me.fin, me, 'attribution requires `finalize´')
                -- var void&? ptr = _malloc(1);
            if me.fin then
                to_blk.fins = to_blk.fins or {}
                table.insert(to_blk.fins, 1, me.fin)
            end
            return
        end
        ASR(not me.fin, me, 'attribution does not require `finalize´')


    -- REFUSE THE FOLLOWING POINTER ATTRIBUTIONS:
        -- to pointers inside organisms (e.g., org.x=y)
        -- to pointers with greater scope than source
    -- (CHECK IF ":=" IS REQUIRED)

        -- refuse "org.x=y", unless "this" (inside constructor or not)
        -- "this" is easy to follow inside the single body
        -- other assignments are spread in multiple bodies
--[[
        if to.org and to.fst.tag~='This' then
            ASR(op==':=', me,
                'organism pointer attribution only inside constructors')
                -- var T t;
                -- t.v = null;

        else
]]
            -- OK: "fr" is a pointer to org (watching makes it safe)
            -- OK: "fr" `&´ reference has bigger scope than "to"
            -- int a; int* pa; pa=&a;
            -- int a; do int* pa; pa=&a; end
-- TODO: this code is duplicated with "ref.lua"
            if not (
                fr.const                   or -- constants are globals
                fr.fst.tag == 'Nat'        or -- natives are globals
                (fr.tag=='Op2_call' and       -- native calls are globals
                 fr[2].fst.tag=='Nat')     or
                AST.iter'Dcl_constr'()     or -- org bodies can't hold
                (fr.org and                   -- "global:*" is global
                 fr.org.cls.id=='Global')  or
                (ENV.clss[to.tp.id] and       -- organisms must use "watching"
                 fr.tag~='Op1_&')          or -- (but avoid &org)
                (ENV.adts[to.tp.id] and       -- adts must use "watching"
                 fr.tag~='Op1_&')          or -- (but avoid &adt)
                (   -- same class and scope of "to" <= "fr"
                    (AST.par(to_blk,'Dcl_cls') == AST.par(fr_blk,'Dcl_cls')) and
                        (   to_blk.__depth >= fr_blk.__depth            -- to <= fr
                        or (to_blk.__depth==cls.blk_ifc.__depth and     --    or
                            fr_blk.__depth==cls.blk_body.__depth)       -- ifc/bdy
                        )
                )
            ) then
                ASR(op==':=', me, 'attribution to pointer with greater scope')
                    -- NO:
                    -- var int* p;
                    -- do
                    --     var int i;
                    --     p = &i;
                    -- end
            else
                ASR(op=='=', me, 'wrong operator')
            end
        --end

    -- FORCE @hold FOR UNSAFE ATTRIBUTIONS INSIDE FUNCTIONS

        local fun = AST.iter'Dcl_fun'()
        if op==':=' and fun and                          -- unsafe attribution
           (to_blk==cls.blk_ifc or to_blk==cls.blk_body) -- inside a function
        then                                             -- to ifc/body field
            -- must be hold
            local _, _, ins, _, _, _ = unpack(fun)
            -- functions/methods that hold pointers
            -- must annotate those arguments
            ASR(ins[fr.lst.var.funIdx][1], me, 1106, 'parameter must be `hold´')
                -- function (void* v)=>void f do
                --     _V := v;
                -- end
                -- class T with
                --     var void* a;
                -- do
                --     function (void* v)=>void f do
                --         this.a := v;
                --     end
                -- end
        end
    end,

    Var = function (me)
        if NOPTR(me.var) then
            return
        end
        if me.var.pre=='pool' or me.var.pre=='function' then
            return
        end

        -- re-setting variable
        local set = AST.par(me,'Set')
        local to  = set and set[4]
        if to and (to==me or (to.tag=='VarList' and AST.isParent(to, me))) then
            GET()[me.var] = 'accessed'
            -- set[4] is VarList or Var
            return
        end
        if AST.par(me,'Dcl_constr') and me.__par.fst.tag=='This' then
            return  -- constructor access
        end

        local loop = AST.par(me, 'Loop')
        local ext  = AST.get(loop,'Loop', 4,'Stmts', 1,'Set', 3,'Await', 1,'Ext')
        if loop and loop.isAwaitUntil and ext and ext[1]=='_ok_killed' then
-- TODO: bug: what if the "o" expression contains other pointers?
            return  -- o'=await o until o==o'
        end

        local cls = CLS()
        local acc = GET()[me.var]

        if acc and acc.tag=='Dcl_cls' and
            (not AST.isParent(cls.blk_body,me.var.blk))
        then
            -- Or access to pointer in recursive class:
            --      var t* ptr;
            --      class Rec with
            --          var t* ptr;
            --      do
            --          ptr = x;
            --      end
            acc = acc

        elseif not AST.isParent(CLS(),me.var.blk) then
            -- Access to pointer defined in an outer organism:
            --      this.out.ptr = x;
            acc = GET()['_']
                -- check any await, even with no previous access to "ptr"

        else
            -- Across-await access to pointer defined in any lexical scope above:
            --      await E;
            --      ptr = x;
            acc = acc
        end

        if type(acc) ~= 'table' then
            GET()[me.var] = 'accessed'
            return  -- no await happened yet
        end

        -- access in the beginning of recursive class
        -- check if enclosing par/or is a "watching me.var"
        -- if so, this access is safe
        if acc.tag == 'Dcl_cls' then
            for paror in AST.iter('ParOr') do
                if paror and AST.isParent(paror[1],me) then
                    local var = paror.__adj_watching and 
                                                     paror.__adj_watching.lst
                                                     and paror.__adj_watching.lst.var
                    if var and var==me.var then
                        -- sets all accesses to "me.var" in the recursive class
                        -- table (acc.GET) to point to the "watching"
                        -- (so that they become child of it)
                        acc.GET[me.var] = paror

                        -- make this access safe
                        acc = paror
                    end
                end
            end
        end

        -- possible dangling pointer "me.var" is accessed across await

        if (ENV.clss[me.tp.id] or ENV.adts[me.tp.id]) then
            -- pointer to org: check if it is enclosed by "watching me.var"
            -- since before the first await
            for paror in AST.iter('ParOr') do
                local var = paror.__adj_watching and paror.__adj_watching.lst
                                                 and paror.__adj_watching.lst.var
                if var==me.var and AST.isParent(paror,acc) then
                    return      -- ok, I'm safely watching "me.var"
                end
            end
        end

        -- invalid access!
        local acc_id = assert(AST.tag2id[acc.tag], 'bug found')
        WRN(false, me, 1107, -- Tkachov (June 05, 2015): I use pointers only when it's safe =)
            'unsafe access to pointer "'..me.var.id..'" across `'..
                acc_id..'´ ('..acc.ln[1]..' : '..acc.ln[2]..')')
    end,

    __await = function (me)
        for _, T in ipairs(TRACK) do        -- search in all levels
            for var, v in pairs(T) do
                if v == 'accessed' then
                    GET()[var] = me   -- tracks the *first* await
                end
            end
        end
        GET()['_'] = me
    end,
    EmitInt = '__await',
    Spawn   = '__await',
    Kill    = '__await',

    Await = function (me)
        if me.tl_awaits then
            F.__await(me)
        end
    end,
    AwaitN   = 'Await',
    --Block    = 'Await',
    Async_pre  = 'Await',
    Thread_pre = 'Await',
    ParOr    = 'Await',
    ParAnd   = 'Await',
    ParEver  = 'Await',

    --Loop     = 'Await',
    Loop = function (me)
        if me.isAwaitUntil then
            return
        else
            F.Await(me)
        end
    end,

    Finalize_pre = function (me, set, fin)
        if not fin then
            set, fin = unpack(me)
        end
        AST.asr(fin[1],'Block', 1,'Stmts')
        fin.active = (#fin[1][1]>1 or
                      fin[1][1][1] and fin[1][1][1].tag~='Nothing')

        if AST.iter'Dcl_constr'() then
            ASR(not fin.active, me, 1108,
                    'constructor cannot contain `finalize´')
        end

        if set then
            -- EmitExt changes the AST
            if set.tag=='Block' then
                set = set[1][2] -- Block->Stmt->Set
            end
            set.fin = fin                   -- let call/set handle
        elseif fin.active then
            local blk = AST.iter'Block'()
            blk.fins = blk.fins or {}
            table.insert(blk.fins, 1, fin)  -- force finalize for this blk
        end
    end,

    Op2_call_pre = function (me)
        local _, f, exps, fin = unpack(me)
        if fin then
            F.Finalize_pre(me, me, fin)
        end
    end,

    __check_params = function (me, ins, params)
        local req = false
        for i, param in ipairs(params) do
            local hold = true
            if ins then
                hold = ins.tup[i].hold
            end
            if hold then
                -- int* pa; _f(pa);
                --  (`pa´ termination must consider `_f´)
                local r = (param.tp.ptr>0 or param.tp.ext or param.tp.arr) and
                          (not param.isConst) and
                          (not param.c or param.c.mod~='const')
                                -- except constants

                r = r and param.fst and param.fst.blk or
                    r and param.fst and param.fst.var and param.fst.var.blk
                            -- need to hold block
                WRN( (not r) or (not req) or (r==req),
                        me, 'invalid call (multiple scopes)')
                req = req or r
            end
        end
        return req
    end,

    Op2_call = function (me)
        local _, f, params, fin = unpack(me)

        local req = false

        if not (me.c and (me.c.mod=='@pure' or me.c.mod=='@nohold')) then
            req = F.__check_params(
                    me,
                    f.var and f.var.fun and f.var.fun.ins,
                    params)
        end

        -- TODO: should yield error if requires finalize and is inside Thread?
        if AST.iter'Thread'() then
            req = false     -- impossible to run finalizers on threads
        end

        ASR((not req) or fin or AST.iter'Dcl_fun'(), me, 1109,
            'call requires `finalize´')
        ASR((not fin) or req, me, 1110, 'invalid `finalize´')

        if fin and fin.active then
            req.fins = req.fins or {}
            table.insert(req.fins, 1, fin)
        end
    end,

    ParEver_pre = function (me)
        me.__tojoin = {}
    end,
    ParEver_pos = function (me)
        JOIN(me)
    end,
    ParEver_bef = function (me)
        PUSH(me)
    end,
    ParEver_aft = function (me)
        POP()
    end,
    ParAnd_pre = 'ParEver_pre',
    ParAnd_bef = 'ParEver_bef',
    ParAnd_aft = 'ParEver_aft',
    ParAnd_pos = 'ParEver_pos',
    ParOr_pre  = 'ParEver_pre',
    ParOr_bef  = 'ParEver_bef',
    ParOr_aft  = 'ParEver_aft',
    ParOr_pos  = 'ParEver_pos',

    -- skip condition (i>1)
    If_bef = function (me, _, i)
        if i > 1 then
            PUSH(me)
        end
    end,
    If_aft = function (me, _, i)
        if i > 1 then
            POP()
        end
    end,
    If_pre = 'ParEver_pre',
    If_pos = 'ParEver_pos',
}

AST.visit(F)

--[[
-- EVENTS:
--
-- The event emitter may pass a pointer that is already out of scope when the
-- awaking trail uses it:
--
-- event void* e;
-- var void* v = await e;
-- await ...;   // v goes out of scope
-- *v;          // segfault
--
-- We have to force the receiving "v" to go out of scope immediatelly:
--
--  event void* e;
--  do
--      var void* v = await e;
--      await ...;   // ERROR: cannot inside the "v" enclosing do-end
--      *v;
--  end
--
-------------------------------------------------------------------------------
--
-- FUNCTIONS:
--
-- When holding a parameter, a function could do either on native globals
-- or on object fields:
--
--      function (void* v1, void* v2)=>void f do
--          this.v = v1;    // OK
--          _V     = v2;    // NO!
--      end
--
-- For object fields, the caller must write a finalizer only if the
-- parameter has a shorter scope than the object of the method call:
--
--      // w/o fin
--      var void* p;
--      var T t;
--      t.f(p);     // t == p (scope)
--
--      // w/ fin
--      var T t;
--      do
--          var void* p;
--          t.f(p)      // t > p (scope)
--              finalize with ... end;
--      end
--
-- Native globals should be forbidden because we would need two different
-- kinds of "nohold" annotations to distinguish the two scopes (object and
-- global).
--
-- Native globals can be assigned in static functions requiring finalizer
-- whenever appliable.
]]

end

    --dofile 'awaits.lua'
    
do
PROPS = {
    has_exts    = false,
    has_wclocks = false,
    has_ints    = false,
    has_asyncs  = false,
    has_threads = false,
    has_orgs    = false,
    has_ifcs    = false,
    has_clear   = false,
    has_pses    = false,
    has_ret     = false,
    has_lua     = false,
    has_orgs_watching = false,
    has_adts_watching = {},
    has_enums   = false,
    has_pool_iterator = false,

    has_orgs_news        = false,
    has_orgs_news_pool   = false,
    has_orgs_news_malloc = false,
    has_adts_news        = false,
    has_adts_news_pool   = false,
    has_adts_news_malloc = false,
}

local NO_atomic = {
    Finalize=true, Finally=true,
    Host=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true, EmitExt=true,
    Pause=true,
    -- TODO:
    Loop=true, Break=true, Escape=true,
    Op2_call=true,
}

local NO_fun = {
    Finalize=true, Finally=true,
    Host=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true, --EmitExt=true,
    Pause=true,
    Spawn=true,
}

local NO_fin = {
    Finalize=true, Finally=true,
    Host=true, Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true,
    Pause=true,
    Kill=true,
}

local NO_async = {
    Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true,
    Pause=true,
    Escape=true,
    Finalize=true,
}

local NO_thread = {
    Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true, EmitExt=true,
    Pause=true,
    Escape=true,
    Finalize=true,
}

local NO_constr = {
    --Finalize=true, Finally=true,
    Escape=true, Async=true, Thread=true,
    ParEver=true, ParOr=true, ParAnd=true,
    Await=true, AwaitN=true,
    EmitInt=true,
    Pause=true,
}

-- Loop, SetBlock may need clear
-- if break/return are in parallel w/ something
--                  or inside block that needs_clr
function NEEDS_CLR (top)
    for n in AST.iter() do
        if n.tag == top.tag then
            break
        elseif n.tag == 'ParEver' or
               n.tag == 'ParAnd'  or
               n.tag == 'ParOr'   or
               n.tag == 'Block' and n.needs_clr then
            PROPS.has_clear = true
            top.needs_clr = true
            break
        end
    end
end

function HAS_FINS ()
    for n in AST.iter() do
        if n.tag == 'Block'    or
           n.tag == 'ParOr'    or
           n.tag == 'Loop'     or
           n.tag == 'SetBlock' then
            n.needs_clr_fin = true
        end
    end
end

F = {
    Node_pre = function (me)
        if NO_atomic[me.tag] then
            ASR(not AST.par(me,'Atomic'), me,
                'not permitted inside `atomic´')
        end
        if NO_fun[me.tag] then
            ASR(not AST.par(me,'Dcl_fun'), me,
                'not permitted inside `function´')
        end
        if NO_fin[me.tag] then
            ASR(not AST.par(me,'Finally'), me,
                'not permitted inside `finalize´')
        end
        if NO_async[me.tag] then
            ASR(not AST.par(me,'Async'), me,
                    'not permitted inside `async´')
        end
        if NO_thread[me.tag] then
            ASR(not AST.par(me,'Thread'), me,
                    'not permitted inside `thread´')
        end
        if NO_constr[me.tag] then
            ASR(not AST.par(me,'Dcl_constr'), me,
                    'not permitted inside a constructor')
        end
    end,

    Block_pre = function (me)       -- _pre: break/return depends on it
        if me.fins then
            me.needs_clr = true
            me.needs_clr_fin = true
            PROPS.has_clear = true
        end

        for _, var in ipairs(me.vars) do
            if var.cls then
                me.needs_clr = true
            end
            if var.pre=='pool' then
                local s
                if ENV.clss[var.tp.id] or var.tp.id=='_TOP_POOL' then
                    s = 'orgs'
                else
                    me.needs_clr = true
                    PROPS.has_clear = true
                    s = 'adts'
                end
                PROPS['has_'..s..'_news'] = true
                if var.tp.arr==true then
                    PROPS['has_'..s..'_news_malloc'] = true  -- pool T[] ts
                else
                    PROPS['has_'..s..'_news_pool'] = true    -- pool T[N] ts
                end
            end
        end

        if me.needs_clr then
            HAS_FINS()  -- TODO (-ROM): could avoid ors w/o fins
        end
    end,
    Spawn = function (me)
        local _,pool,_ = unpack(me)
        --me.blk.needs_clr = true   (var.cls does this)
        ASR(not AST.par(me,'BlockI'), me,
                'not permitted inside an interface')
    end,

    Dcl_pool = function (me)
        local pre, tp, id, constr = unpack(me)
        local tid = tp[1]
        local is_unbounded = (tp[3]==true)
        if ENV.clss[tid] then
            PROPS.has_orgs_news = true
            if is_unbounded then
                PROPS.has_orgs_news_malloc = true       -- pool T[]  ts
            else
                PROPS.has_orgs_news_pool = true         -- pool T[N] ts
            end
        elseif ENV.adts[tid] then
            PROPS.has_adts_news = true
            if is_unbounded then
                PROPS.has_adts_news_malloc = true       -- pool T[]  ts
            else
                PROPS.has_adts_news_pool = true         -- pool T[N] ts
            end
        end
    end,

    ParOr = function (me)
        me.needs_clr = true
        PROPS.has_clear = true
    end,

    Loop = function (me)
        if me.iter_tp == 'org' then
            PROPS.has_pool_iterator = true
        end
    end,

    Loop_pre = function (me)
        me.brks = {}
    end,
    Break = function (me)
        local loop = AST.par(me,'Loop')
        ASR(loop, me, '`break´ without loop')
        loop.brks[me] = true
        loop.has_break = true

        NEEDS_CLR(loop)

        local fin = AST.par(me, 'Finally')
        ASR((not fin) or AST.isParent(fin, loop), me,
                'not permitted inside `finalize´')

        WRN(not loop.isEvery, me,
                'not permitted inside `every´')

        local async = AST.iter(AST.pred_async)()
        if async then
            local loop = AST.iter'Loop'()
            ASR(loop.__depth>async.__depth, me, '`break´ without loop')
        end
    end,

    SetBlock_pre = function (me)
        me.rets = {}
        ASR(not AST.par(me,'BlockI'), me,
                'not permitted inside an interface')
    end,
    Escape = function (me)
        local blk = AST.iter'SetBlock'()
        blk.rets[me] = true
        blk.has_escape = true

        local fin = AST.par(me, 'Finally')
        ASR((not fin) or AST.isParent(fin, blk), me,
                'not permitted inside `finalize´')

        local evr = AST.iter(function (me) return me.tag=='Loop' and me.isEvery end)()
        WRN((not evr) or AST.isParent(evr,blk), me, -- Tkachov (July 15, 2015): meh
                'not permitted inside `every´')

        NEEDS_CLR(blk)
    end,

    Return = function (me)
        ASR(AST.iter'Dcl_fun'(), me,
                'not permitted outside a function')
    end,

    Outer = function (me)
        ASR(AST.par(me,'Dcl_constr'), me,
            '`outer´ can only be unsed inside constructors')
    end,

    Dcl_cls = function (me)
        if me.id ~= 'Main' then
            PROPS.has_orgs  = true
            PROPS.has_clear = true
        end
        if me.is_ifc then
            PROPS.has_ifcs = true
        end
    end,

    Dcl_ext = function (me)
        PROPS.has_exts = true
    end,

    Dcl_var = function (me)
        if me.var.cls then
            -- <class T with var U u; end>
            ASR(not AST.par(me,'BlockI'), me,
                    'not permitted inside an interface')
        end
        if AST.par(me,'BlockI') and me.var.tp.opt then
            CLS().has_pre = true   -- code for pre (before constr)
        end
    end,

    Async = function (me)
        PROPS.has_asyncs = true
    end,
    Thread = function (me)
        PROPS.has_threads = true
    end,
    Sync = function (me)
        ASR(AST.iter'Thread'(), me,'not permitted outside `thread´')
    end,

    Pause = function (me)
        PROPS.has_pses = true
    end,

    Nothing = function (me)
        -- detects if "watching" an org/adt
        local watch = me.__env_watching
        if watch then
            if watch == true then
                PROPS.has_orgs_watching = true
            else
                PROPS.has_adts_watching[watch] = true
            end
        end
    end,

    _loop1 = function (me)
        for loop in AST.iter'Loop' do
            if loop.isEvery then
                ASR(me.isEvery, me,
                    '`every´ cannot contain `await´')
            elseif loop.iter_tp == 'org' then
                ASR(false, me,
                    'pool iterator cannot contain `await´')
            end
        end
    end,

    Await = function (me)
        local e, dt = unpack(me)
        if e.tag ~= 'Ext' then
            PROPS.has_ints = true
        elseif dt then
            PROPS.has_wclocks = true
        end

        if e.tag=='Ext' and e[1]=='_ok_killed' then
            return
        else
            F._loop1(me)
        end
    end,
    AwaitN = function (me)
        F._loop1(me)
    end,

    EmitInt = function (me)
        PROPS.has_ints = true
    end,

    EmitExt = function (me)
        local op, ext = unpack(me)
        if ext.evt.pre == 'input' then
            ASR( AST.par(me,'Async') or op=='call',
                me, 'invalid `'..op..'´')
                    -- no <emit I> on sync
        end

        if AST.par(me,'Dcl_fun') then
            ASR(op=='call', me, 'invalid `emit´')
        end
    end,

    Set = function (me)
        local _, set, fr, to = unpack(me)
        local thr = AST.par(me, 'Thread')
        if thr and (not to) then
            ASR( thr.__depth <= AST.iter'SetBlock'().__depth+1, me,
                    'invalid access from `thread´')
        end

        if AST.par(me,'BlockI') then
            CLS().has_pre = true   -- code for pre (before constr)
            ASR(set=='exp' or set=='adt-constr',
                me, 'not permitted inside an interface')
        end

        if to.tag=='Var' and to.var.id=='_ret' then
            PROPS.has_ret = true
        end
    end,

    Op1_cast = function (me)
        local tp, _ = unpack(me)
        if tp.ptr>0 and ENV.clss[tp.id] then
            PROPS.has_ifcs = true      -- cast must check org->cls_id
        end
    end,

    Lua = function (me)
        PROPS.has_lua = true
    end,
}

AST.visit(F)

end

    
do
-- TODO: rename to flow
ANA = {
    ana = {
        isForever  = nil,
        reachs   = 0,      -- unexpected reaches
        unreachs = 0,      -- unexpected unreaches
    },
}

function ANA.dbg_one (p)
    for e in pairs(p) do
        if e == true then
            DBG('', '$$$')
        else
            for _,t in pairs(e) do
                DBG('', _, t.id)
            end
        end
    end
end
function ANA.dbg (me)
    DBG('== '..me.tag, me)
    DBG('-- PRE')
    ANA.dbg_one(me.ana.pre)
    DBG('-- POS')
    ANA.dbg_one(me.ana.pos)
end

-- avoids counting twice (due to loops)
-- TODO: remove
local __inc = {}
function INC (me, c)
    if __inc[me] then
        return true
    else
        ANA.ana[c] = ANA.ana[c] + 1
        __inc[me] = true
        return false
    end
end

-- [false]  => never terminates
-- [true]   => terminates w/o event

function OR (me, sub, short)

    -- TODO: short
    -- short: for ParOr/Loop/SetBlock if any sub.pos is equal to me.pre,
    -- then we have a "short circuit"

    for k in pairs(sub.ana.pos) do
        if k ~= false then
            me.ana.pos[false] = nil      -- remove NEVER
            me.ana.pos[k] = true
        end
    end
end

function COPY (n)
    local ret = {}
    for k in pairs(n) do
        ret[k] = true
    end
    return ret
end

function ANA.CMP (n1, n2)
    return ANA.HAS(n1, n2) and ANA.HAS(n2, n1)
end

function ANA.HAS (n1, n2)
    for k2 in pairs(n2) do
        if not n1[k2] then
            return false
        end
    end
    return true
end

local LST = {
    Do=true, Stmts=true, Block=true, Root=true, Dcl_cls=true,
    Pause=true, Set=true,
}

F = {
    Root_pos = function (me)
        ANA.ana.isForever = not (not me.ana.pos[false])
    end,

    Node_pre = function (me)
        if me.ana then
            return
        end

        local top = AST.iter()()
        me.ana = {
            pre  = (top and COPY(top.ana.pre)) or { [true]=true },
        }
    end,
    Node = function (me)
        if me.ana.pos then
            return
        end
        local lst
        for i=#me, 1, -1 do
            if AST.isNode(me[i]) then
                lst = me[i]
                break
            end
        end
        if LST[me.tag] and lst then
            me.ana.pos = COPY(lst.ana.pos)  -- copy lst child pos
        else
            me.ana.pos = COPY(me.ana.pre)       -- or copy own pre
        end
    end,

    Dcl_cls_pos = function (me)
        local _,id = unpack(me)
        if id ~= 'Main' then
            me.ana.pos = COPY(me.ana.pre) -- no effect on enclosing class
-- TODO: evaluate class termination as well
        end
    end,
    Dcl_cls_pre = function (me)
        if me ~= MAIN then
            me.ana.pre = { [me.id]=true }
        end
    end,
    Orgs = function (me)
        me.ana.pos = { [false]=true }       -- orgs run forever
    end,

    Stmts_bef = function (me, sub, i)
        if i == 1 then
            -- first sub copies parent
            sub.ana = {
                pre = COPY(me.ana.pre)
            }
        else
            -- broken sequences
            if sub.tag~='Host' and me[i-1].ana.pos[false] and (not me[i-1].ana.pre[false]) then
                --ANA.ana.unreachs = ANA.ana.unreachs + 1
                me.__unreach = true
                WRN( INC(me, 'unreachs'),
                     sub, 'statement is not reachable')
            end
            -- other subs follow previous
            sub.ana = {
                pre = COPY(me[i-1].ana.pos)
            }
        end
    end,

    ParOr_pos = function (me)
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub, true)
        end
        if me.ana.pos[false] then
            --ANA.ana.unreachs = ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, 'at least one trail should terminate')
        end
    end,

    ParAnd_pos = function (me)
        -- if any of the sides run forever, then me does too
        -- otherwise, behave like ParOr
        for _, sub in ipairs(me) do
            if sub.ana.pos[false] then
                me.ana.pos = { [false]=true }
                --ANA.ana.unreachs = ANA.ana.unreachs + 1
                WRN( INC(me, 'unreachs'),
                     sub, 'trail should terminate')
                return
            end
        end

        -- like ParOr, but remove [true]
        local onlyTrue = true
        me.ana.pos = { [false]=true }
        for _, sub in ipairs(me) do
            OR(me, sub)
            if not sub.ana.pos[true] then
                onlyTrue = false
            end
        end
        if not onlyTrue then
            me.ana.pos[true] = nil
        end
    end,

    ParEver_pos = function (me)
        me.ana.pos = { [false]=true }
        local ok = false
        for _, sub in ipairs(me) do
            if sub.ana.pos[false] then
                ok = true
                break
            end
        end
        if not ok then
            --ANA.ana.reachs = ANA.ana.reachs + 1
            WRN( INC(me, 'reachs'),
                 me, 'all trails terminate')
        end
    end,

    If = function (me)
        me.ana.pos = { [false]=true }
        for _, sub in ipairs{me[2],me[3]} do
            OR(me, sub)
        end
    end,

    SetBlock_pre = function (me)
        me.ana.pos = { [false]=true }   -- `return/break´ may change this
    end,
    Escape = function (me)
        local top = AST.iter((me.tag=='Escape' and 'SetBlock') or 'Loop')()
        me.ana.pos = COPY(me.ana.pre)
        OR(top, me, true)
        me.ana.pos = { [false]='esc' }   -- diff from [false]=true
    end,
    SetBlock = function (me)
        local blk = me[1]
        if not blk.ana.pos[false] then
            --ANA.ana.reachs = ANA.ana.reachs + 1
            WRN( INC(me, 'reachs'),
                 blk, 'missing `escape´ statement for the block')
        end
    end,

    Loop_pre = 'SetBlock_pre',
    Break    = 'Escape',

    Loop = function (me)
        local max,iter,_,body = unpack(me)

        -- if eventually terminates (max or iter) and
        --   loop iteration is reachable (not body.pos[false]),
        -- then me.pos=U(me.pre,body.pos)
        -- ('number','org','data' are bounded, 'event' is not)
        if (max or iter and me.iter_tp~='event') and
            (not body.ana.pos[false])
        then
            -- union(me.ana.pre, body.ana.pos)
            me.ana.pos = COPY(me.ana.pre)
            OR(me, body)
            return
        end

        if body.ana.pos[false] then
            --ANA.ana.unreachs = ANA.ana.unreachs + 1
            WRN( INC(me, 'unreachs'),
                 me, '`loop´ iteration is not reachable')
        end
    end,

    -- warn if recursive spawn w/o await path
    Spawn = function (me)
        local id, pool, _,_ = unpack(me)
        local cls = CLS()

        -- recursive spawn (spawn T inside T)
        if id == cls.id then
            -- no await from the begin to spawn
            if me.ana.pre[id] == true then
                -- pool is unbounded
                if pool.tp.arr == true then
                    WRN(false, me, 'unbounded recursive spawn')
                end
            end
        end
    end,

    Thread = 'Async',
    Async = function (me)
        if me.ana.pre[false] then
            me.ana.pos = COPY(me.ana.pre)
        else
            me.ana.pos = { ['ASYNC_'..me.n]=true }  -- assume it terminates
        end
    end,

    Await_aft = function (me, sub, i)
        if i > 1 then
            return
        end

        -- between Await and Until

        local e, dt, cnd = unpack(me)

        local t
        if me.ana.pre[false] then
            t = { [false]=true }
        else
            -- enclose with a table to differentiate each instance
            t = { [{e.evt or e.var}]=true }
        end
        me.ana.pos = COPY(t)
        if cnd then
            cnd.ana = {
                pre = COPY(t),
            }
        end
    end,

    -- TODO: behaves similarly to Stmts
    --  join code
    Set_aft = function (me, sub, i)
        if sub.tag == 'Await' then
            me[i+1].ana = {
                pre = COPY(sub.ana.pos)
            }
        end
    end,

    AwaitN = function (me)
        me.ana.pos = { [false]=true }
    end,
}

local _union = function (a, b, keep)
    if not keep then
        local old = a
        a = {}
        for k in pairs(old) do
            a[k] = true
        end
    end
    for k in pairs(b) do
        a[k] = true
    end
    return a
end

-- TODO: remove
-- if nested node is reachable from "pre", join with loop POS
function ANA.union (root, pre, POS)
    local t = {
        Node = function (me)
            if me.ana.pre[pre] then         -- if matches loop begin
                _union(me.ana.pre, POS, true)
            end
        end,
    }
    AST.visit(t, root)
end

AST.visit(F)

end

    
do
ANA.ana.acc  = 0      -- nd accesses
ANA.ana.abrt  = 0      -- nd flows
ANA.ana.excpt = 0      -- nd excpt

-- any variable access calls this function
-- to be inserted on parent Parallel sub[i] or Class
function iter (n)
    local par = n.__par and n.__par.tag
    return par=='ParOr' or par=='ParAnd' or par=='ParEver'
        or n.tag=='Dcl_cls'
end

function ERR (me, msg)
    return msg..' ('..me.ln[1]..':'..me.ln[2]..')'
end

function INS (acc, exists)
--[[
    if AST.iter'Async'() then
        acc.md = 'no'                       -- protected acc
    end
    if AST.iter'Sync'() then
        acc.md = 'no'                       -- protected acc
    end
]]
    if not exists then
        acc.cls = CLS()                     -- cls that acc resides
    end
    local n = AST.iter(iter)()             -- child Block from PAR
    if n then
        n.ana.accs[#n.ana.accs+1] = acc
    end
    return acc
end

function CHG (acc, md)
    if AST.iter'Thread'() then
        return
    end
    if acc.md == 'nv' then
        return
    else
        acc.md = md
    end
end

F = {
-- accs need to be I-indexed (see CHK_ACC)
    Dcl_cls_pre = function (me)
        me.ana.accs = {}
    end,
    ParOr_pre = function (me)
        for _, sub in ipairs(me) do
            sub.ana.accs = {}
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

    ParOr_pos = function (me)
        -- insert all my subs on my parent Par
        if AST.iter(AST.pred_par) then -- requires ParX_pos
            for _, sub in ipairs(me) do
                for _,acc in ipairs(sub.ana.accs) do
    -- check par/enter only against immediate pars
                    if acc.md ~= 'par' then
    -- check ParOr esc only against immediate pars
                    if not (acc.md=='esc' and acc.id.tag=='ParOr') then
    -- check Loop esc only against nested pars
                    --if not (acc.md=='esc' and acc.id.tag=='Loop'
                            --and acc.id.depth>me.depth) then
                        INS(acc, true)
                    --end
                    end
                    end
                end
            end
        end
    end,
    ParAnd_pos  = 'ParOr_pos',
    ParEver_pos = 'ParAnd_pos',

    Spawn = function (me)
        local sz = #me.cls.ana.accs -- avoid ipairs due to "spawn myself"
        for i=1, sz do
            INS(me.cls.ana.accs[i], true)
        end
    end,

-- TODO: usar o Dcl_var p/ isso
--[=[
    Orgs = function (me)
        -- insert cls accs on my parent ParOr
        for _, var in ipairs(me.vars) do
            for _,acc in ipairs(var.cls.ana.accs) do
                INS(acc, true)
            end
        end
    end,
]=]

    EmitExt = function (me)
        local _, e1, e2 = unpack(me)
        if e1.evt.pre == 'input' then
            return
        end
        INS {
            path = me.ana.pre,
            id  = e1.evt.id,    -- like functions (not table events)
            md  = 'cl',
            tp  = TP.fromstr'@',
            any = false,
            err = ERR(me, 'event `'..e1.evt.id..'´')
        }
--[[
        if e2 then
            local tp = TP.deptr(e1.evt.ins, true)
            if e2.accs and tp then
                e2.accs[1][4] = (e2.accs[1][2] ~= 'no')   -- &x does not become 
                    "any"
                e2.accs[1][2] = (me.c and me.c.mod=='@pure' and 'rd') or 'wr'
                e2.accs[1][3] = tp
            end
        end
]]
    end,

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        CHG(f.lst.acc, 'cl')
        me.acc = f.lst.acc
        for _, exp in ipairs(exps) do
            if exp.tp.ptr>0 then
                local v = exp.lst
                if v and v.acc then   -- ignore constants
--DBG(exp.tag, exp.lst)
                    v.acc.any = exp.lval    -- f(&x) // a[N] f(a) // not "any"
                    CHG(v.acc, (me.c and me.c.mod=='@pure' and 'rd') or 'wr')
                    v.acc.tp = TP.copy(exp.tp)
                    v.acc.tp.ptr = v.acc.tp.ptr - 1     -- f may deref exp
                end
            end
        end

        -- TODO: never tested
--[[
        me.acc = INS {
            path = me.ana.pre,
            id  = f,
            md  = 'cl',
            tp  = TP.fromstr'@',
            any = true,
            err = 'call to `'..f.id..'´ (line '..me.ln[2]..')',
        }
]]
    end,

    EmitInt = function (me)
        local _, e1, e2 = unpack(me)
        CHG(e1.lst.acc, 'tr')
        e1.lst.acc.node = me        -- emtChk
        me.emtChk = false
    end,

    Set = function (me)
        local _,_,_,to = unpack(me)
        to = (to.tag=='VarList' and to) or {to}
        for _, v in ipairs(to) do
            if v.lst.acc and v.lst.acc.md~='no' and v.lst.acc.md~='nv' then
                CHG(v.lst.acc, 'wr')
            else
                -- *((u32*)0x100) = v  (no acc)
            end
        end
    end,

    ['Op2_idx'] = function (me)
        if not (me.lst.var and me.lst.var.tp.arr) then
            me.lst.acc.any = true
        end
        me.lst.acc.tp = me.tp  -- deptr'd
    end,
    ['Op1_*'] = function (me)
        if not me.lst.acc then
            assert(me.lst.sval)
            return  -- constants
        end

        me.lst.acc.any = true
        me.lst.acc.tp = me.tp  -- deptr'd

        -- TODO: HACK_3
        -- ignore cast to tceu_org
        if me[2].tag=='Op1_cast' and me[2][1][1]=='_tceu_org' then
            me.lst.acc.tp = me[2][2].tp  -- change to uncast type
        end
    end,
    ['Op1_&'] = function (me)
        CHG(me.lst.acc, 'no')
    end,

    Field = function (me)
        me.lst.acc.org = me.org.lst
    end,

    Global = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = 'Global',
            md  = 'rd',
            tp  = me.tp,
            any = true,
            err = ERR(me, 'variable `global´'),
        }
    end,

    Outer = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me,
            md  = 'rd',
            tp  = me.tp,
            any = true,
            err = ERR(me, 'variable `outer´'),
        }
    end,

    This = function (me)
        me.acc = INS {
            path = me.ana.pre,
            id  = me,
            md  = (AST.par(me,'Dcl_constr') and 'nv') or 'rd',
            tp  = me.tp,
            any = true,
            err = ERR(me, 'variable `this´'),
        }
    end,

    Var = function (me)
        local tag = me.__par.tag=='VarList' and me.__par.__par.tag

        if tag=='Async' or tag=='Thread' then
            return  -- <async (v)> is not an access
        end

        local generated = (string.sub(me.var.id,1,1) == '_') and (me.var.id~='_ret')

        me.acc = INS {
            path = me.ana.pre,
            id  = me.var,
            md  = (generated and 'nv') or 'rd',
            tp  = me.var.tp,
            any = me.var.tp.ref,
            err = ERR(me, 'variable/event `'..me.var.id..'´'),
        }

        if me.__par.tag=='Field' and me.__par[2].tag=='This' and AST.par(me,'Dcl_constr') then
            -- variable being allocated cannot be in parallel with anyone
            me.acc.md = 'no'
        end
    end,

    RawExp = 'Nat',
    Nat = function (me)
        local _, generated = unpack(me);
        me.acc = INS {
            path = me.ana.pre,
            id  = me[1],
            md  = (generated and 'nv') or 'rd',
            tp  = TP.fromstr'@',
            any = false,
            err = ERR(me, 'symbol `'..me[1]..'´'),
        }
    end,

    -- FLOW --

    Break = function (me, TAG, PRE)
        TAG = TAG or 'Loop'
        PRE = PRE or me.ana.pre
        local top = AST.iter(TAG)()
        INS {
            path = PRE,
            id  = top,
            md  = 'esc',
            err = ERR(me, 'escape'),
        }
    end,
    Escape = function (me)
        F.Break(me, 'SetBlock')
    end,
    Node = function (me)
        local top = me.__par and me.__par.tag
        if top == 'ParOr' then
            if not me.ana.pos[false] then
                F.Break(me, 'ParOr', me.ana.pos)
            end
        end

        if top=='ParOr' or top=='ParAnd' or top=='ParEver' then
            if not me.ana.pre[false] then
                me.parChk = false           -- only chk if ND flw
                INS {
                    path = me.ana.pre,
                    id   = me,--.__par,
                    md   = 'par',
                    err  = ERR(me,'par enter'),
                }
            end
        end
    end,

    Await = function (me)
        local e = unpack(me)
        if e.tag ~= 'Ext' then
            CHG(me[1].lst.acc, 'aw')
        end
        INS {
            path = me.ana.pos,
            id  = me,--AST.iter(TAG)(),
            md  = 'awk',
            err = ERR(me, 'awake'),
        }
    end,
}

AST.visit(F)

------------------------------------------------------------------------------

local ND = {
    acc = { par={},awk={},esc={},
        cl  = { cl=2, tr=2,     wr=2,     rd=2,     aw=2  },
        tr  = { cl=2, tr=1,     wr=false, rd=false, aw=1  },
        wr  = { cl=2, tr=false, wr=2,     rd=2,     aw=false },
        rd  = { cl=2, tr=false, wr=2,     rd=false, aw=false },
        aw  = { cl=2, tr=1,     wr=false, rd=false, aw=false },
        no  = {},   -- never ND ('ref')
        nv  = {},   -- never ND ('ref')
    },

    flw = { cl={},tr={},wr={},rd={},aw={},no={},nv={},
        par = { par=false, awk=false, esc=1 },
        awk = { par=false, awk=false, esc=1 },
        esc = { par=1,     awk=1,     esc=1 },
    },
}

local ALL = nil     -- holds all emits starting from top-most PAR

--[[
    ana = {
        acc = 1,  -- false positive
    },
    ana = {
        isForever = true,
        n_unreachs = 1,
    },
]]

-- {path [A]=true, [a]=true } => {ret [A]=true, [aX]=true,[aY]=true }
-- {T [a]={[X]=true,[Y]=true} } (emits2pres)
local function int2exts (path, NO_emts, ret)
    ret = ret or {}

    local more = false                  -- converged
    for int in pairs(path) do
        if type(int)=='table' and int[1].pre=='event' then
            for emt_acc in pairs(ALL) do
                if int[1]==emt_acc.id and (not NO_emts[emt_acc]) then
                    for ext in pairs(emt_acc.path) do
                        if not ret[ext] then
                            more = true         -- not converged yet
                            ret[ext] = true     -- insert new ext
                        end
                    end
                end
            end
        else
            ret[int] = true             -- already an ext
        end
    end
    if more then
        return int2exts(ret, NO_emts, ret, cache) -- not converged
    else
        if next(ret)==nil then
            ret[false] = true   -- include "never" if empty
        end
        return ret
    end
end

function par_rem (path, NO_par)
    for id in pairs(path) do
        if NO_par[id] then
            path[id] = nil
        end
    end
    if next(path)==nil then
        path[true] = true       -- include "tight" became empty
    end
    return path
end

function par_level1 (path1, path2)
    for id1 in pairs(path1) do
        for id2 in pairs(path2) do
            if (id1 == false) then
            elseif (id1 == id2) or
                     (type(id1) == 'table') and (type(id2) == 'table') and
                     (id1[1] == id2[1])
            then
                return true
            end
        end
    end
end

--local CACHE = setmetatable({},
    --{__index=function(t,k) t[k]={} return t[k] end})

function CHK_ACC (accs1, accs2, NO_par, NO_emts)
    local cls = CLS()

    -- "acc": i/j are concurrent, and have incomp. acc
    -- accs need to be I-indexed
    for _, acc1 in ipairs(accs1) do
        local path1 = int2exts(acc1.path, NO_emts)
              path1 = par_rem(path1, NO_par)
        for _, acc2 in ipairs(accs2) do
            local path2 = int2exts(acc2.path, NO_emts)
                  path2 = par_rem(path2, NO_par)

            local isLvl1 = par_level1(path1,path2)

-- FLOW (only in safety level-1)
            if isLvl1 and ND.flw[acc1.md][acc2.md] then
                if AST.isParent(acc1.id, acc2.id)
                or AST.isParent(acc2.id, acc1.id)
                then
                    if OPTS.safety > 0 then
                        DBG('WRN : abortion : '..
                                acc1.err..' vs '..acc2.err)
                    end
                    ANA.ana.abrt = ANA.ana.abrt + 1
                    if acc1.md == 'par' then
                        acc1.id.parChk = true
                    end
                    if acc2.md == 'par' then
                        acc2.id.parChk = true
                    end
                end
            end

-- ACC (in both safety levels, ignore aw/tr for level-2)
--DBG(acc1.md,acc2.md, OPTS.safety, ND.acc[acc1.md],ND.acc[acc2.md])
            if par_level1(path1,path2) and ND.acc[acc1.md][acc2.md] or
               OPTS.safety==2 and ND.acc[acc1.md][acc2.md]==2 then
                -- this.x vs this.x (both accs bounded to cls)
                local cls_ = (acc1.cls == cls) or
                             (acc2.cls == cls)

                -- a.x vs this.x
                local _nil = {}
                local o1 = (acc1.org or acc2.org)
                o1 = o1 and o1.acc or _nil
                local o2 = (acc2.org or acc1.org)
                o2 = o2 and o2.acc or _nil

                -- orgs are compatible?
                local org_ = (o1 == o2)
                          or o1.any
                          or o2.any

                -- orgs are compatible?
                local org_ = o1.id == o2.id
                          or o1.any
                          or o2.any

                -- ids are compatible?
                local id_ = acc1.id == acc2.id
                         or acc1.md=='cl' and acc2.md=='cl'
                         or acc1.any and TP.contains(acc1.tp,acc2.tp)
                         or acc2.any and TP.contains(acc2.tp,acc1.tp)

                -- C's are det?
                local c1 = ENV.c[acc1.id]
                c1 = c1 and (c1.mod=='@pure' or c1.mod=='const')
                local c2 = ENV.c[acc2.id]
                c2 = c2 and (c2.mod=='@pure' or c2.mod=='const')
                local c_ = c1 or c2
                        or (ENV.dets[acc1.id] and ENV.dets[acc1.id][acc2.id])

    --DBG(id_, c_,c1,c2, acc1.any,acc2.any)
--[[
DBG'==============='
DBG(acc1.cls.id, acc1, acc1.id, acc1.md, TP.toc(acc1.tp), acc1.any, acc1.err)
for k in pairs(path1) do
DBG('path1', acc1.path, type(k)=='table' and k[1].id or k)
end
DBG(acc2.cls.id, acc2, acc2.id, acc2.md, TP.toc(acc2.tp), acc2.any, acc2.err)
for k in pairs(path2) do
DBG('path2', acc2.path, type(k)=='table' and k[1].id or k)
end
DBG'==============='
]]
                if cls_ and org_ and id_ and (not c_)
                then
                    if OPTS.safety > 0 then
                        DBG('WRN : nondeterminism : '..acc1.err
                                ..' vs '..acc2.err)
                    end
                    ANA.ana.acc = ANA.ana.acc + 1
                end
            end
        end
    end
end

function _chk (n, id)
    for k in pairs(n) do
        if type(k)=='table' and k[1]==id then
            return true
        end
    end
    return false
end

-- TODO: join with CHK_ACC
-- emits vs rets/ors/breaks (the problem is that emits are considered in par)
function CHK_EXCPT (s1, s2, isOR)
    for _, ana in ipairs(s1.ana.accs) do
        if ana.md == 'tr' then
            if _chk(s2.ana.pos,ana.id) and isOR or -- terminates w/ same event
               s2.ana.pos[false] --or       -- ~terminates (return/break)
               --s2.ana.pos[true]                 -- terminates tight
            then
                if OPTS.warn_exception then
                    DBG('WRN : exception : line '..s2.ln[2]..' vs '..ana.err)
                end
                ANA.ana.excpt = ANA.ana.excpt + 1
                ana.node.emtChk = true
            end
        end
    end
end

G = {
-- take all emits from top-level PAR
    ParOr_pre = function (me)
        if ALL then
            return
        end
        ALL = {}
        for _, sub in ipairs(me) do
            for _,acc in ipairs(sub.ana.accs) do
                if acc.md == 'tr' then
                    ALL[acc] = true
                end
            end
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',

-- look for nondeterminism
    ParOr = function (me)
        for i=1, #me do
            for j=i+1, #me do

                -- holds invalid emits
                local NO_emts = {}
                for _,acc in ipairs(me[i].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
                for _,acc in ipairs(me[j].ana.accs) do
                    if acc.md == 'tr' then
                        NO_emts[acc] = true -- same trail (happens bef or aft)
                    end
                end
                for acc in pairs(ALL) do
                    if ANA.CMP(acc.path, me.ana.pre) then
                        NO_emts[acc] = true -- instantaneous emit
                    end
                end

                CHK_ACC(me[i].ana.accs, me[j].ana.accs,
                        me.ana.pre,
                        --ANA.union(me.ana.pre,me.ana.pos),
                        NO_emts)
                CHK_EXCPT(me[i], me[j], me.tag=='ParOr')
                CHK_EXCPT(me[j], me[i], me.tag=='ParOr')
            end
        end
    end,
    ParAnd  = 'ParOr',
    ParEver = 'ParOr',

-- TODO: workaround
    -- Loop can only be repeated after nested PARs evaluate CHK_*
    Loop = function (me)
        local _,_,_,body = unpack(me)
        -- pre = pre U pos
        if not body.ana.pos[false] then
            ANA.union(body, next(me.ana.pre), body.ana.pos)
        end
    end,
}

AST.visit(G)

end

    
do
function MAX_all (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            me.trails_n = MAX(me.trails_n, sub.trails_n)
        end
    end
end

F = {
    Node_pre = function (me)
        me.trails_n = 1
    end,
    Node_pos = function (me)
        if not F[me.tag] then
            MAX_all(me)
        end
    end,

    If = function (me)
        local c, t, f = unpack(me)
        MAX_all(me, {t,f})
    end,

    Dcl_cls = function (me)
        MAX_all(me)

        -- pointer to next org or parent/trail
        -- [ IN__ORG_UP/DOWN ]
        if me ~= MAIN then
            me.trails_n = me.trails_n + 1
        end

        ASR(me.trails_n < 256, me, 'too many trails')
    end,

    Block = function (me)
        MAX_all(me)

        -- [ CLR | ADT_I | ORG_STATS_I | ORG_POOL_I | ... | STMTS | FIN ]
        -- clear trail
        -- adt finalization
        -- pointer to contiguous static orgs
        -- pointers to each of the pools
        -- statements
        -- finalization
        -- STATS and POOL must interleave to respect execution order:
        -- var  T a;
        -- pool T ts;
        -- var  T b;
        -- First execute a, then all ts, then b.

        for i=1, #me.vars do
            local var = me.vars[i]

            if var.pre=='pool' then
                me.fins = me.fins or {}     -- release adts
            end

            if var.adt and var.pre=='pool' then
                me.trails_n = me.trails_n + 1
            elseif var.cls then
                me.trails_n = me.trails_n + 1   -- ORG_POOL_I/ORG_STATS_I
                var.trl_orgs_first = true       -- avoids repetition in initialization of STATS

                -- for STATS, unify all skipping all non-pool vars
                if var.pre ~= 'pool' then
                    for j=i+1, #me.vars do
                        local var2 = me.vars[j]
                        if var2.pre == 'pool' then
                            break
                        else
                            i = i + 1   -- skip on outer loop
                        end
                    end
                end
            end
        end

        if me.fins then
            -- implicit await in parallel
            me.trails_n = me.trails_n + 1
        end
    end,

    ParAnd  = 'ParOr',
    ParEver = 'ParOr',
    ParOr = function (me)
        me.trails_n = 0
        for _, sub in ipairs(me) do
            me.trails_n = me.trails_n + sub.trails_n
        end
    end,
}

AST.visit(F)

-------------------------------------------------------------------------------

function pred (n)
    return n.trails
end

G = {
    Root_pre = 'Dcl_cls_pre',
    Dcl_cls_pre = function (me)
        me.trails  = { 0, me.trails_n -1 }     -- [0, N]
    end,

    Node = function (me)
        if me.trails then
            return
        end
        me.trails  = AST.iter(pred)().trails
    end,

    Block_pre = function (me)
        local stmts = unpack(me)

        -- [ 1, 1, S, 1 ] (clr, org0, stmts, fin)

        me.trails = me.trails or AST.iter(pred)().trails

        local t0 = me.trails[1]

        -- [ ORG_STATS | ORG_POOL_I | STMTS | FIN ]
        -- pointer to all static orgs
        -- pointers to each of the pools
        -- statements
        -- finalization

        for i=1, #me.vars do
            local var = me.vars[i]

            if var.adt and var.pre=='pool' then
                var.trl_adt = { t0, t0 }
                t0 = t0 + 1

            elseif var.cls then
                var.trl_orgs = { t0, t0 }   -- ORG_POOL_I/ORG_STATS_I
                t0 = t0 + 1

                -- for STATS, unify all skipping all non-pool vars
                if var.pre ~= 'pool' then
                    for j=i+1, #me.vars do
                        local var2 = me.vars[j]
                        if var2.pre == 'pool' then
                            break
                        else
                            if var2.cls then
                                var2.trl_orgs = { t0-1, t0-1 }   -- ORG_STATS_I
                            end
                            i = i + 1   -- skip on outer loop
                        end
                    end
                end
            end
        end

        -- BLOCK
        stmts.trails = { t0, t0+stmts.trails_n-1 }
            t0 = t0 + stmts.trails_n    -- stmts

        -- FINS (must be the last to properly nest fins)
        if me.fins then
            me.trl_fins  = { t0, t0 }
                t0 = t0 + 1             -- fin
        end
    end,

    _Par_pre = function (me)
        me.trails = AST.iter(pred)().trails

        for i, sub in ipairs(me) do
            sub.trails = {}
            if i == 1 then
                sub.trails[1] = me.trails[1]
            else
                local pre = me[i-1]
                sub.trails[1] = pre.trails[1] + pre.trails_n
            end
            sub.trails[2] = sub.trails[1] + sub.trails_n  - 1
        end
    end,

    ParOr_pre   = '_Par_pre',
    ParAnd_pre  = '_Par_pre',
    ParEver_pre = '_Par_pre',
}

AST.visit(G)

end

    
do
LBLS = {
    list = {},      -- { [lbl]={}, [i]=lbl }
    code_enum = '',
    code_fins = '',
}

function new (lbl)
    if lbl[2] then
        lbl.id = lbl[1]
    else
        lbl.id = CLS().id..'_'..lbl[1]..'_'..#LBLS.list
    end
    lbl.id = string.gsub(lbl.id, '%*','')
    lbl.id = string.gsub(lbl.id, '%.','')
    lbl.id = string.gsub(lbl.id, '%$','')
    lbl.id = string.gsub(lbl.id, '%%','')
    LBLS.list[lbl] = true
    lbl.n = #LBLS.list                   -- starts from 0
    LBLS.list[#LBLS.list+1] = lbl

    for n in AST.iter() do
        if n.lbls_all then
            n.lbls_all[lbl] = true
        end
    end

    return lbl
end

F = {
    Node_pre = function (me)
        me.lbls = { #LBLS.list }
    end,
    Node = function (me)
        me.lbls[2] = #LBLS.list-1
    end,

    Root_pre = function (me)
        --new{'CEU_INACTIVE', true}
    end,
    Root = function (me)
        -- 0, 1,-1, tot,-tot
        -- <0 = off (for internal events)
        TP.types.tceu_nlbl.len  = TP.n2bytes(1+2 + #LBLS.list*2)

        -- enum of labels
        for i, lbl in ipairs(LBLS.list) do
            LBLS.code_enum = LBLS.code_enum..'    '
                                ..lbl.id..' = '..lbl.n..',\n'
        end

        -- labels which are finalizers
        local t = {}
        for _, lbl in ipairs(LBLS.list) do
            t[#t+1] = string.find(lbl.id,'__fin') and assert(lbl.__depth) or 0
        end
        LBLS.code_fins = table.concat(t,',')
    end,

    Block = function (me)
        local blk = unpack(me)

        if me.fins then
            me.lbl_fin = new{'Block__fin', __depth=me.__depth}
        end

        for _, var in ipairs(me.vars) do
            if var.adt and var.pre=='pool' then
                var.lbl_fin_kill_free = new{'adt_fin_kill_free'}
            end
        end
    end,

    Dcl_cls = function (me)
        if me.is_ifc then
            return
        end

        me.lbl = new{'Class_'..me.id, true}
-- TODO (-RAM)
        --if i_am_instantiable then
            me.lbl_clr = new{'Class_free_'..me.id}
        --end
    end,
    Spawn = function (me)
        me.lbls_cnt = new{me.tag..'_cont'}
    end,
    Kill = function (me)
        me.lbl = new{'Kill'}
    end,

    SetBlock_pre = function (me)
        me.lbl_out = new{'Set_out',  prio=me.__depth}
    end,

    Set = function (me)
        local _, set, _, to = unpack(me)
        if set=='adt-mut' or set=='adt-constr' then
            if PROPS.has_adts_watching[to.tp.id] then
                me.lbl_cnt = new{'Set_adt'}
            end
        end
    end,

    _Par_pre = function (me)
        me.lbls_in = {}
        for i, sub in ipairs(me) do
            if i > 1 then
                me.lbls_in[i] = new{me.tag..'_sub_'..i}
            end
        end
    end,
    ParEver_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParEver_out'}
    end,
    ParOr_pre = function (me)
        F._Par_pre(me)
        me.lbl_out = new{'ParOr_out',  prio=me.__depth}
    end,
    ParAnd_pre = function (me)
        F._Par_pre(me)
        me.lbl_tst = new{'ParAnd_chk'}
        me.lbl_out = new{'ParAnd_out'}
    end,

    Thread = function (me)
        me.lbl = new{'Thread'}
        me.lbl_out = new{'Thread_out'}
    end,
    Async = function (me)
        me.lbl = new{'Async'}
    end,

    Loop_pre = function (me)
        if AST.iter'Async'() then
            me.lbl_asy = new{'Async_cnt'}
        end
        if me.iter_tp == 'data' then
            me.lbl_rec = new{'Recurse'}
        end
    end,
    Recurse = function (me)
        me.lbl = new{'Recurse'}
    end,

    EmitExt = function (me)
        -- only async needs to break up (avoids stack growth)
        if AST.iter'Async'() then
            me.lbl_cnt = new{'Async_cont'}
        end
    end,
    EmitInt = function (me)
        me.lbl_cnt = new{'EmitInt_cont'}
    end,
    Dcl_var = function (me)
        if me.var.cls then
            me.lbls_cnt = new{'Start_cnt'}
        end
    end,

    Await = function (me)
        local e, dt = unpack(me)
        if dt then
            me.lbl = new{'Awake_DT'}
        else
            me.lbl = new{'Awake_'..(e.evt or e.var.evt).id}
        end
    end,

    ParOr_pos = function (me)
        if me.needs_clr then
            me.lbl_clr = new{'Clear'}
        end
    end,
    Block_pos    = 'ParOr_pos',
    Loop_pos     = 'ParOr_pos',
    SetBlock_pos = 'ParOr_pos',
}

AST.visit(F)

end

    
do
local VARS = {}

if not ANA then
    return          -- isTmp=false for all vars
end

F = {
    Dcl_var_pre = function (me)
        local var = me.var

        if var.cls then
            VARS = {}       -- org dcls eliminate all current possible tmps
            return
        end

        if var.pre~='var' or var.cls or var.inTop then
            return                  -- only normal vars can be tmp
        end

        VARS[var] = true
        if var.isTmp ~= false then  -- already preset as false
            var.isTmp = true
        end

        -- declarations inside ADTs are never temporary (always part of the data)
        if AST.par(me, 'Dcl_adt') then
            var.isTmp = false
            assert(not AST.par(me,'Dcl_fun'), 'bug found: mixing adt/fun')

        -- declarations inside functions are always temporary (no awaits inside)
        elseif AST.par(me, 'Dcl_fun') then
            var.isTmp = true
        end

        -- inside a recursive loop
        -- TODO: check if tmp is crossed by "recurse" (otherwise could be tmp)
        for loop in AST.iter'Loop' do
            if loop.iter_tp == 'data' then
error'not implemented (locals inside iter)'
                var.isTmp = false
                break;
            end
        end
    end,

    Var = function (me)
        local var = me.var

        -- uses inside threads
        local thr = AST.iter'Thread'()
        if thr then
            if me.var.blk.__depth < thr.__depth then
                var.isTmp = false
                return              -- defined outside: isTmp=false
            else
                return              -- defined inside: isTmp=true
            end
        end

        -- all function vars are "tmp"
        if AST.iter'Dcl_fun'() then
            return
        end

        -- only normal vars can be tmp
        if var.pre~='var' or var.cls then
            var.isTmp = false
            return
        end

        --[[
        --  var int i;
        --  var T[2] t with
        --      i = i + 1;      // "i" cannot be tmp
        --  end;
        --]]
        local constr = AST.par(me, 'Dcl_constr')
        if constr and (var.blk.__depth < constr.__depth) then
            local org = AST.par(me, 'Dcl_var')
            if org then
                local _, tp = unpack(org)
                if tp.arr then
                    var.isTmp = false
                end
            end
        end

        local glb = ENV.clss.Global
        if var.inTop or
            (var.blk==ENV.clss.Main.blk_ifc and glb and glb.is_ifc and
             glb.blk_ifc.vars[var.id])
        then
            var.isTmp = false
            return                  -- vars in interfaces cannot be tmp
        end

        local dcl = AST.iter'Dcl_var'()
        if dcl and dcl[1]==var.id then
            return                  -- my declaration is not an access
        end

        if me.__par.tag == 'SetBlock' then
            return                  -- set is performed on respective `return´
        end

        local v = VARS[var]

        local op = AST.iter'Op1_&'()
        local isRef = op and (op.base == me)

        local AwaitInt = function ()
            local n = AST.iter'Await'()
            return n and n[1].tag~='Ext'
        end

        if AST.iter'Finally'() or   -- finally executes through "call"
           AwaitInt() or            -- await ptr:a (ptr is tested on awake)
           isRef or                 -- reference may escape
           var.tp.arr               -- array may escape: TODO conservative
                                    -- (arrays as parameters)
        then
            var.isTmp = false
            VARS[var] = nil
            return
        end

        -- Not tmp if defined in the same block of an org:
        --      var T t;
        --      var int ret = 1;
        -- becomes
        --      var int ret;
        --      start t
        --      ret = 1;
        for _,oth in pairs(var.blk.vars) do
            if oth.cls then
                v = false
            end
        end

        if v == true then
            VARS[var] = me.ana.pre
            return                  -- first access
        end

        if not (v and ANA.CMP(v,me.ana.pre)) then
            var.isTmp = false       -- found a Par or Await in the path
            return
        end
    end,

    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        if e1.fst.var then
            e1.fst.var.isTmp = false    -- assigned to a pointer
        end
    end,
    Set = function (me)
        local _, _, fr = unpack(me)
        if me.__ref_byref and fr.fst.var then
            fr.fst.var.isTmp = false    -- assigned to a pointer
        end
    end,

    EmitNoTmp = 'EmitInt',
    EmitInt = function (me)
        VARS = {}   -- NO: run in different ceu_call
    end,
    EmitExt = function (me)
        local op, ext, param = unpack(me)
        local evt = ext.evt
        if evt.pre == 'input' then
            VARS = {}
        end
    end,

    Spawn_pre = function (me)
        VARS = {}   -- NO: start organism
    end,

    Loop_pre = function (me)
        local awaits = false
        AST.visit(
            {
                Await = function (me)
                    awaits = true
                end,
                AwaitN   = 'Await',
                EmitInt  = 'Await',
                Async    = 'Await',
                Thread   = 'Await',
                Spawn    = 'Await',
            },
            me)

        if ((not awaits) and (not AST.iter(AST.pred_async)())) or
            me.isAwaitUntil then
            return      -- OK: (tight loop outside Async) or (await ... until)
        end
        VARS = {}       -- NO: loop in between Dcl/Accs is dangerous
        --[[
            -- x is on the stack but may be written in two diff reactions
            -- a non-ceu code can reuse the stack in between
            input int E;
            var int x;
            loop do
                var int tmp = await E;
                if tmp == 0 then
                    break;
                end
                x = tmp;
            end
            return x;
        ]]
    end,
--[[
]]

    ParOr_pre = function (me)
        for var, v in pairs(VARS) do
            if v ~= true then
                VARS[var] = nil     -- remove previously accessed vars
            end
        end
    end,
    ParAnd_pre  = 'ParOr_pre',
    ParEver_pre = 'ParOr_pre',
    ParOr   = 'ParOr_pre',
    ParAnd  = 'ParOr_pre',
    ParEver = 'ParOr_pre',

    -- TODO: should pre's be already different?
    Async_pre = 'ParOr_pre',
    Async     = 'ParOr_pre',
}

AST.visit(F)

end

    
do
MEM = {
    tops = '',
    tops_init = '',
    native_pre = '',
}

function SPC ()
    return string.rep(' ',AST.iter()().__depth*2)
end

function pred_sort (v1, v2)
    return (v1.len or TP.types.word.len) > (v2.len or TP.types.word.len)
end

function CUR (me, id)
    if id then
        return '(('..TP.toc(CLS().tp)..'*)_STK_ORG)->'..id
    else
        return '(('..TP.toc(CLS().tp)..'*)_STK_ORG)'
    end
end

F = {
    Host = function (me)
        local pre, code = unpack(me)
        -- unescape `##´ => `#´
        local src = string.gsub(code, '^%s*##',  '#')
              src = string.gsub(src,   '\n%s*##', '\n#')
        CLS().native[pre] = CLS().native[pre] .. [[

#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]] .. src
    end,

    Dcl_adt_pre = function (me)
        local id, op = unpack(me)
        me.struct = 'typedef '
        me.auxs   = {}
        if op == 'union' then
            me.struct = me.struct..[[
struct CEU_]]..id..[[ {
    u8 tag;
    union {
]]
            me.enum = { 'CEU_NONE'..me.n }    -- reserves 0 to catch more bugs
        end

        me.auxs[#me.auxs+1] = [[
#ifdef CEU_ADTS_WATCHING_]]..id..[[

void CEU_]]..id..'_kill (tceu_app* _ceu_app, tceu_go* go, CEU_'..id..[[* me);
#endif
#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU_]]..id..'_free_dynamic (tceu_app* _ceu_app, CEU_'..id..[[* me);
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU_]]..id..'_free_static (tceu_app* _ceu_app, CEU_'..id..[[* me, void* pool);
#endif
#endif
]]
    end,
    Dcl_adt = function (me)
        local id, op = unpack(me)
        if op == 'union' then
            me.struct = me.struct .. [[
    };
}
]]
            me.enum = 'enum {\n'..table.concat(me.enum,',\n')..'\n};\n'
        else
            me.struct = string.sub(me.struct, 1, -3)    -- remove leading ';'
        end

        local kill = [[
#ifdef CEU_ADTS_WATCHING_]]..id..[[

void CEU_]]..id..'_kill (tceu_app* _ceu_app, tceu_go* go, CEU_'..id..[[* me) {
]]
        if op == 'union' then
            kill = kill .. [[
    switch (me->tag) {
]]
            for _, tag in ipairs(me.tags) do
                local id_tag = string.upper(id..'_'..tag)
                kill = kill .. [[
        case CEU_]]..id_tag..[[:
]]
                if me.is_rec and tag==me.tags[1] then
                    kill = kill .. [[
            /* base case */
]]
                else
                    kill = kill .. [[
            CEU_]]..id_tag..[[_kill(_ceu_app, go, me);
]]
                end
                kill = kill .. [[
            break;
]]
            end
            kill = kill .. [[
#ifdef CEU_DEBUG
        default:
            ceu_out_assert(0, "invalid tag");
#endif
    }
]]
        end
        kill = kill .. [[
}
#endif
]]

        local free = [[
#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void CEU_]]..id..'_free_dynamic (tceu_app* _ceu_app, CEU_'..id..[[* me) {
]]
        if op == 'struct' then
            free = free .. [[
    ceu_out_realloc(me, 0);
]]
        else
            assert(op == 'union')
            free = free .. [[
    switch (me->tag) {
]]
            for _, tag in ipairs(me.tags) do
                local id_tag = string.upper(id..'_'..tag)
                free = free .. [[
        case CEU_]]..id_tag..[[:
]]
                if me.is_rec and tag==me.tags[1] then
                    free = free .. [[
            /* base case */
]]
                else
                    free = free .. [[
            CEU_]]..id_tag..[[_free_dynamic(_ceu_app, me);
]]
                end
                free = free .. [[
            break;
]]
            end
            free = free .. [[
#ifdef CEU_DEBUG
        default:
            ceu_out_assert(0, "invalid tag");
#endif
    }
]]
        end
        free = free .. [[
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void CEU_]]..id..'_free_static (tceu_app* _ceu_app, CEU_'..id..[[* me, void* pool) {
]]
        if op == 'struct' then
            free = free .. [[
    ceu_pool_free(pool, (void*)me);
]]
        else
            assert(op == 'union')
            free = free .. [[
    switch (me->tag) {
]]
            for _, tag in ipairs(me.tags) do
                local id_tag = string.upper(id..'_'..tag)
                free = free .. [[
        case CEU_]]..id_tag..[[:
]]
                if me.is_rec and tag==me.tags[1] then
                    free = free .. [[
            /* base case */
]]
                else
                    free = free .. [[
            CEU_]]..id_tag..[[_free_static(_ceu_app, me, pool);
]]
                end
                free = free .. [[
            break;
]]
            end
            free = free .. [[
    }
]]
        end
        free = free .. [[
}
#endif
#endif
]]

        local pack = ''
        if me.tp.opt and (me.tp.opt.ptr>0 or me.tp.opt.ref) then
            local ID = string.upper(me.tp.id)
            local tp = 'CEU_'..me.tp.id
            local some = TP.toc(me[4][2][1][1][2])
-- TODO: OPT
            local cls = ENV.clss[string.sub(some,5,-2)]
            if cls and (not cls.is_ifc) then
                some = 'struct '..some      -- due to recursive spawn
            end
            pack = [[
]]..tp..[[ CEU_]]..ID..[[_pack (]]..some..[[ ptr) {
    ]]..tp..[[ ret;
    if (ptr == NULL) {
        ret.tag = CEU_]]..ID..[[_NIL;
    } else {
        ret.tag = CEU_]]..ID..[[_SOME;
        ret.SOME.v = ptr;
    }
    return ret;
}
]]..some..[[ CEU_]]..ID..[[_unpack (]]..tp..[[ me) {
    if (me.tag == CEU_]]..ID..[[_NIL) {
        return NULL;
    } else {
        return me.SOME.v;
    }
}
]]
        end

        me.auxs[#me.auxs+1] = kill
        me.auxs[#me.auxs+1] = free
        me.auxs[#me.auxs+1] = pack
        me.auxs   = table.concat(me.auxs,'\n')..'\n'
        me.struct = me.struct..' CEU_'..id..';'
        MEM.tops = MEM.tops..'\n'..(me.enum or '')..'\n'..
                                   me.struct..'\n'

        -- declare a static BASE instance
        if me.is_rec then
            MEM.tops = MEM.tops..[[
static CEU_]]..id..[[ CEU_]]..string.upper(id)..[[_BASE;
]]
            MEM.tops_init = MEM.tops_init .. [[
CEU_]]..string.upper(id)..[[_BASE.tag = CEU_]]..string.upper(id..'_'..me.tags[1])..[[;
]]
        end

        MEM.tops = MEM.tops..me.auxs..'\n'
    end,
    Dcl_adt_tag_pre = function (me)
        local top = AST.par(me, 'Dcl_adt')
        local id = unpack(top)
        local tag = unpack(me)
        local enum = 'CEU_'..string.upper(id)..'_'..tag
        top.enum[#top.enum+1] = enum
        -- _ceu_app is required because of OS/assert
        top.auxs[#top.auxs+1] = [[
CEU_]]..id..'* '..enum..'_assert (tceu_app* _ceu_app, CEU_'..id..[[* me, char* file, int line) {
    ceu_out_assert_ex(me->tag == ]]..enum..[[, "invalid tag", file, line);
    return me;
}
]]

        if top.is_rec and top.tags[1]==tag then
            return  -- base case, no free
        end

        local kill = [[
#ifdef CEU_ADTS_WATCHING_]]..id..[[

void ]]..enum..'_kill (tceu_app* _ceu_app, tceu_go* go, CEU_'..id..[[* me) {
]]
        -- kill all my recursive fields after myself (push them before)
        for _,item in ipairs(top.tags[tag].tup) do
            local _, tp, _ = unpack(item)
            if TP.tostr(tp) == id..'*' then
                kill = kill .. [[
    CEU_]]..id..[[_kill(_ceu_app, go, me->]]..tag..'.'..item.var_id..[[);
/*
    me->]]..tag..'.'..item.var_id..[[ = &CEU_]]..string.upper(id)..[[_BASE;
*/
]]
            end
        end

        -- kill myself before my recursive fields (push myself after)
        kill = kill .. [[
    {
        tceu_stk stk;
                 stk.evt  = CEU_IN__ok_killed;
    #ifdef CEU_ORGS
                 stk.org  = _ceu_app->data;
    #endif
                 stk.trl  = &_ceu_app->data->trls[0];
                 stk.stop = NULL;
                 stk.evt_sz = sizeof(me);
        stack_push(go, &stk, &me);
            /* param is pointer to what to kill */
    }
}
#endif
]]

        local free = [[
#ifdef CEU_ADTS_NEWS
#ifdef CEU_ADTS_NEWS_MALLOC
void ]]..enum..'_free_dynamic (tceu_app* _ceu_app, CEU_'..id..[[* me) {
]]

        -- free all my recursive fields
        for _,item in ipairs(top.tags[tag].tup) do
            local _, tp, _ = unpack(item)
            if TP.tostr(tp) == id..'*' then
                free = free .. [[
    CEU_]]..id..[[_free_dynamic(_ceu_app, me->]]..tag..'.'..item.var_id..[[);
]]
            end
        end

        -- free myself
        free = free .. [[
    ceu_out_realloc(me, 0);
}
#endif
#ifdef CEU_ADTS_NEWS_POOL
void ]]..enum..'_free_static (tceu_app* _ceu_app, CEU_'..id..[[* me, void* pool) {
]]

        -- free all my recursive fields
        for _,item in ipairs(top.tags[tag].tup) do
            local _, tp, _ = unpack(item)
            if TP.tostr(tp) == id..'*' then
                free = free .. [[
    CEU_]]..id..[[_free_static(_ceu_app, me->]]..tag..'.'..item.var_id..[[, pool);
]]
            end
        end

        -- free myself
        free = free .. [[
    ceu_pool_free(pool, (void*)me);
}
#endif
#endif
]]

        top.auxs[#top.auxs+1] = kill
        top.auxs[#top.auxs+1] = free
    end,

    Dcl_cls_pre = function (me)
        me.struct = [[
typedef struct CEU_]]..me.id..[[ {
  struct tceu_org org;
  tceu_trl trls_[ ]]..me.trails_n..[[ ];
]]
        me.native = { [true]='', [false]='' }
        me.funs = ''
    end,
    Dcl_cls_pos = function (me)
        if me.is_ifc then
            me.struct = 'typedef void '..TP.toc(me.tp)..';\n'

            -- interface full declarations must be delayed to after their impls
            -- TODO: HACK_4: delayed declaration until use

            local struct = [[
typedef union CEU_]]..me.id..[[_delayed {
]]
            for v_cls, v_matches in pairs(me.matches) do
                if v_matches and (not v_cls.is_ifc) then
                    -- ifcs have no size
                    if v_cls.id ~= 'Main' then  -- TODO: doesn't seem enough
                        struct = struct..'\t'..TP.toc(v_cls.tp)..' '..v_cls.id..';\n'
                    end
                end
            end
            struct = struct .. [[
} CEU_]]..me.id..[[_delayed;
]]
            me.__env_last_match.__delayed =
                (me.__env_last_match.__delayed or '') .. struct .. '\n'
        else
            me.struct  = me.struct..'\n} '..TP.toc(me.tp)..';\n'
        end

        -- native/pre goes before everything
        MEM.native_pre = MEM.native_pre ..  me.native[true]

        if me.id ~= 'Main' then
            -- native goes after class declaration
            MEM.tops = MEM.tops .. me.native[false] .. '\n'
        end
        MEM.tops = MEM.tops .. me.struct .. '\n'

        -- TODO: HACK_4: delayed declaration until use
        MEM.tops = MEM.tops .. (me.__delayed or '') .. '\n'

        MEM.tops = MEM.tops .. me.funs .. '\n'
--DBG('===', me.id, me.trails_n)
--DBG(me.struct)
--DBG('======================')
    end,

    Dcl_fun = function (me)
        local _, _, ins, out, id, blk = unpack(me)
        local cls = CLS()

        -- input parameters (void* _ceu_go->org, int a, int b)
        local dcl = { 'tceu_app* _ceu_app', 'tceu_org* __ceu_org' }
        for _, v in ipairs(ins) do
            local _, tp, id = unpack(v)
            dcl[#dcl+1] = TP.toc(tp)..' '..(id or '')
        end
        dcl = table.concat(dcl,  ', ')

        -- TODO: static?
        me.id = 'CEU_'..cls.id..'_'..id
        me.proto = [[
]]..TP.toc(out)..' '..me.id..' ('..dcl..[[)
]]
        if OPTS.os and ENV.exts[id] and ENV.exts[id].pre=='output' then
            -- defined elsewhere
        else
            cls.funs = cls.funs..'static '..me.proto..';\n'
        end
    end,

    Stmts_pre = function (me)
        local cls = CLS()
        if cls then
            cls.struct = cls.struct..SPC()..'union {\n'
        end
    end,
    Stmts_pos = function (me)
        local cls = CLS()
        if cls then
            cls.struct = cls.struct..SPC()..'};\n'
        end
    end,

    Block_pos = function (me)
        local top = AST.par(me,'Dcl_adt') or CLS()
        local tag = ''
        if top.tag == 'Dcl_adt' then
            local n = AST.par(me, 'Dcl_adt_tag')
            if n then
                tag = unpack(n)
            end
        end
        if me.__loop then
            top.struct = top.struct..SPC()..me.__loop..'\n'
        end
        top.struct = top.struct..SPC()..'} '..tag..';\n'
    end,
    Block_pre = function (me)
        local DCL = AST.par(me,'Dcl_adt') or CLS()

        DCL.struct = DCL.struct..SPC()..'struct { /* BLOCK ln='..me.ln[2]..' */\n'

        if DCL.tag == 'Dcl_cls' then
            for _, var in ipairs(me.vars) do
                if var.trl_orgs then
                    -- ORG_STATS (shared for sequential), ORG_POOL (unique for each)
                    var.trl_orgs.val = CUR(me, '__lnks_'..me.n..'_'..var.trl_orgs[1])
                end
            end
            if me.fins then
                for i, fin in ipairs(me.fins) do
                    fin.val = CUR(me, '__fin_'..me.n..'_'..i)
                    DCL.struct = DCL.struct .. SPC()
                                ..'u8 __fin_'..me.n..'_'..i..': 1;\n'
                end
            end
        end

        for _, var in ipairs(me.vars) do
            local len
            --if var.isTmp or var.pre=='event' then  --
            if var.isTmp then --
                len = 0
            elseif var.pre == 'event' then --
                len = 1   --
            elseif var.pre=='pool' and (not var.tp.ref) and (type(var.tp.arr)=='table') then
                len = 10    -- TODO: it should be big
            elseif var.cls or var.adt then
                len = 10    -- TODO: it should be big
                --len = (var.tp.arr or 1) * ?
            elseif var.tp.arr then
                len = 10    -- TODO: it should be big
--[[
                local _tp = TP.deptr(var.tp)
                len = var.tp.arr * (TP.deptr(_tp) and TP.types.pointer.len
                             or (ENV.c[_tp] and ENV.c[_tp].len
                                 or TP.types.word.len)) -- defaults to word
]]
            elseif var.tp.ptr>0 or var.tp.ref then
                len = TP.types.pointer.len
            else
                len = ENV.c[var.tp.id].len
            end
            var.len = len
        end

        -- sort offsets in descending order to optimize alignment
        -- TODO: previous org metadata
        local sorted = { unpack(me.vars) }
        if me~=DCL.blk_ifc and DCL.tag~='Dcl_adt' then
            table.sort(sorted, pred_sort)   -- TCEU_X should respect lexical order
        end

        for _, var in ipairs(sorted) do
            local tp
            if var.tp.opt then
                tp = TP.toc(var.tp.opt)     -- int? becomes CEU_Opt_...
            else
                tp = TP.toc(var.tp)
            end

            if var.inTop then
                var.id_ = var.id
                    -- id's inside interfaces are kept (to be used from C)
            else
                var.id_ = var.id .. '_' .. var.n
                    -- otherwise use counter to avoid clash inside struct/union
            end

            if DCL.id == var.tp.id then
                tp = 'struct '..tp  -- for types w/ pointers for themselves
            end

            if var.pre=='var' and (not var.isTmp) then
                local dcl = [[
#line ]]..var.ln[2]..' "'..var.ln[1]..[["
]]
                local cls = ENV.clss[var.tp.id]
-- TODO: OPT
                if cls and (not cls.is_ifc) and (DCL.id ~= var.tp.id) then
                    dcl = dcl..'struct ' -- due to recursive spawn
                end
                if var.tp.arr then
                    local tp = string.sub(tp,1,-2)  -- remove leading `*´
                    dcl = dcl .. tp..' '..var.id_..'['..var.tp.arr.cval..']'
                else
                    dcl = dcl .. tp..' '..var.id_
                end
                DCL.struct = DCL.struct..SPC()..'  '..dcl..';\n'
            elseif var.pre=='pool' then
                local adt = ENV.adts[var.tp.id]
                local cls = ENV.clss[var.tp.id]
                local top = adt or cls

                -- ADT:
                -- tceu_adt_root id = { root=?, pool=_id };
                -- CEU_POOL_DCL(_id);
                if adt then
                    assert(var.tp.ptr <= 1, 'bug found')
                    local ptr = (var.tp.ref and '*') or ''
                    DCL.struct = DCL.struct .. [[
/*
 * REF:
 * tceu_adt_root* x;  // root/pool always the same as the parent
 * PTR:
 * tceu_adt_root x;   // pool: the same // root: may point to the middle
 */
tceu_adt_root]]..ptr..' '..var.id_..[[;
]]
                end

                -- static pool: "var T[N] ts"
                if (var.adt or var.cls) and type(var.tp.arr)=='table' then
                    local ID = (adt and '_' or '') .. var.id_  -- _id for ADT pools
                    if top.is_ifc then
                        DCL.struct = DCL.struct .. [[
CEU_POOL_DCL(]]..ID..',CEU_'..var.tp.id..'_delayed,'..var.tp.arr.sval..[[)
]]
                               -- TODO: bad (explicit CEU_)
                    else
                        DCL.struct = DCL.struct .. [[
CEU_POOL_DCL(]]..ID..',CEU_'..var.tp.id..','..var.tp.arr.sval..[[)
]]
                               -- TODO: bad (explicit CEU_)
                    end
                elseif (not adt) then   -- (top_pool or cls)
                    -- ADT doesn't require this NULL pool field
                    --  (already has root->pool=NULL)
                    if var.tp.ptr>0 or var.tp.ref then
                        local ptr = string.rep('*', (var.tp.ref and 1 or 0) + var.tp.ptr)
                        DCL.struct = DCL.struct .. [[
tceu_pool_]]..ptr..' '..var.id_..[[;
]]
                    else
                        DCL.struct = DCL.struct .. [[
tceu_pool_ ]]..var.id_..[[;
]]
                    end
                end
            end

            -- pointers ini/end to list of orgs
            if var.cls then
                DCL.struct = DCL.struct .. SPC() ..
                   'tceu_org_lnk __lnks_'..me.n..'_'..var.trl_orgs[1]..'[2];\n'
                    -- see val.lua for the (complex) naming
            end
        end
    end,

    ParOr_pre = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'struct {\n'
    end,
    ParOr_pos = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'};\n'
    end,
    ParAnd_pre = 'ParOr_pre',
    ParAnd_pos = 'ParOr_pos',
    ParEver_pre = 'ParOr_pre',
    ParEver_pos = 'ParOr_pos',

    ParAnd = function (me)
        local cls = CLS()
        for i=1, #me do
            cls.struct = cls.struct..SPC()..'u8 __and_'..me.n..'_'..i..': 1;\n'
        end
    end,

    Loop = function (me)
        if not me.__recs then
            return
        end
error'not implemented'

        -- `recurse´ stack
        -- TODO: no cls space if no awaits inside the loop (use local C var)
        local max,iter,_,_ = unpack(me)

        if max then
            me.iter_max = max.cval
        else
            local adt = ENV.adts[iter.tp.id]
            if adt then
                local tp  = iter.lst.var.tp
                local arr = tp.arr
                if (not tp.arr) and (not tp.ref) then
                    me.iter_max = iter.lst.var.n_cons * adt.n_recs
                elseif type(arr)=='table' then
                    me.iter_max = arr.cval * adt.n_recs
                else
                    error'not implemented: unbounded iter'
                end
            else
                error'not implemented: unbounded iter'
            end
        end

        me.iter_max = me.iter_max * me.__recs
        AST.par(me, 'Block').__loop = [[
int          __recurse_nxt_]]..me.n..[[;    /* TODO: int (minimum type) */
tceu_recurse __recurse_vec_]]..me.n..'['..me.iter_max..']'..[[;
]]
            -- TODO: reason about the maximum space (it's less than the above!)
    end,
--[[
    Recurse = function (me)
        local loop = AST.par(me,'Loop')
        loop.__recs = (loop.__recs or 0) + 1
                      -- stack is a multiple of inner recurses
    end,
]]

    Await = function (me)
        local _, dt = unpack(me)
        if dt then
            local cls = CLS()
            cls.struct = cls.struct..SPC()..'s32 __wclk_'..me.n..';\n'
        end
    end,

    Thread_pre = 'ParOr_pre',
    Thread = function (me)
        local cls = CLS()
        cls.struct = cls.struct..SPC()..'CEU_THREADS_T __thread_id_'..me.n..';\n'
        cls.struct = cls.struct..SPC()..'s8*       __thread_st_'..me.n..';\n'
    end,
    Thread_pos = 'ParOr_pos',
}

AST.visit(F)

end

    
do
local _ceu2c = { ['or']='||', ['and']='&&', ['not']='!' }
local function ceu2c (op)
    return _ceu2c[op] or op
end

local F

function V (me, ...)
    local CTX = ...
    if type(CTX) ~= 'table' then
        CTX = {}
        for _, ctx in ipairs{...} do
            assert(type(ctx)=='string', 'bug found')
            CTX[ctx] = true
        end
    end

    local f = assert(F[me.tag], 'bug found : V('..me.tag..')')
    while type(f) == 'string' do
        f = assert(F[f], 'bug found : V('..me.tag..')')
    end

    local VAL = f(me, CTX)

    return string.gsub(VAL, '^%(%&%(%*(.-)%)%)$', '(%1)')
            -- (&(*(...))) => (((...)))
end

F =
{
    -- TODO: rewrite it all
    -- called by Var, Field, Dcl_var
    __var = function (me, VAL, CTX)
        local cls = (me.org and me.org.cls) or CLS()
        local var = me.var or me
        if var.pre == 'var' then
            if var.tp.arr then
                -- normalize all arrays acesses to pointers to arr[0]
                -- (because of interface accesses that must be done through a pointer)
                VAL = '(&'..VAL..'[0])'
            elseif var.cls then
                -- normalize all org acesses to pointers to it
                -- (because of interface accesses that must be done through a pointer)
                VAL = '(&'..VAL..')'
            elseif var.tp.opt then
            elseif var.tp.ref then
                if ENV.clss[var.tp.id] then
                    -- orgs vars byRef, do nothing
                    -- (normalized to pointer)
                else
                    -- normal vars byRef
                    VAL = '(*('..VAL..'))'
                end
            end

            -- variable with option type (var tp? id)
            if var.tp.opt then
                local ID = string.upper(var.tp.opt.id)
                local op = (var.tp.ref and '*') or ''

                if CTX.opt_raw then
                    return VAL
                end

                -- set
                local set = AST.par(me, 'Set')
                local _, to, fr, is_to, are_both_opt
                if set then
                    _, _, fr, to = unpack(set)
                    is_to = (to.lst.var == var)
                    is_fr = (fr.lst.var == var)
                    are_both_opt = (to.tp.opt and fr.tp.opt)
                end

                -- call
                local call = AST.par(me, 'Op2_call')
                call = call and call.tp.id=='@' and call
                if call then
                    local _,_,params = unpack(call)
                    call = false
                    for _, p in ipairs(params) do
                        --if TP.contains(p.tp,me.tp) and (p.lst==me) then
                        if TP.contains(p.tp,var.tp) and (p==me) then
                            call = true
                            break
                        end
                    end
                end

                -- check
                local check = AST.par(me,'Op1_?')

                -- SET
                if are_both_opt then
                    -- do nothing, both are opt
                elseif is_to then
                    if (fr.fst.tag=='Op2_call' and fr.fst.__fin_opt_tp)
                    or (fr.tag=='Spawn')
                    then
                        -- var _t&? = _f(...);
                        -- var T*? = spawn <...>;
                        VAL = '('..op..'('..VAL..'))'
                    else
                        -- xxx.me = v
                        if CTX.byref or (not me.tp.ref) then
                            VAL = '('..op..'('..VAL..'.SOME.v))'
                        else
                            VAL = '('..op..'(CEU_'..ID..'_SOME_assert(_ceu_app, &'
                                        ..VAL..',__FILE__,__LINE__)->SOME.v))'
                        end
                    end

                -- CALL
                -- _f(xxx.me)
                elseif call and me.tp.ref then
                    -- reference option type -> pointer
                    -- var tp&? v;
                    -- _f(v);
                    --      - NULL,   if v==nil
                    --      - SOME.v, if v!=nil
                    VAL = '(CEU_'..ID..'_unpack('..VAL..'))'

                -- CHECK
                -- ? xxx.me
                elseif check then
                    VAL = '('..VAL..'.tag)'
                        -- TODO: optimization: "tp&?" => 'NULL'

                -- NONE
                else
                    -- ... xxx.me ...
                    VAL = '('..op..'(CEU_'..ID..'_SOME_assert(_ceu_app, &'
                                ..VAL..',__FILE__,__LINE__)->SOME.v))'
                end
            end
        elseif var.pre == 'pool' then
            -- normalize all pool acesses to pointers to it
            -- (because of interface accesses that must be done through a pointer)
            if ENV.adts[var.tp.id] then
                if CTX.adt_pool then
                    VAL = '((tceu_pool_*)&'..VAL..')'
                elseif CTX.adt_root then
                    if var.tp.ref then
                        VAL = '('..VAL..')'
                    else
                        VAL = '(&'..VAL..')'
                    end
                else
                    local cast = ((CTX.lval and '') or '(CEU_'..var.tp.id..'*)')
                    if var.tp.ref then
                        VAL = '('..cast..'('..VAL..')->root)'
                    else
                        VAL = '('..cast..'('..VAL..').root)'
                    end
                end
            elseif not (var.tp.ptr>0 or var.tp.ref) then
                VAL = '(&'..VAL..')'
                VAL = '((tceu_pool_*)'..VAL..')'
            end
        elseif var.pre == 'function' then
            VAL = 'CEU_'..cls.id..'_'..var.id
        elseif var.pre == 'isr' then
            VAL = 'CEU_'..cls.id..'_'..var.id
        elseif var.pre == 'event' then
            assert(CTX.ifc_idx)
            return var.evt.idx
        elseif var.pre == 'output' then
            VAL = nil
        elseif var.pre == 'input' then
            VAL = nil
        else
            error 'not implemented'
        end

        local ref = me.tp and me.tp.ref and me.tp.id
        if CTX.byref and (not CTX.opt_raw) and
            (not (ENV.clss[me.tp.id] or (ref and ENV.clss[ref]) or
                  ENV.adts[me.tp.id] or (ref and ENV.adts[ref]) or
                  me.tp.id=='@'))
                 -- already by ref
        then
            VAL = '(&'..VAL..')'
        end

        return VAL
    end,

    Dcl_var = 'Var',
    Var = function (me, CTX)
        local var = me.var
        local VAL

        -- TODO: move to __var
        if CTX.adt_pool then
            VAL = CUR(me, '_'..var.id_)
        elseif var.isTmp then
            VAL = '__ceu_'..var.id..'_'..var.n
        else
            VAL = CUR(me, var.id_)
        end

        local field = AST.par(me, 'Field')
        if not (field and field[3]==me) then
            VAL = F.__var(me, VAL, CTX)
        end

        return VAL
    end,

    Field = function (me, CTX)
        local gen = '((tceu_org*)'..V(me.org)..')'
        if me.org.cls and me.org.cls.is_ifc then
            if me.var.pre == 'var'
            or me.var.pre == 'pool' then
                if me.var.tp.arr or me.var.pre=='pool' then
                    VAL = [[(
(]]..TP.toc(me.var.tp)..[[) (
    ((byte*)]]..V(me.org)..[[) + _CEU_APP.ifcs_flds[]]..gen..[[->cls][
        ]]..ENV.ifcs.flds[me.var.ifc_id]..[[
    ]
))]]
                else
                    VAL = [[(*(
(]]..TP.toc(me.var.tp.opt or me.var.tp)..[[*) (
    ((byte*)]]..V(me.org)..[[) + _CEU_APP.ifcs_flds[]]..gen..[[->cls][
        ]]..ENV.ifcs.flds[me.var.ifc_id]..[[
    ]
        )
))]]
                    if me.var.tp.ref and (not ENV.clss[me.var.tp.id]) and (not me.var.tp.opt) then
                        VAL = '(*'..VAL..')'
                    end
                end
            elseif me.var.pre == 'function' then
                VAL = [[(*(
(]]..TP.toc(me.var.tp)..[[*) (
    _CEU_APP.ifcs_funs[]]..gen..[[->cls][
        ]]..ENV.ifcs.funs[me.var.ifc_id]..[[
    ]
        )
))]]
            elseif me.var.pre == 'event' then
                assert(CTX.ifc_idx)
                return '(_CEU_APP.ifcs_evts['..gen..'->cls]['
                                ..ENV.ifcs.evts[me.var.ifc_id]
                           ..'])'
            else
                error 'not implemented'
            end

            if me.var.tp.opt then
                VAL = F.__var(me, VAL, CTX)
            end
        else
            if me.c then
                VAL = me.c.id_
            else
                assert(me.var, 'bug found')
                VAL = '('..V(me.org)..'->'..me.var.id_..')'
                VAL = F.__var(me, VAL, CTX)
            end
        end
        return VAL
    end,

    ----------------------------------------------------------------------

    Adt_constr_one = function (me)
        return me.val   -- set by hand in code.lua
    end,

    ----------------------------------------------------------------------

    Global = function (me)
        return '(_ceu_app->data)'
    end,

    Outer = function (me)
        return '(('..TP.toc(me.tp)..'*)_STK_ORG)'
    end,

    This = function (me)
        local VAL
        if AST.iter'Dcl_constr'() then
            VAL = '__ceu_org'    -- set when calling constr
        else
            VAL = '_STK_ORG'
        end
        return '(('..TP.toc(me.tp)..'*)'..VAL..')'
    end,

    ----------------------------------------------------------------------

    Op2_call = function (me)
        local _, f, exps = unpack(me)
        local ps = {}
        if f.var and f.var.fun then
            -- (tceu_app*, tceu_org*, ...)
            ps[#ps+1] = '_ceu_app'
            if f.org then
                ps[#ps+1] = V(f.org)   -- only native
            else
                ps[#ps+1] = CUR(me)
            end
            ps[#ps] = '(tceu_org*)'..ps[#ps]
        end
        for i, exp in ipairs(exps) do
            ps[#ps+1] = V(exp)
        end
        VAL = V(f)..'('..table.concat(ps,',')..')'

        if me.__fin_opt_tp then
            VAL = '(CEU_'..string.upper(me.__fin_opt_tp.opt.id)..'_pack('..VAL..'))'
        end
        return VAL
    end,

    Op2_idx = function (me)
        local _, arr, idx = unpack(me)
        local VAL = V(arr)..'['..V(idx)..']'
        if me.tp.ptr==0 and ENV.clss[me.tp.id] then
            VAL = '(&'..VAL..')'
                -- class accesses must be normalized to references
        end
        return VAL
    end,

    Op2_any = function (me)
        local op, e1, e2 = unpack(me)
        return '('..V(e1)..ceu2c(op)..V(e2)..')'
    end,
    ['Op2_-']   = 'Op2_any',
    ['Op2_+']   = 'Op2_any',
    ['Op2_%']   = 'Op2_any',
    ['Op2_*']   = 'Op2_any',
    ['Op2_/']   = 'Op2_any',
    ['Op2_|']   = 'Op2_any',
    ['Op2_&']   = 'Op2_any',
    ['Op2_<<']  = 'Op2_any',
    ['Op2_>>']  = 'Op2_any',
    ['Op2_^']   = 'Op2_any',
    ['Op2_==']  = 'Op2_any',
    ['Op2_!=']  = 'Op2_any',
    ['Op2_>=']  = 'Op2_any',
    ['Op2_<=']  = 'Op2_any',
    ['Op2_>']   = 'Op2_any',
    ['Op2_<']   = 'Op2_any',
    ['Op2_or']  = 'Op2_any',
    ['Op2_and'] = 'Op2_any',

    Op1_any = function (me)
        local op, e1 = unpack(me)
        return '('..ceu2c(op)..V(e1)..')'
    end,
    ['Op1_~']   = 'Op1_any',
    ['Op1_-']   = 'Op1_any',
    ['Op1_+']   = 'Op1_any',
    ['Op1_not'] = 'Op1_any',

    ['Op1_*'] = function (me)
        local op, e1 = unpack(me)
        if ENV.clss[me.tp.id] and e1.tp.ptr==1 then
            return V(e1) -- class accesses should remain normalized to references
        else
            return '('..ceu2c(op)..V(e1)..')'
        end
    end,
    ['Op1_&'] = function (me)
        local op, e1 = unpack(me)
        if ENV.clss[e1.tp.id] and e1.tp.ptr==0 then
            return V(e1) -- class accesses are already normalized to references
        else
            return '('..ceu2c(op)..V(e1)..')'
        end
    end,
    ['Op1_?'] = function (me)
        local op, e1 = unpack(me)
        return '('..V(e1)..' != CEU_'..string.upper(e1.tp.opt.id)..'_NIL)'
    end,

    ['Op2_.'] = function (me, CTX)
        local op, e1, id = unpack(me)
        local VAL
        if me.__env_tag then
            local tag = e1.tp.id and ('CEU_'..string.upper(e1.tp.id)..'_'..id)
            if me.__env_tag == 'test' then
                VAL  = '('..V(e1)..'.'..'tag == '..tag..')'
            elseif me.__env_tag == 'assert' then
                VAL  = '('..tag..'_assert(_ceu_app, &'..V(e1)..', __FILE__, __LINE__)'..'->'..id..')'
                --VAL  = '('..tag..'_assert('..V(e1)..')'..ceu2c(op)..id..')'
            elseif me.__env_tag == 'field' then
                if e1.union_tag_blk.vars[id].tp.ref and (me.tp.ref==false) then
                    VAL  = '('..'*('..V(e1)..')'..'.'..id..')'
                else
                    VAL  = '('..V(e1)..'.'..id..')'
                end
            end
        else
            VAL  = '('..V(e1)..'.'..id..')'
            if CTX.byref then
                VAL = '(&'..VAL..')'
            end
        end
        return VAL
    end,

    Op1_cast = function (me)
        local tp, exp = unpack(me)
        local VAL = V(exp)

        local cls = tp.ptr==1 and ENV.clss[tp.id]
        if cls then
            if cls.is_ifc then
                -- TODO: out of bounds acc
                VAL = '(('..VAL..' == NULL) ? NULL : '..
                        '((_CEU_APP.ifcs_clss[((tceu_org*)'..VAL..')->cls]'
                            ..'['..cls.n..']) ?'..VAL..' : NULL)'..
                      ')'
            else
                VAL = '(('..VAL..' == NULL) ? NULL : '..
                        '((((tceu_org*)'..VAL..')->cls == '..cls.n..') ? '
                        ..VAL..' : NULL)'..
                      ')'
            end
        end

        return '(('..TP.toc(tp)..')'..VAL..')'
    end,

    ----------------------------------------------------------------------

    WCLOCKK = function (me)
        return '((s32)'..me.us..')'
    end,

    WCLOCKE = function (me)
        local exp, unit = unpack(me)
        return '((s32)'.. V(exp) .. ')*' .. SVAL.t2n[unit]
    end,

    RawExp = function (me)
        return (unpack(me))
    end,

    Type = function (me)
        return TP.toc(me)
    end,

    Nat = function (me)
        return string.sub(me[1], 2)
    end,
    SIZEOF = function (me)
        local tp = unpack(me)
        return 'sizeof('..V(tp)..')'
    end,
    STRING = function (me)
        return me[1]
    end,
    NUMBER = function (me)
        return me[1]
    end,
    NULL = function (me)
        return 'NULL'
    end,
}

end

    
do
CODE = {
    has_goto  = false,   -- avoids "unused label"
    pres      = '',
    constrs   = '',
    threads   = '',
    functions = '',
    stubs     = '',     -- maps input functions to ceu_app_call switch cases
}

-- Assert that all input functions have bodies.
local INPUT_FUNCTIONS = {
    -- F1 = false,  -- input function w/o body
    -- F2 = true,   -- input functino w/  body
}

function CONC_ALL (me, t)
    t = t or me
    for _, sub in ipairs(t) do
        if AST.isNode(sub) then
            CONC(me, sub)
        end
    end
end

function CONC (me, sub, tab)
    sub = sub or me[1]
    tab = string.rep(' ', tab or 0)
    me.code = me.code .. string.gsub(sub.code, '(.-)\n', tab..'%1\n')
end

function CASE (me, lbl)
    LINE(me, 'case '..lbl.id..':;', 0)
end

function DEBUG_TRAILS (me, lbl)
    LINE(me, [[
#ifdef CEU_DEBUG_TRAILS
#ifndef CEU_OS
printf("\tOK!\n");
#endif
#endif
]])
end

function LINE (me, line, spc)
    spc = spc or 4
    spc = string.rep(' ', spc)
    me.code = me.code .. [[

#line ]]..me.ln[2]..' "'..me.ln[1]..[["
]] .. spc..line
end

function HALT (me, ret, cond)
    if cond then
        LINE(me, 'if ('..cond..') {')
    end
    --LINE(me, '\tgoto _CEU_NEXT_;')
    if ret then
        LINE(me, '\treturn '..ret..';')
    else
        LINE(me, '\treturn RET_HALT;')
    end
    if cond then
        LINE(me, '}')
    end
end

function GOTO (me, lbl)
    CODE.has_goto = true
    LINE(me, [[
_CEU_LBL = ]]..lbl..[[;
goto _CEU_GOTO_;
]])
end

function AWAIT_PAUSE (me, no)
    if not PROPS.has_pses then
        return
    end

    for pse in AST.iter'Pause' do
        COMM(me, 'PAUSE: '..pse.dcl.var.id)
        LINE(me, [[
if (]]..V(pse.dcl)..[[) {
    goto ]]..no..[[;
}
]])
    end
end

function COMM (me, comm)
    LINE(me, '/* '..comm..' */', 0)
end

local _iter = function (n)
    if n.tag == 'Block' and n.needs_clr then
        return true
    end

    if n.tag == 'SetBlock' and n.needs_clr then
        return true
    end

    if n.tag == 'Loop' and n.needs_clr then
        return true
    end

    n = n.__par
    if n and (n.tag == 'ParOr') then
        return true     -- par branch
    end
end

-- TODO: check if all calls are needed
--          (e.g., cls outermost block should not!)
function CLEAR_BEF (me)
    COMM(me, 'CLEAR: '..me.tag..' ('..me.ln[2]..')')

    if ANA and me.ana.pos[false] then
        return
    end
    if not me.needs_clr then
        return
    end

--[[
    -- TODO: put it back!
    -- check if top will clear during same reaction
    if (not me.needs_clr_fin) and ANA then   -- fin must execute before any stmt
        local top = AST.iter(_iter)()
        if top and ANA.CMP(top.ana.pos, me.ana.pos) then
            return  -- top will clear
        end
    end
]]

    LINE(me, [[
return ceu_out_clear(_ceu_go, ]]..me.lbl_clr.id..[[, _STK_ORG,
                     &_STK_ORG->trls[ ]]..(me.trails[1])  ..[[ ],
                     &_STK_ORG->trls[ ]]..(me.trails[2]+1)..[[ ]);
]])
end

function CLEAR_AFT (me)
    if ANA and me.ana.pos[false] then
        return
    end
    if not me.needs_clr then
        return
    end
    LINE(me, [[
case ]]..me.lbl_clr.id..[[:;

/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_STK->trl = &_STK_ORG->trls[ ]] ..me.trails[1]..[[ ];
]])
end


-- attributions/constructors need access to the pool
-- the pool is the first "e1" that matches adt type:
-- l = new List.CONS(...)
-- ^-- first
-- l:CONS.tail = new List.CONS(...)
-- ^      ^-- matches, but not first
-- ^-- first
local function FIND_ADT_POOL (fst)
    local adt = ENV.adts[fst.tp.id]
    if adt and (fst.tp.arr or fst.tp.ptr==1 or fst.tp.ref) then
        return fst
    else
        assert(fst.__par, 'bug found')
        return FIND_ADT_POOL(fst.__par)
    end
end

F = {
    Node_pre = function (me)
        me.code = '/* NODE: '..me.tag..' '..me.n..' */\n'
    end,

    Do         = CONC_ALL,
    Finally    = CONC_ALL,

    Dcl_constr = function (me)
        CONC_ALL(me)
        CODE.constrs = CODE.constrs .. [[
static void _ceu_constr_]]..me.n..[[ (tceu_app* _ceu_app, tceu_org* __ceu_org, tceu_go* _ceu_go) {
]] .. me.code .. [[
}
]]
    end,

    Stmts = function (me)
        LINE(me, '{')   -- allows C declarations for Spawn
        CONC_ALL(me)
        LINE(me, '}')
    end,

    Root = function (me)
        for _, cls in ipairs(ENV.clss_cls) do
            me.code = me.code .. cls.code_cls
        end

        -- functions and threads receive __ceu_org as parameter
        --   and do not require _ceu_go
        CODE.functions = string.gsub(CODE.functions, '_STK_ORG', '__ceu_org')
        CODE.threads   = string.gsub(CODE.threads,   '_STK_ORG', '__ceu_org')

        -- assert that all input functions have bodies
        for evt, v in pairs(INPUT_FUNCTIONS) do
            ASR(v, evt.ln, 'missing function body')
        end
    end,

    BlockI = CONC_ALL,
    BlockI_pos = function (me)
        -- Interface constants are initialized from outside
        -- (another _ceu_go_org), need to use __ceu_org instead.
        me.code_ifc = string.gsub(me.code, '_STK_ORG', '__ceu_org')
        me.code = ''
    end,

    Dcl_fun = function (me)
        local _, _, ins, out, id, blk = unpack(me)
        if blk then
            if me.var.fun.isExt then
                local ps = {}
                assert(ins.tup, 'bug found')
                for i, _ in ipairs(ins) do
                    ps[#ps+1] = '(('..TP.toc(ins)..'*)((void*)param))->_'..i
                end
                ps = (#ps>0 and ',' or '')..table.concat(ps, ',')

                CODE.functions = CODE.functions .. [[
#define ceu_in_call_]]..id..[[(app,org,param) ]]..me.id..[[(app,org ]]..ps..[[)
]]

                local ret_value, ret_void
                if TP.toc(out) == 'void' then
                    ret_value = '('
                    ret_void  = 'return NULL;'
                else
                    ret_value = 'return ((void*)'
                    ret_void  = ''
                end

                CODE.stubs = CODE.stubs .. [[
case CEU_IN_]]..id..[[:
#line ]]..me.ln[2]..' "'..me.ln[1]..[["
    ]]..ret_value..me.id..'(_ceu_app, _ceu_app->data '..ps..[[));
]]..ret_void..'\n'
            end
            CODE.functions = CODE.functions ..
                me.proto..'{'..blk.code..'}'..'\n'
        end

        -- assert that all input functions have bodies
        local evt = ENV.exts[id]
        if me.var.fun.isExt and evt and evt.pre=='input' then
            INPUT_FUNCTIONS[evt] = INPUT_FUNCTIONS[evt] or blk or false
        end
    end,
    Return = function (me)
        local exp = unpack(me)
        LINE(me, 'return '..(exp and V(exp) or '')..';')
    end,

    Dcl_cls_pos = function (me)
        me.code_cls = me.code
        me.code     = ''        -- do not inline in enclosing class
    end,
    Dcl_cls = function (me)
        if me.is_ifc then
            CONC_ALL(me)
            return
        end
        if me.has_pre then
            CODE.pres = CODE.pres .. [[
static void _ceu_pre_]]..me.n..[[ (tceu_app* _ceu_app, tceu_org* __ceu_org) {
]] .. me.blk_ifc[1][1].code_ifc .. [[
}
]]
        end

        CASE(me, me.lbl)

        -- TODO: move to _ORG? (MAIN does not call _ORG)
        LINE(me, [[
#ifdef CEU_IFCS
_STK_ORG->cls = ]]..me.n..[[;
#endif
]])

        CONC_ALL(me)

        if ANA and me.ana.pos[false] then
            return      -- never reachable
        end

        -- might need "free"

        LINE(me, [[
#ifdef CEU_ORGS
{
    tceu_stk stk;
             stk.evt    = CEU_IN__CLEAR;
             stk.cnt    = NULL;
             stk.org    = _STK_ORG;
             stk.trl    = &_STK_ORG->trls[0];
             stk.stop   = _STK_ORG;
             stk.evt_sz = 0;

#ifdef CEU_ORGS_NEWS
/* HACK_9:
 * If the stack top is the initial spawn state of the organism, it means that 
 * the organism terminated on start and the spawn must return NULL.
 * In this case, we mark it with "CEU_IN__NONE" to be recognized in the spawn 
 * continuation below.
 */
if (_STK->evt==CEU_IN__STK && _STK->org==_STK_ORG
    && _STK->trl==&_STK_ORG->trls[0]
    && _STK->stop==&_STK_ORG->trls[_STK_ORG->n]
    ) {
    _STK->evt = CEU_IN__NONE;
    ceu_out_stack_clear_org(_ceu_go, _STK_ORG, stack_curi(_ceu_go));
        /* remove all but me (HACK_9) */
} else {
    ceu_out_stack_clear_org(_ceu_go, _STK_ORG, stack_nxti(_ceu_go));
        /* remove all */
}
#endif

    stack_push(_ceu_go, &stk, NULL);
}
#endif
]])

        -- stop
        if me == MAIN then
            HALT(me, 'RET_QUIT')
        else
            HALT(me, 'RET_RESTART')
        end

        --[[
        -- TODO-RESEARCH-2:
        -- When an organism dies naturally, some pending traversals might
        -- remain in the stack with dangling pointers to the released organism:
        --
        --  class T with
        --  do
        --      par/or do
        --          // aborts and terminates the organism
        --      with
        --          // continuation is cleared but still has to be traversed
        --      end
        --  end
        --
        -- The "stack_clear_org" modifies all pending traversals to the
        -- organism to go in sequence.
        --
        -- Alternatives:
        --      - TODO: currently not organism in sequence, but restart from Main
        --          (#if 0/1 above and in ceu_stack_clear_org)
        --      - ?
        --]]
    end,

    -- TODO: C function?
    _ORG = function (me, t)
        COMM(me, 'start org: '..t.id)

        --[[
class T with
    <PRE>           -- 1    org: me.lbls_pre[i].id
    var int v = 0;
do
    <BODY>          -- 3    org: me.lbls_body[i].id
end

<...>               -- 0    parent:

var T t with
    <CONSTR>        -- 2    org: no lbl (cannot call anything)
end;

<CONT>              -- 4    parent: me.lbls_cnt.id
]]

        -- ceu_out_org, _ceu_constr_
        local org = t.arr and '((tceu_org*) &'..t.val..'['..t.val_i..']'..')'
                           or '((tceu_org*) '..t.val..')'
        -- each org has its own trail on enclosing block
        if t.arr then
            LINE(me, [[
for (]]..t.val_i..[[=0; ]]..t.val_i..'<'..t.arr.sval..';'..t.val_i..[[++)
{
]])     end
        LINE(me, [[
    /* resets org memory and starts org.trail[0]=Class_XXX */
    ceu_out_org(_ceu_app, ]]..org..','..t.cls.trails_n..','..t.cls.lbl.id..[[,
#ifdef CEU_ORGS_NEWS
                ]]..t.isDyn..[[,
#endif
                _STK_ORG, ]] ..t.lnks..[[);
/* TODO: currently idx is always "1" for all interfaces access because pools 
 * are all together there. When we have separate trls for pools, we'll have to 
 * indirectly access the offset in the interface. */
]])
        if t.cls.has_pre then
            LINE(me, [[
    _ceu_pre_]]..t.cls.n..[[(_ceu_app, ]]..org..[[);
]])
        end
        if t.constr then
            LINE(me, [[
    _ceu_constr_]]..t.constr.n..[[(_ceu_app, ]]..org..[[, _ceu_go);
]])
        end
        LINE(me, [[
    return ceu_out_org_spawn(_ceu_go, ]]..me.lbls_cnt.id..','..org..','..t.cls.lbl.id..[[);
case ]]..me.lbls_cnt.id..[[:;
]])
        if t.arr then
            LINE(me, [[
}
]])
        end
    end,

    Dcl_var = function (me)
        local _,_,_,constr = unpack(me)
        local var = me.var
        if var.cls then
            F._ORG(me, {
                id     = var.id,
                isDyn  = 0,
                cls    = var.cls,
                val    = V(me),
                constr = constr,
                arr    = var.tp.arr,
                val_i  = var.tp.arr and V({tag='Var',var=var.constructor_iterator}),
                lnks   = '&_STK_ORG->trls['..var.trl_orgs[1]..'].lnks'
            })
        elseif var.tp.opt then
            -- initialize optional types to nil
            local ID = string.upper(var.tp.opt.id)
            LINE(me, [[
]]..V(me,'opt_raw')..[[.tag = CEU_]]..ID..[[_NIL;
]])
        end
    end,

    Adt_constr_root = function (me)
        local dyn, one = unpack(me)

        LINE(me, '{')

        local set = assert(AST.par(me,'Set'), 'bug found')
        local _,_,_,to = unpack(set)

        if not dyn then
            CONC(me, one)
            F.__set(me, one, to)
        else
            local set = assert(AST.par(me,'Set'), 'bug found')
            F.__set_adt_mut_conc_fr(me, set, one)
        end

        LINE(me, '}')
    end,

    ExpList = CONC_ALL,
    Adt_constr_one = function (me)
        local adt, params = unpack(me)
        local id, tag = unpack(adt)
        adt = assert(ENV.adts[id])

        local root = AST.par(me, 'Adt_constr_root')

        -- CODE-1: declaration, allocation
        -- CODE-2: all children
        -- CODE-3: assignment
        --          { requires all children }

        me.val = '__ceu_adt_'..me.n

        -- CODE-1
        if not adt.is_rec then
            -- CEU_T t;
            LINE(me, [[
CEU_]]..id..' '..me.val..[[;
]])
        else
            -- CEU_T* t;
            LINE(me, [[
CEU_]]..id..'* '..me.val..[[;
]])

            -- base case
            if adt.is_rec and tag==adt.tags[1] then
                LINE(me,
me.val..' = &CEU_'..string.upper(id)..[[_BASE;
]])

            -- other cases
            else
                local tp = 'CEU_'..id

                -- extract pool from set
                --      to.x.y = new z;
                -- i.e.,
                --      to.root.pool
                local set = assert( AST.par(me,'Set'), 'bug found' )
                local _,_,_,to = unpack(set)
                local pool = FIND_ADT_POOL(to.fst)
                pool = '('..V(pool,'adt_root')..'->pool)'

                LINE(me, [[
#if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (]]..pool..[[ == NULL) {
    ]]..me.val..[[ = (]]..tp..[[*) ceu_out_realloc(NULL, sizeof(]]..tp..[[));
} else {
    ]]..me.val..[[ = (]]..tp..[[*) ceu_pool_alloc((tceu_pool*)]]..pool..[[);
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
    ]]..me.val..[[ = (]]..tp..[[*) ceu_out_realloc(NULL, sizeof(]]..tp..[[));
#elif defined(CEU_ADTS_NEWS_POOL)
    ]]..me.val..[[ = (]]..tp..[[*) ceu_pool_alloc((tceu_pool*)]]..pool..[[);
#endif
]])

                -- fallback to base case if fails
                LINE(me, [[
if (]]..me.val..[[ == NULL) {
    ]]..me.val..[[ = &CEU_]]..string.upper(id)..[[_BASE;
} else  /* rely on {,} that follows */
]])
            end
        end

        LINE(me, '{')   -- will ignore if allocation fails

        -- CODE-2
        CONC(me, params)

        -- CODE-3
        local op = (adt.is_rec and '->' or '.')
        local blk,_
        if tag then
            -- t->tag = TAG;
            if not (adt.is_rec and tag==adt.tags[1]) then
                -- not required for base case
                LINE(me, me.val..op..'tag = CEU_'..string.upper(id)..'_'..tag..';')
            end
            blk = ENV.adts[id].tags[tag].blk
            tag = tag..'.'
        else
            _,_,blk = unpack(ENV.adts[id])
            tag = ''
        end
        for i, p in ipairs(params) do
            local field = blk.vars[i]
            LINE(me, me.val..op..tag..field.id..' = '..V(p)..';')
        end

        LINE(me, '}')   -- will ignore if allocation fails
    end,

    Kill = function (me)
        local org, exp = unpack(me)
        if exp then
            LINE(me, [[
((tceu_org*)]]..V(org)..')->ret = '..V(exp)..[[;
]])
        end
        LINE(me, [[
{
    tceu_org* __ceu_org = (tceu_org*)]]..V(org)..[[;
    return ceu_out_clear(_ceu_go, ]]..me.lbl.id..[[, __ceu_org,
                             &__ceu_org->trls[0],
                             __ceu_org);
}

case ]]..me.lbl.id..[[:;
]])
    end,

    Spawn = function (me)
        local id, pool, constr = unpack(me)
        local ID = '__ceu_new_'..me.n
        local set = AST.par(me, 'Set')

        LINE(me, [[
/*{*/
    tceu_org* ]]..ID..[[;
]])
        if pool and (type(pool.var.tp.arr)=='table') then
            -- static
            LINE(me, [[
    ]]..ID..[[ = (tceu_org*) ceu_pool_alloc((tceu_pool*)]]..V(pool)..[[);
]])
        elseif pool.var.tp.ptr>0 or pool.var.tp.ref then
            -- pointer don't know if is dynamic or static
            LINE(me, [[
#if !defined(CEU_ORGS_NEWS_MALLOC)
    ]]..ID..[[ = (tceu_org*) ceu_pool_alloc((tceu_pool*)]]..V(pool)..[[);
#elif !defined(CEU_ORGS_NEWS_POOL)
    ]]..ID..[[ = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_]]..id..[[));
#else
    if (]]..V(pool)..[[->queue == NULL) {
        ]]..ID..[[ = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_]]..id..[[));
    } else {
        ]]..ID..[[ = (tceu_org*) ceu_pool_alloc((tceu_pool*)]]..V(pool)..[[);
    }
#endif
]])
        else
            -- dynamic
            LINE(me, [[
    ]]..ID..[[ = (tceu_org*) ceu_out_realloc(NULL, sizeof(CEU_]]..id..[[));
]])
        end

        if set then
            local set_to = set[4]
            LINE(me, V(set_to)..' = '..
                '('..string.upper(TP.toc(set_to.tp.opt))..'_pack('..
                    '((CEU_'..id..'*)__ceu_new_'..me.n..')));')
        end

        LINE(me, [[
    if (]]..ID..[[ != NULL) {
]])

        if pool and (type(pool.var.tp.arr)=='table') or
           PROPS.has_orgs_news_pool or OPTS.os then
            LINE(me, [[
        ]]..ID..[[->pool = (tceu_pool_*)]]..V(pool)..[[;
]])
        end

        local org = '_STK_ORG'
        if pool and pool.org then
            org = '((tceu_org*)'..V(pool.org)..')'
        end

        F._ORG(me, {
            id     = 'dyn',
            isDyn  = 1,
            cls    = me.cls,
            val    = ID,
            constr = constr,
            arr    = false,
            lnks   = '(((tceu_pool_*)'..V(pool)..')->lnks)',
        })
        LINE(me, [[
    }
/*}*/
]])
        if set then
            local set_to = set[4]
            LINE(me, [[
/* HACK_9: see above */
if (]]..V(set_to)..[[.tag != ]]..string.upper(TP.toc(set_to.tp.opt))..[[_NIL) {
    tceu_stk* stk = stack_nxt(_ceu_go);
    if (stk->evt == CEU_IN__NONE) {
        ]]..V(set_to)..' = '..              
            string.upper(TP.toc(set_to.tp.opt))..[[_pack(NULL);
    }
}
]])
        end

    end,

    Block_pre = function (me)
        local cls = CLS()
        if (not cls) or cls.is_ifc then
            return
        end

        if me.fins then
            LINE(me, [[
/*  FINALIZE */
_STK_ORG->trls[ ]]..me.trl_fins[1]..[[ ].evt   = CEU_IN__CLEAR;
_STK_ORG->trls[ ]]..me.trl_fins[1]..[[ ].lbl   = ]]..me.lbl_fin.id..[[;
]])
            for _, fin in ipairs(me.fins) do
                LINE(me, fin.val..' = 0;')
            end
        end

        -- declare tmps
        -- initialize pools
        -- initialize ADTs base cases
        -- initialize Optional types to NIL
        LINE(me, '{')       -- close in Block_pos
        for _, var in ipairs(me.vars) do
            if var.isTmp then
                -- TODO: join with code in "mem.lua" for non-tmp vars
                local tp = var.tp.opt or var.tp -- int? becomes CEU_Opt_...
                if tp.arr then
                    local tp_ = TP.toc(tp)
                    local tp_ = string.sub(TP.toc(tp),1,-2)  -- remove leading `*´
                    LINE(me, tp_..' '..var.id_..'['..tp.arr.cval..']')
                else
                    LINE(me, TP.toc(tp)..' __ceu_'..var.id..'_'..var.n)
                end
                if var.isFun then
                    -- function parameter
                    -- __ceu_a = a
                    LINE(me, ' = '..var.id)
                end
                LINE(me, ';')
            elseif var.pre=='pool' and (var.cls or var.adt) then
                -- real pool (not reference or pointer)
                local cls = var.cls
                local adt = var.adt
                local top = cls or adt
                local static = (type(var.tp.arr)=='table')

                if top or var.tp.id=='_TOP_POOL' then
                    local id = (adt and '_' or '') .. var.id_
                    local dcl = '&'..CUR(me, id)

                    local lnks = (var.trl_orgs and var.trl_orgs[1]) or 'NULL'
                    if lnks ~= 'NULL' then
                        lnks = '&_STK_ORG->trls['..lnks..'].lnks'
                    end

                    if static then
                        if top.is_ifc then
                            LINE(me, [[
ceu_pool_init(]]..dcl..','..var.tp.arr.sval..',sizeof(CEU_'..var.tp.id..'_delayed),'..lnks..','
    ..'(byte**)'..dcl..'_queue, (byte*)'..dcl..[[_mem);
]])
                        else
                            LINE(me, [[
ceu_pool_init(]]..dcl..','..var.tp.arr.sval..',sizeof(CEU_'..var.tp.id..'),'..lnks..','
    ..'(byte**)'..dcl..'_queue, (byte*)'..dcl..[[_mem);
]])
                        end
                    elseif cls or var.tp.id=='_TOP_POOL' then
                        LINE(me, [[
(]]..dcl..[[)->lnks  = ]]..lnks..[[;
(]]..dcl..[[)->queue = NULL;            /* dynamic pool */
]])
                    end
                end

                -- real pool
                if adt and adt.is_rec then
                    -- create base case NIL and assign to "*l"
                    local tag = unpack( AST.asr(adt,'Dcl_adt', 3,'Dcl_adt_tag') )
                    local tp = 'CEU_'..adt.id
                    LINE(me, [[
{
    ]]..tp..[[* __ceu_adt;
]])
                    -- base case: use preallocated static variable
                    if adt.is_rec and tag==adt.tags[1] then
                        LINE(me, [[
    __ceu_adt = &CEU_]]..string.upper(adt.id)..[[_BASE;
]])

                    -- other cases: must allocate
                    else
                        error'bug found'
                    end

                    local VAL_root = V({tag='Var',var=var}, 'adt_root')
                    local VAL_pool = V({tag='Var',var=var}, 'adt_pool')
                    if static then
                        LINE(me, [[
    ]]..VAL_root..[[->pool = ]]..VAL_pool..[[;
]])
                    else
                        LINE(me, [[
#ifdef CEU_ADTS_NEWS_POOL
    ]]..VAL_root..[[->pool = NULL;
#endif
]])
                    end
                    LINE(me, [[
    ]]..VAL_root..[[->root = __ceu_adt;
}
/*  FINALIZE ADT */
_STK_ORG->trls[ ]]..var.trl_adt[1]..[[ ].evt   = CEU_IN__CLEAR;
_STK_ORG->trls[ ]]..var.trl_adt[1]..[[ ].lbl   = ]]..(var.lbl_fin_kill_free).id..[[;
]])
                end
            end

            -- initialize trails for ORG_STATS_I & ORG_POOL_I
            -- "first" avoids repetition for STATS in sequence
            -- TODO: join w/ ceu_out_org (removing start from the latter?)
            if var.trl_orgs and var.trl_orgs_first then
                LINE(me, [[
#ifdef CEU_ORGS
ceu_out_org_trail(_STK_ORG, ]]..var.trl_orgs[1]..[[, (tceu_org_lnk*) &]]..var.trl_orgs.val..[[);
#endif
]])
            end
        end
    end,

    Block_pos = function (me)
        local stmts = unpack(me)
        local cls = CLS()
        if (not cls) or cls.is_ifc then
            return
        end

        -- TODO: try to remove this requirement
        if me.trails[1] ~= stmts.trails[1] then
            LINE(me, [[
/* switch to blk trail */
_STK->trl = &_STK_ORG->trls[ ]]..stmts.trails[1]..[[ ];
]])
        end
        CONC(me, stmts)
        CLEAR_BEF(me)

        if me.fins then
            LINE(me, [[
{
    int __ceu_from_fin;         /* separate dcl/set because of C++ */
    __ceu_from_fin = 0;         /* skip HALT */
    if (0) {
]])
            CASE(me, me.lbl_fin)
            LINE(me, [[
        __ceu_from_fin = 1;         /* stop on HALT */
    }
]])
            for i, fin in ipairs(me.fins) do
                LINE(me, [[
    if (]]..fin.val..[[) {
        ]] .. fin.code .. [[
    }
]])
            end
            LINE(me, [[
    if (__ceu_from_fin) {
        return RET_HALT;
    }
}
]])
        end

        -- release ADT pool items
        for _, var in ipairs(me.vars) do
            if var.adt and var.adt.is_rec then
                local id, op = unpack(var.adt)
                local static = (type(var.tp.arr)=='table')
                CASE(me, var.lbl_fin_kill_free)

                local VAL      = V({tag='Var',var=var})
                local VAL_root = V({tag='Var',var=var}, 'adt_root')
                if PROPS.has_adts_watching[var.adt.id] then
                    LINE(me, [[
#if 0
"kill" only while in scope
CEU_]]..id..[[_kill(_ceu_app, _ceu_go, ]]..VAL..[[);
#endif
]])
                end
                if static then
                    local pool = '('..VAL_root..'->pool)'
                    LINE(me, [[
CEU_]]..id..[[_free_static(_ceu_app, ]]..VAL..','..pool..[[);
]])
                else
                    LINE(me, [[
CEU_]]..id..[[_free_dynamic(_ceu_app, ]]..VAL..[[);
]])
                end
                HALT(me)
            end
        end

        CLEAR_AFT(me)
        LINE(me, '}')       -- open in Block_pre
    end,

    Pause = CONC_ALL,
    -- TODO: meaningful name
    PauseX = function (me)
        local psed = unpack(me)
        LINE(me, [[
ceu_pause(&_STK_ORG->trls[ ]]..me.blk.trails[1]..[[ ],
          &_STK_ORG->trls[ ]]..me.blk.trails[2]..[[ ],
        ]]..psed..[[);
]])
    end,

    -- TODO: more tests
    Op2_call_pre = function (me)
        local _, f, exps, fin = unpack(me)
        if fin and fin.active then
            LINE(AST.iter'Stmts'(), fin.val..' = 1;')
        end
    end,
    Finalize = function (me)
        -- enable finalize
        local set,fin = unpack(me)
        if fin.active then
            LINE(me, fin.val..' = 1;')
        end
        if set then
            CONC(me, set)
        end
    end,

    __set_adt_mut_conc_fr = function (me, SET, fr)
        local _,set,_,to = unpack(SET)

        local pool = FIND_ADT_POOL(to.fst)
        pool = '('..V(pool,'adt_root')..'->pool)'

        LINE(me, [[
{
    void* __ceu_old = ]]..V(to)..[[;    /* will kill/free old */
]])

        if set ~= 'adt-constr' then
            -- remove "fr" from tree (set parent link to NIL)
            LINE(me, [[
    void* __ceu_new = ]]..V(fr)..[[;
    ]]..V(fr)..[[ = &CEU_]]..string.upper(fr.tp.id)..[[_BASE;
    ]]..V(to,'lval')..[[ = __ceu_new;
]])
        end

        if PROPS.has_adts_watching[to.tp.id] then
            LINE(me, [[
/* save the continuation to run after the kills */
_STK->trl->evt = CEU_IN__STK;
_STK->trl->lbl = ]]..SET.lbl_cnt.id..[[;
_STK->trl->stk = stack_curi(_ceu_go);

CEU_]]..to.tp.id..[[_kill(_ceu_app, _ceu_go, __ceu_old);
]])
        end

        LINE(me, [[
                /* TODO: parameter restored here */
#if defined(CEU_ADTS_NEWS_MALLOC) && defined(CEU_ADTS_NEWS_POOL)
if (]]..pool..[[ == NULL) {
    CEU_]]..to.tp.id..[[_free_dynamic(_ceu_app, __ceu_old);
} else {
    CEU_]]..to.tp.id..[[_free_static(_ceu_app, __ceu_old, ]]..pool..[[);
}
#elif defined(CEU_ADTS_NEWS_MALLOC)
CEU_]]..to.tp.id..[[_free_dynamic(_ceu_app, __ceu_old);
#elif defined(CEU_ADTS_NEWS_POOL)
CEU_]]..to.tp.id..[[_free_static(_ceu_app, __ceu_old, ]]..pool..[[);
#endif
}
]])

        -- must allocate after the free
        CONC(me, fr)
        if set == 'adt-constr' then
            LINE(me, [[
]]..V(to,'lval')..' = '..V(fr)..[[;
]])
        end

        if PROPS.has_adts_watching[to.tp.id] then
            LINE(me, [[
return RET_RESTART;
case ]]..SET.lbl_cnt.id..[[:;
]])
        end
    end,

    __set = function (me, fr, to)
        local byref = (me.__ref_byref and 'byref') or ''

        -- optional types
        if to.tp.opt then
            local ID = string.upper(to.tp.opt.id)
            if fr.tp.opt then
                LINE(me, V(to,byref)..' = '..V(fr,byref)..';')
            elseif (fr.fst.tag=='Op2_call' and fr.fst.__fin_opt_tp) then
                -- var _t&? = _f(...);
                -- var T*? = spawn <...>;
                LINE(me, V(to,byref)..' = '..V(fr)..';')
            else
                local tag
                if fr.tag == 'NIL' then
                    tag = 'NIL'
                else
                    tag = 'SOME'
                    LINE(me, V(to,byref)..' = '..V(fr,byref)..';')
                end
                LINE(me, V(to,'opt_raw')..'.tag = CEU_'..ID..'_'..tag..';')
            end

        -- normal types
        else
            LINE(me, V(to,'lval',byref)..' = '..V(fr,byref)..';')
        end

        if to.tag=='Var' and to.var.id=='_ret' then
            assert(byref == '', 'bug found')
            if CLS().id == 'Main' then
                LINE(me, [[
#ifdef CEU_RET
    _ceu_app->ret = ]]..V(to)..[[;
#endif
]])
            else
                LINE(me, [[
#ifdef CEU_ORGS_WATCHING
    _STK_ORG->ret = ]]..V(to)..[[;
#endif
]])
            end
        end
    end,

    Set = function (me)
        local _, set, fr, to = unpack(me)
        COMM(me, 'SET: '..tostring(to[1]))    -- Var or C

        if set == 'exp' then
            CONC(me, fr)                -- TODO: remove?
            F.__set(me, fr, to)

        elseif set == 'adt-alias' then
            CONC(me, fr)                -- TODO: remove?

            --[[
            -- PTR:
            --      l = list:TAG.field;
            -- becomes
            --      l.pool = list.pool
            --      l.root = list:TAG.field
            -- REF:
            --      l = list;
            -- becomes
            --      l = &list
            --]]

            local pool = FIND_ADT_POOL(fr.fst)
            if to.var.pre == 'pool' then
                if to.var.tp.ref then
                    LINE(me, [[
]]..V(to,'lval','adt_root')..' = '..V(fr,'adt_root')..[[;
]])
                else
                    LINE(me, [[
#ifdef CEU_ADTS_NEWS_POOL
]]..V(to,'lval','adt_root')..'->pool = '..V(pool,'adt_root')..[[->pool;
#endif
]]..V(to,'lval','adt_root')..'->root = '..V(fr)..[[;
]])
                end

            else
                -- normal pointer (not pool)
                LINE(me, [[
]]..V(to,'lval')..' = '..V(fr)..[[;
]])
            end

        elseif set == 'adt-mut' then
            F.__set_adt_mut_conc_fr(me, me, fr)

        else
            CONC(me, fr)
        end
    end,

    SetBlock_pos = function (me)
        local blk,_ = unpack(me)
        CONC(me, blk)
        HALT(me)        -- must escape with `escape´
        CASE(me, me.lbl_out)
        if me.has_escape then
            CLEAR_BEF(me)
            CLEAR_AFT(me)
        end
    end,
    Escape = function (me)
        GOTO(me, AST.iter'SetBlock'().lbl_out.id)
    end,

    _Par = function (me)
        -- Ever/Or/And spawn subs
        COMM(me, me.tag..': spawn subs')
        for i, sub in ipairs(me) do
            if i > 1 then
                LINE(me, [[
{
    /* mark all trails to start (1st runs immediatelly) */
    tceu_trl* trl = &_STK_ORG->trls[ ]]..sub.trails[1]..[[ ];
    trl->evt = CEU_IN__STK;
    trl->lbl = ]]..me.lbls_in[i].id..[[;
    trl->stk = stack_curi(_ceu_go);   /* awake in the same level as we are now */
#ifdef CEU_DEBUG
    ceu_out_assert(trl > _STK->trl, "bug found");
#endif
}
]])
            end
        end
    end,

    ParEver = function (me)
        F._Par(me)
        for i, sub in ipairs(me) do
            if i > 1 then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)

            -- only if trail terminates
            if not sub.ana.pos[false] then
                HALT(me)
            end
        end
    end,

    ParOr_pos = function (me)
        F._Par(me)
        for i, sub in ipairs(me) do
            if i > 1 then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)

            if not (ANA and sub.ana.pos[false]) then
                COMM(me, 'PAROR JOIN')
                GOTO(me, me.lbl_out.id)
            end
        end

        if not (ANA and me.ana.pos[false]) then
            CASE(me, me.lbl_out)
            CLEAR_BEF(me)
            CLEAR_AFT(me)
        end
    end,

    ParAnd = function (me)
        -- close AND gates
        COMM(me, 'close ParAnd gates')

        local val = CUR(me, '__and_'..me.n)

        for i=1, #me do
            LINE(me, val..'_'..i..' = 0;')
        end

        F._Par(me)

        for i, sub in ipairs(me) do
            if i > 1 then
                CASE(me, me.lbls_in[i])
            end
            CONC(me, sub)
            LINE(me, val..'_'..i..' = 1;')
            GOTO(me, me.lbl_tst.id)
        end

        -- AFTER code :: test gates
        CASE(me, me.lbl_tst)
        for i, sub in ipairs(me) do
            HALT(me, nil, '!'..val..'_'..i)
        end

        LINE(me, [[
/* switch to 1st trail */
/* TODO: only if not joining with outer prio */
_STK->trl = &_STK_ORG->trls[ ]]..me.trails[1]..[[ ];
]])
    end,

    If = function (me)
        local c, t, f = unpack(me)
        -- TODO: If cond assert(c==ptr or int)

        LINE(me, [[
if (]]..V(c)..[[) {
]]    ..t.code..[[
} else {
]]    ..f.code..[[
}
]])
    end,

--[=[
    Recurse = function (me)
        local exp = unpack(me)
        local loop = AST.par(me, 'Loop')
        local _,_,to,_ = unpack(loop)

        -- vec[top].lbl  = <lbl-continuation>
        -- vec[top].data = <cur-to>
        -- top++;
        local nxt = CUR(me,'__recurse_nxt_'..loop.n)
        local vec = CUR(me,'__recurse_vec_'..loop.n)..'['..nxt..']'
        LINE(me, [[
ceu_out_assert_ex(]]..nxt..' < '..loop.iter_max..[[,
    "loop overflow", __FILE__, __LINE__);
]]..vec..'.lbl  = '..me.lbl.id..[[;
]]..vec..'.data = '..V(to)..[[;
]]..nxt..[[++;
]])

        -- <cur-to> = <exp>
        -- next;
        LINE(me, V(to)..' = '..V(exp)..';')
        GOTO(me, loop.lbl_rec.id)

        CASE(me, me.lbl)
    end,
]=]

    Loop_pos = function (me)
        local max,iter,to,body = unpack(me)
        local no = '_CEU_NO_'..me.n..'_'

        local ini, nxt = {}, {}
        local cnd = ''

        if me.i_var then
            ini[#ini+1] = V(me.i_var)..' = 0'
            nxt[#nxt+1] = V(me.i_var)..'++'
        end

        if iter then
            if me.iter_tp == 'event' then
                -- nothing to do

            elseif me.iter_tp == 'number' then
                cnd = V(me.i_var)..' < '..V(iter)

            elseif me.iter_tp == 'org' then
                -- INI
                local var = iter.lst.var

                local org_cur = '((tceu_org*)'..V(to)..')'
                local org_nxt = '('..V(me.var_nxt)..'.org)'

                local lnks = '(((tceu_pool_*)'..V(iter)..')->lnks)'
                ini[#ini+1] = V(to)..[[ = (]]..TP.toc(iter.tp)..[[)(
    ((*]]..lnks..[[)[0].nxt->n == 0) ?
        NULL :    /* marks end of linked list */
        (*]]..lnks..[[)[0].nxt
)
]]
                ini[#ini+1] = org_nxt..' = '..
                                '('..org_cur..'==NULL || '..
                                     org_cur..'->nxt->n==0) ?'..
                                        'NULL : '..
                                        org_cur..'->nxt'
                    -- assign to "nxt" before traversing "cur":
                    --  "cur" may terminate and be freed

                -- CND
                cnd = '('..V(to)..' != NULL)'

                -- NXT
                nxt[#nxt+1] = V(to)..' = ('..TP.toc(to.tp)..')'..org_nxt
                nxt[#nxt+1] = org_nxt..' = '..
                                '('..org_cur..'==NULL || '..org_cur..'->nxt->n==0) ?  '..
                                    'NULL : '..
                                    org_cur..'->nxt'

            elseif me.iter_tp == 'data' then
error'bug found'
                local nxt = CUR(me,'__recurse_nxt_'..me.n)
                local vec = CUR(me,'__recurse_vec_'..me.n)..'['..nxt..']'
                ini[#ini+1] = V(to)..' = '..V(iter)     -- initial pointer
                ini[#ini+1] = nxt..' = 0'               -- reset stack
                ini[#ini+1] = vec..'.lbl = 0'           -- initial dummy element
                ini[#ini+1] = nxt..'++'                 -- not empty

            else
                error'not implemented'
            end
        end

        ini = table.concat(ini, ', ')
        nxt = table.concat(nxt, ', ')

        -- ensures that cval is constant
        if max then
            LINE(me, 'int __'..me.n..'['..max.cval..'] = {};')
        end

        if me.iter_tp == 'org' then
            LINE(me, [[
ceu_pool_iterator_enter(&]]..V(me.var_nxt)..[[);
]])
        end

        LINE(me, [[
for (]]..ini..';'..cnd..';'..nxt..[[) {
]])
        if me.iter_tp == 'data' then
error'not implemented'
            local nxt = CUR(me,'__recurse_nxt_'..me.n)
            local vec = CUR(me,'__recurse_vec_'..me.n)..'['..nxt..']'
            LINE(me, [[
if (]]..nxt..[[ > 0) {
    ]]..nxt..[[--;
    if (]]..vec..[[.lbl == 0) {
        /* initial dummy element, do nothing */
    } else {
        ]]..V(to)..[[ = ]]..vec..[[.data;
]])
        GOTO(me, vec..'.lbl')
            LINE(me, [[
    }
} else {
    break;
}
]])
            CASE(me, me.lbl_rec)
        end

        if max then
            LINE(me, [[
    ceu_out_assert_ex(]]..V(me.i_var)..' < '..V(max)..[[,
        "loop overflow", __FILE__, __LINE__);
]])
        end

        CONC(me,body)
        local async = AST.iter'Async'()
        if async then
            LINE(me, [[
#ifdef ceu_out_pending
    if (ceu_out_pending())
#endif
    {
]]..no..[[:
        _STK->trl->evt = CEU_IN__ASYNC;
        _STK->trl->lbl = ]]..me.lbl_asy.id..[[;
]])
            HALT(me, 'RET_ASYNC')
            LINE(me, [[
    }
    case ]]..me.lbl_asy.id..[[:;
]])
            AWAIT_PAUSE(me, no)
        end
        LINE(me, [[
}
]])

        if me.iter_tp == 'org' then
            LINE(me, [[
ceu_pool_iterator_leave(&]]..V(me.var_nxt)..[[);
]])
        end

        if me.has_break and ( not (AST.iter(AST.pred_async)()
                                or AST.iter'Dcl_fun'()) )
        then
            CLEAR_BEF(me)
            CLEAR_AFT(me)
        end
    end,

    Break = function (me)
        LINE(me, 'break;')
    end,

    CallStmt = function (me)
        local call = unpack(me)
        LINE(me, V(call)..';')
    end,

    __emit_ps = function (me)
        local _, e, ps = unpack(me)
        local val = '__ceu_ps_'..me.n
        if ps and #ps>0 then
            local PS = {}
            for _, p in ipairs(ps) do
                PS[#PS+1] = V(p)
            end
            LINE(me, [[
]]..TP.toc((e.var or e).evt.ins)..' '..val..[[;
{
    ]]..TP.toc((e.var or e).evt.ins)..' '..val..[[_ =
        { ]]..table.concat(PS,',')..[[ };
    ]]..val..' = '..val..[[_;
}
]])
                --  tp __ceu_ps_X;
                --  {
                --      tp __ceu_ps_X_ = { ... }    // separate dcl/set because of C++
                --      __ceu_ps_X = __ceu_ps_X_;
                --  }
            val = '(&'..val..')'
        end
        return val
    end,

    EmitExt = function (me)
        local op, e, ps = unpack(me)
        local no = '_CEU_NO_'..me.n..'_'

        local DIR, dir, ptr
        if e.evt.pre == 'input' then
            DIR = 'IN'
            dir = 'in'
            if op == 'call' then
                ptr = '_ceu_app->data'
            else
                ptr = '_ceu_app'
            end
        else
            assert(e.evt.pre == 'output')
            DIR = 'OUT'
            dir = 'out'
            ptr = '_ceu_app'
        end

        local t1 = { }
        if e.evt.pre=='input' and op=='call' then
            t1[#t1+1] = '_ceu_app'  -- to access `app´
            t1[#t1+1] = ptr         -- to access `this´
        end

        local t2 = { ptr, 'CEU_'..DIR..'_'..e.evt.id }

        if ps and #ps>0 then
            local val = F.__emit_ps(me)
            t1[#t1+1] = val
            if op ~= 'call' then
                t2[#t2+1] = 'sizeof('..TP.toc(e.evt.ins)..')'
            end
            t2[#t2+1] = '(void*)'..val
        else
            if dir=='in' then
                t1[#t1+1] = 'NULL'
            end
            if op ~= 'call' then
                t2[#t2+1] = '0'
            end
            t2[#t2+1] = 'NULL'
        end
        t2 = table.concat(t2, ', ')
        t1 = table.concat(t1, ', ')

        local ret_cast = ''
        if OPTS.os and op=='call' then
            -- when the call crosses the process,
            -- the return val must be casted back
            -- TODO: only works for plain values
            if AST.par(me, 'Set') then
                if TP.toc(e.evt.out) == 'int' then
                    ret_cast = '(int)'
                else
                    ret_cast = '(void*)'
                end
            end
        end

        local op = (op=='emit' and 'emit') or 'call'

        local VAL = '\n'..[[
#if defined(ceu_]]..dir..'_'..op..'_'..e.evt.id..[[)
    ceu_]]..dir..'_'..op..'_'..e.evt.id..'('..t1..[[)

#elif defined(ceu_]]..dir..'_'..op..[[)
    (]]..ret_cast..[[ceu_]]..dir..'_'..op..'('..t2..[[))

#else
    #error ceu_]]..dir..'_'..op..[[_* is not defined
#endif
]]

        if not (op=='emit' and e.evt.pre=='input') then
            local set = AST.par(me, 'Set')
            if set then
                local set_to = set[4]
                LINE(me, V(set_to)..' = '..VAL..';')
            else
                LINE(me, VAL..';')
            end
            return
        end

        -------------------------------------------------------------------------------
        -- emit INPUT
        -------------------------------------------------------------------------------

        LINE(me, [[
]]..no..[[:
_STK->trl->evt = CEU_IN__ASYNC;
_STK->trl->lbl = ]]..me.lbl_cnt.id..[[;
]])

        if e[1] == '_WCLOCK' then
            local suf = (ps[1].tm and '_') or ''
            LINE(me, [[
#ifdef CEU_WCLOCKS
{
    u32 __ceu_tmp_]]..me.n..' = '..V(ps[1])..[[;
    ceu_out_go(_ceu_app, CEU_IN__WCLOCK]]..suf..[[, &__ceu_tmp_]]..me.n..[[);
    while (
#if defined(CEU_RET) || defined(CEU_OS)
            _ceu_app->isAlive &&
#endif
            _ceu_app->wclk_min_set]]..suf..[[<=0) {
        s32 __ceu_dt = 0;
        ceu_out_go(_ceu_app, CEU_IN__WCLOCK]]..suf..[[, &__ceu_dt);
    }
}
#endif
]])
        else
            LINE(me, VAL..';')
        end

        LINE(me, [[
#if defined(CEU_RET) || defined(CEU_OS)
if (! _ceu_app->isAlive) {
    return RET_QUIT;
}
#endif
]])
        HALT(me, 'RET_ASYNC')
        LINE(me, [[
case ]]..me.lbl_cnt.id..[[:;
]])
        AWAIT_PAUSE(me, no)
    end,

    EmitInt = function (me)
        local _, int, ps = unpack(me)
        local val = F.__emit_ps(me)

        -- [ ... | me=stk | ... | oth=stk ]
        LINE(me, [[
{
    tceu_stk stk        = *_STK;
_STK->trl++;
    /* create this level to allow incrementing the previous trail traversal */
             stk.evt    = CEU_IN__STK;
             stk.evt_sz = 0;
    stack_push(_ceu_go, &stk, NULL);
}

/* save the continuation to run after the emit */
_STK->trl->evt = CEU_IN__STK;
_STK->trl->lbl = ]]..me.lbl_cnt.id..[[;
_STK->trl->stk = stack_curi(_ceu_go);
   /* awake in the same level as we are now (-1 vs the emit push below) */

/* trigger the event */
{
    tceu_stk stk;
             stk.evt  = ]]..V(int,'ifc_idx')..[[;
#ifdef CEU_ORGS
             stk.evto = (tceu_org*) ]]..((int.org and V(int.org)) or '_STK_ORG')..[[;
#endif
#ifdef CEU_ORGS
             stk.org  = _ceu_app->data;   /* TODO(speed): check if is_ifc */
#endif
             stk.trl  = &_ceu_app->data->trls[0];
#ifdef CEU_CLEAR
             stk.stop = NULL;
#endif
]])
        if ps and #ps>0 then
            LINE(me, [[
            stk.evt_sz = sizeof(*]]..val..[[);
            stack_push(_ceu_go, &stk, ]]..val..[[);
]])
        else
            LINE(me, [[
            stk.evt_sz = 0;
            stack_push(_ceu_go, &stk, NULL);
]])
        end
        LINE(me, [[
}

return RET_RESTART;

case ]]..me.lbl_cnt.id..[[:;
    /* Above push can only awake myself, so I can pop.
     * Have to trl-- to reexecute myself. */
    stack_pop(_ceu_go);
    _STK->trl--;
]])
    end,

    AwaitN = function (me)
        HALT(me)
    end,

    __AwaitInt = function (me)
        local e = unpack(me)
        local org = (e.org and V(e.org)) or '_STK_ORG'
        local no = '_CEU_NO_'..me.n..'_'

        LINE(me, [[
    _STK->trl->seqno =
]])
        if me.isEvery then
            LINE(me, [[
        _ceu_app->seqno-1;   /* always ready to awake */
]])
        else
            LINE(me, [[
        _ceu_app->seqno;    /* not reset with retry */
                            /* (before the label below) */
]])
        end

        LINE(me, [[
]]..no..[[:
    _STK->trl->evt   = ]]..V(e,'ifc_idx')..[[;
    _STK->trl->lbl   = ]]..me.lbl.id..[[;
]])
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
#ifdef CEU_ORGS
    if ((tceu_org*)]]..org..[[ != _STK->evto) {
        _STK->trl->seqno = _ceu_app->seqno-1;   /* awake again */
        goto ]]..no..[[;
    }
#endif
]])
        AWAIT_PAUSE(me, no)
        DEBUG_TRAILS(me)
    end,

    __AwaitExt = function (me)
        local e, dt = unpack(me)
        local no = (dt or AST.iter'Pause'()) and '_CEU_NO_'..me.n..'_'
        local suf = (dt and dt.tm and '_') or ''  -- timemachine "WCLOCK_"

        local val = CUR(me, '__wclk_'..me.n)

        if dt then
            LINE(me, [[
ceu_out_wclock]]..suf..[[(_ceu_app, (s32)]]..V(dt)..[[, &]]..val..[[, NULL);
]])
        end

        LINE(me, [[
]]..(no and no..':' or '')..[[
    _STK->trl->evt   = CEU_IN_]]..e.evt.id..suf..[[;
    _STK->trl->lbl   = ]]..me.lbl.id..[[;
    _STK->trl->seqno =
]])
        if me.isEvery or e.evt.id=='_ok_killed' then
            LINE(me, [[
        _ceu_app->seqno-1;   /* always ready to awake */
]])
        else
            LINE(me, [[
        _ceu_app->seqno;
]])
        end
        HALT(me)

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])
        AWAIT_PAUSE(me, no)

        if dt then
            LINE(me, [[
    /* subtract time and check if I have to awake */
    if (!ceu_out_wclock]]..suf..[[(_ceu_app, *(*((s32**)_STK->evt_buf)), NULL, &]]..val..[[) )
        goto ]]..no..[[;
]])
        end

        DEBUG_TRAILS(me)
    end,

    Await = function (me)
        local e, dt = unpack(me)
        if e.tag == 'Ext' then
            F.__AwaitExt(me)
        else
            F.__AwaitInt(me)
        end

        local set = AST.par(me, 'Set')
        if set then
            local set_to = set[4]
            for i, v in ipairs(set_to) do
                local val
                if dt then
                    local suf = (dt.tm and '_') or ''
                    val = '(_ceu_app->wclk_late'..suf..')'
                elseif e.tag=='Ext' then
                    if e[1] == '_ok_killed' then
                        if TP.tostr(set_to.tp)=='(void*)' then
                            -- ADT
                            val = '(*((tceu_org**)_STK->evt_buf))'
                        else
                            -- ORG
                            val = '(((tceu_org_kill*)_STK->evt_buf))'
                        end
                    else
                        val = '((*(('..TP.toc(me.tp)..'*)_STK->evt_buf))->_'..i..')'
                    end
                else
                    val = '((('..TP.toc(me.tp)..')_STK->evt_buf)->_'..i..')'
                end
                LINE(me, V(v)..' = '..val..';')
            end
        end
    end,

    Async = function (me)
        local vars,blk = unpack(me)
        local no = '_CEU_NO_'..me.n..'_'

        LINE(me, [[
]]..no..[[:
_STK->trl->evt = CEU_IN__ASYNC;
_STK->trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me, 'RET_ASYNC')

        LINE(me, [[
case ]]..me.lbl.id..[[:;
]])
        AWAIT_PAUSE(me, no)
        CONC(me, blk)
    end,

    Thread = function (me)
        local vars,blk = unpack(me)

        -- TODO: transform to Set in the AST?
        if vars then
            for i=1, #vars, 2 do
                local isRef, n = vars[i], vars[i+1]
                if not isRef then
                    LINE(me, V(n.new)..' = '..V(n.var)..';')
                        -- copy async parameters
                end
            end
        end

        -- spawn thread
        LINE(me, [[
/* TODO: test it! */
]]..me.thread_st..[[  = ceu_out_realloc(NULL, sizeof(s8));
*]]..me.thread_st..[[ = 0;  /* ini */
{
    tceu_threads_p p = { _ceu_app, _STK_ORG, ]]..me.thread_st..[[ };
    int ret =
        CEU_THREADS_CREATE(&]]..me.thread_id..[[, _ceu_thread_]]..me.n..[[, &p);
    if (ret == 0)
    {
        int v = CEU_THREADS_DETACH(]]..me.thread_id..[[);
        ceu_out_assert(v == 0, "bug found");
        _ceu_app->threads_n++;

        /* wait for "p" to be copied inside the thread */
        CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);

        while (1) {
            CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
            int ok = (*(p.st) >= 1);   /* cpy ok? */
            if (ok)
                break;
            CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
        }

        /* proceed with sync execution (already locked) */
        *(p.st) = 2;    /* lck: now thread may also execute */
]])

        -- await termination
        local no = '_CEU_NO_'..me.n..'_'
        LINE(me, [[
]]..no..[[:
        _STK->trl->evt = CEU_IN__THREAD;
        _STK->trl->lbl = ]]..me.lbl.id..[[;
]])
        HALT(me)

        -- continue
        LINE(me, [[
case ]]..me.lbl.id..[[:;
        if (*(*((CEU_THREADS_T**)_STK->evt_buf)) != ]]..me.thread_id..[[) {
            goto ]]..no..[[; /* another thread is terminating: await again */
        }
    }
}
]])
        DEBUG_TRAILS(me)

        local set = AST.par(me, 'Set')
        if set then
            local set_to = set[4]
            LINE(me, V(set_to)..' = (*('..me.thread_st..') > 0);')
        end

        -- thread function
        CODE.threads = CODE.threads .. [[
static void* _ceu_thread_]]..me.n..[[ (void* __ceu_p)
{
    /* start thread */

    /* copy param */
    tceu_threads_p _ceu_p = *((tceu_threads_p*) __ceu_p);
    tceu_app* _ceu_app  = _ceu_p.app;
    tceu_org* __ceu_org = _ceu_p.org;

    /* now safe for sync to proceed */
    CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
    *(_ceu_p.st) = 1;
    CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);

    /* ensures that sync reaquires the mutex and terminates
     * the current reaction before I proceed
     * otherwise I could lock below and reenter sync
     */
    while (1) {
        CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
        int ok = (*(_ceu_p.st) >= 2);   /* lck ok? */
        CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
        if (ok)
            break;
    }

    /* body */
    ]]..blk.code..[[

    /* goto from "sync" and already terminated */
    ]]..me.lbl_out.id..[[:

    /* terminate thread */
    {
        CEU_THREADS_T __ceu_thread = CEU_THREADS_SELF();
        void* evtp = &__ceu_thread;
        /*pthread_testcancel();*/
        CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
    /* only if sync is not active */
        if (*(_ceu_p.st) < 3) {             /* 3=end */
            *(_ceu_p.st) = 3;
            ceu_out_go(_ceu_app, CEU_IN__THREAD, evtp);   /* keep locked */
                /* HACK_2:
                 *  A thread never terminates the program because we include an
                 *  <async do end> after it to enforce terminating from the
                 *  main program.
                 */
        } else {
            ceu_out_realloc(_ceu_p.st, 0);  /* fin finished, I free */
            _ceu_app->threads_n--;
        }
        CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
    }

    /* more correct would be two signals:
     * (1) above, when I finish
     * (2) finalizer, when sync finishes
     * now the program may hang if I never reach here
    CEU_THREADS_COND_SIGNAL(&_ceu_app->threads_cond);
     */
    return NULL;
}
]]
    end,

    RawStmt = function (me)
        if me.thread then
            me.thread.thread_st = CUR(me, '__thread_st_'..me.thread.n)
            me.thread.thread_id = CUR(me, '__thread_id_'..me.thread.n)
                -- TODO: ugly, should move to "Thread" node

            me[1] = [[
if (*]]..me.thread.thread_st..[[ < 3) {     /* 3=end */
    *]]..me.thread.thread_st..[[ = 3;
    /*ceu_out_assert( TODO:take-ret-then-assert * pthread_cancel(]]..me.thread.thread_id..[[) == 0 , "bug found");*/
} else {
    ceu_out_realloc(]]..me.thread.thread_st..[[, 0); /* thr finished, I free */
    _ceu_app->threads_n--;
}
]]
        end

        LINE(me, me[1])
    end,

    Lua = function (me)
        local nargs = #me.params

        local set_to
        local nrets
        local set = AST.par(me, 'Set')
        if set then
            set_to = set[4]
            nrets = 1
        else
            nrets = 0
        end

        local lua = string.format('%q', me.lua)
        lua = string.gsub(lua, '\n', 'n') -- undo format for \n
        LINE(me, [[
{
    int err;
    ceu_luaL_loadstring(err,_ceu_app->lua, ]]..lua..[[);
    if (! err) {
]])

        for _, p in ipairs(me.params) do
            ASR(p.tp.id~='@', me, 'unknown type')
            if TP.isNumeric(p.tp) then
                LINE(me, [[
        ceu_lua_pushnumber(_ceu_app->lua,]]..V(p)..[[);
]])
            elseif TP.toc(p.tp)=='char*' then
                LINE(me, [[
        ceu_lua_pushstring(_ceu_app->lua,]]..V(p)..[[);
]])
            elseif p.tp.ptr>0 then
                LINE(me, [[
        ceu_lua_pushlightuserdata(_ceu_app->lua,]]..V(p)..[[);
]])
            else
                error 'not implemented'
            end
        end

        LINE(me, [[
        ceu_lua_pcall(err, _ceu_app->lua, ]]..nargs..','..nrets..[[, 0);
        if (! err) {
]])
        if set then
            if TP.isNumeric(set_to.tp) or set_to.tp=='bool' then
                LINE(me, [[
            int is;
            int ret;
            ceu_lua_isnumber(is, _ceu_app->lua,-1);
            if (is) {
                ceu_lua_tonumber(ret, _ceu_app->lua,-1);
            } else {
                ceu_lua_isboolean(is, _ceu_app->lua,-1);
                if (is) {
                    ceu_lua_toboolean(ret, _ceu_app->lua,-1);
                } else {
                    ceu_lua_pushstring(_ceu_app->lua, "not implemented [1]");
                    err = 1;
                }
            }
            ]]..V(set_to)..[[ = ret;
            ceu_lua_pop(_ceu_app->lua, 1);
]])
            elseif TP.toc(set_to.tp) == 'char*' then
                --ASR(me.ret.var and me.ret.var.tp.arr, me,
                    --'invalid attribution (requires a buffer)')
                LINE(me, [[
            int is;
            ceu_lua_isstring(is, _ceu_app->lua,-1);
            if (is) {
                const char* ret;
                ceu_lua_tostring(ret, _ceu_app->lua,-1);
]])
                local sval = set_to.var and set_to.var.tp.arr and 
                set_to.var.tp.arr.sval
                if sval then
                    LINE(me, 'strncpy('..V(set_to)..', ret, '..(sval-1)..');')
                    LINE(me, V(set_to)..'['..(sval-1).."] = '\\0';")
                else
                    LINE(me, 'strcpy('..V(set_to)..', ret);')
                end
                LINE(me, [[
            } else {
                ceu_lua_pushstring(_ceu_app->lua, "not implemented [2]");
                err = 1;
            }
            ceu_lua_pop(_ceu_app->lua, 1);
]])
            elseif set_to.tp.ptr > 0 then
                LINE(me, [[
            void* ret;
            int is;
            ceu_lua_islightuserdata(is, _ceu_app->lua,-1);
            if (is) {
                ceu_lua_touserdata(ret,_ceu_app->lua,-1);
            } else {
                ceu_lua_pushstring(_ceu_app->lua, "not implemented [3]");
                err = 1;
            }
            ]]..V(set_to)..[[ = ret;
            ceu_lua_pop(_ceu_app->lua, 1);
]])
            else
                error 'not implemented'
            end
        end

        LINE(me, [[
            if (! err) {
                goto _CEU_LUA_OK_]]..me.n..[[;
            }
        }
    }
/* ERROR */
    ceu_lua_error(_ceu_app->lua); /* TODO */

/* OK */
_CEU_LUA_OK_]]..me.n..[[:;
}
]])
    end,

    Sync = function (me)
        local thr = AST.iter'Thread'()
        LINE(me, [[
CEU_THREADS_MUTEX_LOCK(&_ceu_app->threads_mutex);
if (*(_ceu_p.st) == 3) {        /* 3=end */
    CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
    goto ]]..thr.lbl_out.id..[[;   /* exit if ended from "sync" */
} else {                        /* othrewise, execute block */
]])
        CONC(me)
        LINE(me, [[
    CEU_THREADS_MUTEX_UNLOCK(&_ceu_app->threads_mutex);
}
]])
    end,

    Atomic = function (me)
        LINE(me, 'CEU_ISR_ON();')
        CONC(me)
        LINE(me, 'CEU_ISR_OFF();')
    end,
}

AST.visit(F)

end

    --AST.dump(AST.root)
end

local function SUB (str, from, to)
    assert(to, from)
    local i,e = string.find(str, from, 1, true)
    if i then
        return SUB(string.sub(str,1,i-1) .. to .. string.sub(str,e+1),
                   from, to)
    else
        return str
    end
end

local HH, CC

-- TEMPLATE.H
do
    HH = FILES.template_h
    HH = SUB(HH, '#include "ceu_os.h"', FILES.ceu_os_h)

    local tps = { [0]='void', [1]='8', [2]='16', [4]='32' }
    HH = SUB(HH, '=== TCEU_NLBL ===',   's'..tps[TP.types.tceu_nlbl.len])
    HH = SUB(HH, '=== TCEU_NCLS ===',   's'..tps[TP.types.tceu_ncls.len])
    HH = SUB(HH, '=== CEU_NTRAILS ===', MAIN.trails_n)
    --HH = SUB(HH, '=== CLSS_DEFS ===',  MEM.clss)

    -- DEFINES
    do
        local str = ''
        local t = {
            -- props.lua
            has_exts    = 'CEU_EXTS',
            has_wclocks = 'CEU_WCLOCKS',
            has_ints    = 'CEU_INTS',
            has_asyncs  = 'CEU_ASYNCS',
            has_threads = 'CEU_THREADS',
            has_orgs    = 'CEU_ORGS',
            has_orgs_news        = 'CEU_ORGS_NEWS',
            has_orgs_news_pool   = 'CEU_ORGS_NEWS_POOL',
            has_orgs_news_malloc = 'CEU_ORGS_NEWS_MALLOC',
            has_adts_news        = 'CEU_ADTS_NEWS',
            has_adts_news_pool   = 'CEU_ADTS_NEWS_POOL',
            has_adts_news_malloc = 'CEU_ADTS_NEWS_MALLOC',
            has_ifcs    = 'CEU_IFCS',
            has_clear   = 'CEU_CLEAR',
            has_pses    = 'CEU_PSES',
            has_ret     = 'CEU_RET',
            has_lua     = 'CEU_LUA',
            has_orgs_watching = 'CEU_ORGS_WATCHING',
            has_pool_iterator = 'CEU_ORGS_POOL_ITERATOR',
            -- code.lua
            has_goto    = 'CEU_GOTO',
        }
        for k, s in pairs(t) do
            if PROPS[k] or CODE[k] then
                str = str .. '#define ' .. s .. '\n'
            end
        end

        if next(PROPS.has_adts_watching) then
            str = str .. '#define CEU_ADTS_WATCHING\n'
        end
        for id in pairs(PROPS.has_adts_watching) do
            str = str .. '#define CEU_ADTS_WATCHING_' .. id .. '\n'
        end

        -- TODO: goto OPTS
        --str = str .. '#define CEU_DEBUG_TRAILS\n'
        --str = str .. '#define CEU_NOLINES\n'

        if OPTS.os then
            str = str .. [[
#ifndef CEU_OS_APP
#define CEU_OS_APP
#endif
]]
            if OPTS.os_luaifc then
                str = str .. [[
#ifndef CEU_OS_LUAIFC
#define CEU_OS_LUAIFC
#endif
]]
            end
        end

        if OPTS.timemachine then
            str = str .. [[
#ifndef CEU_TIMEMACHINE
#define CEU_TIMEMACHINE
#endif
]]
        end

        if OPTS.run_tests then
            str = str .. '#define CEU_RUNTESTS\n'
        end

        local h = OPTS.out_h
        if OPTS.out_h == '-' then
            h = '_STDIN_H'
        end

        HH = SUB(HH, '=== DEFS_H ===',
                     string.upper(string.gsub(h,'%.','_')))
        HH = SUB(HH, '=== DEFINES ===', str)
    end


    -- EVENTS
    do
        -- inputs: [max_evt+1...) (including _FIN,_WCLOCK,_ASYNC)
        --          cannot overlap w/ internal events
        local str = ''
        local t = {}
        local ins  = 0
        local outs = 0

        -- TODO
        str = str..'#define CEU_IN__NONE 0\n'

        HH = SUB(HH, '=== NATIVE_PRE ===', (OPTS.c_calls and '') or MEM.native_pre)

        for i, evt in ipairs(ENV.exts) do
            if evt.pre == 'input' then
                ins = ins + 1
                evt.n = (256-ins)
                local s = '#define CEU_IN_'..evt.id..' '..evt.n
                if OPTS.verbose and i > 9 then
                    DBG('', s)
                end
                if not (evt.os and OPTS.os) then
                    str = str..s..'\n'
                end
            else
                outs = outs + 1
                evt.n = outs
                local s = '#define CEU_OUT_'..evt.id..' '..evt.n
                if OPTS.verbose then
                    DBG('', s)
                end
                if not (evt.os and OPTS.os) then
                    str = str..s..'\n'
                end
            end
            assert(evt.pre=='input' or evt.pre=='output')
            ASR(ins+outs < 255, me, 'too many events')
        end

        if not OPTS.os then
            str = str..'#define CEU_IN_higher CEU_IN__INIT\n'   -- _INIT = HIGHER EXTERNAL
            str = str..'#define CEU_IN_lower '..(256-ins)..'\n'
        end

        --str = str..'#define CEU_IN_n  '..ins..'\n'
        str = str..'#define CEU_OUT_n '..outs..'\n'

        HH = SUB(HH, '=== EVENTS ===', str)
    end

    -- FUNCTIONS called
    do
        local str = ''
        for id in pairs(ENV.calls) do
            if id ~= '$anon' then
                str = str..'#define CEU_FUN'..id..'\n'
            end
        end
        HH = SUB(HH, '=== FUNCTIONS ===', str)
    end

    -- TUPLES
    do
        local str = ''
        for _,T in pairs(TP.types) do
            if T.tup and #T.tup>0 then
                str = str .. 'typedef struct {\n'
                for i, t in ipairs(T.tup) do
                    local tmp = TP.toc(t)
                    if ENV.clss[t.id] then
                        -- T* => void*
                        -- T** => void**
                        tmp = 'void'..string.match(tmp,'(%*+)')
                    end
                    str = str..'\t'..tmp..' _'..i..';\n'
                end
                str = str .. '} '..TP.toc(T)..';\n'
            end
        end
        HH = SUB(HH, '=== TUPLES ===', str)
    end
end

-- TEMPLATE.C
do
    CC = FILES.template_c

    CC = SUB(CC, '=== FILENAME ===', OPTS.input)
    --CC = SUB(CC, '^#line.-\n', '')

    CC = SUB(CC, '=== LABELS_ENUM ===', LBLS.code_enum)

    CC = SUB(CC, '=== TOPS_DEFS ===',  MEM.tops)   -- TODO: move to HH
    CC = SUB(CC, '=== TOPS_INIT ===',  MEM.tops_init)

    CC = SUB(CC, '=== CONSTRS_C ===',   CODE.constrs)
    CC = SUB(CC, '=== PRES_C ===',      CODE.pres)
    CC = SUB(CC, '=== THREADS_C ===',   CODE.threads)
    CC = SUB(CC, '=== FUNCTIONS_C ===', CODE.functions)
    CC = SUB(CC, '=== STUBS ===',       CODE.stubs)
    CC = SUB(CC, '=== CODE ===',        AST.root.code)
    CC = SUB(CC, '=== NATIVE ===', (OPTS.c_calls and '') or MAIN.native[false])

    -- IFACES
    if PROPS.has_ifcs then
        local CLSS = {}
        local FLDS = {}
        local EVTS = {}
        local FUNS = {}
        local TRLS = {}
        for _, cls in ipairs(ENV.clss_cls) do
            local clss = {}
            local flds = {}
            local evts = {}
            local funs = {}
            local trls = {}
            for i=1, #ENV.ifcs.flds do
                flds[i] = 0
            end
            for i=1, #ENV.ifcs.evts do
                evts[i] = 0
            end
            for i=1, #ENV.ifcs.funs do
                funs[i] = 'NULL'
            end
            for _, var in ipairs(cls.blk_ifc.vars) do
                if var.pre == 'event' then
                    local i = ENV.ifcs.evts[var.ifc_id]
                    if i then
                        evts[i+1] = var.evt.idx
                    end
                elseif var.pre=='var' or var.pre=='pool' then
                    local i = ENV.ifcs.flds[var.ifc_id]
                    if i then
                        flds[i+1] = 'offsetof(CEU_'..cls.id..','..(var.id_ or var.id)..')'
                    end
                elseif var.pre == 'function' then
                    local i = ENV.ifcs.funs[var.ifc_id]
                    if i then
                        funs[i+1] = '(void*)CEU_'..cls.id..'_'..var.id
                    end
                else
                    error 'not implemented'
                end
            end

            -- IFCS_CLSS
            for _,ifc in ipairs(ENV.clss_ifc) do
                clss[#clss+1] = cls.matches[ifc] and 1 or 0
            end

            CLSS[#CLSS+1] = '\t\t{'..table.concat(clss,',')..'}'
            FLDS[#FLDS+1] = '\t\t{'..table.concat(flds,',')..'}'
            EVTS[#EVTS+1] = '\t\t{'..table.concat(evts,',')..'}'
            FUNS[#FUNS+1] = '\t\t{'..table.concat(funs,',')..'}'
            TRLS[#TRLS+1] = '\t\t{'..table.concat(trls,',')..'}'
        end
        CC = SUB(CC, '=== CEU_NCLS ===',     #ENV.clss_cls)
        CC = SUB(CC, '=== IFCS_NIFCS ===',   #ENV.clss_ifc)
        CC = SUB(CC, '=== IFCS_NFLDS ===',   #ENV.ifcs.flds)
        CC = SUB(CC, '=== IFCS_NEVTS ===',   #ENV.ifcs.evts)
        CC = SUB(CC, '=== IFCS_NFUNS ===',   #ENV.ifcs.funs)
        CC = SUB(CC, '=== IFCS_CLSS ===',    table.concat(CLSS,',\n'))
        CC = SUB(CC, '=== IFCS_FLDS ===',    table.concat(FLDS,',\n'))
        CC = SUB(CC, '=== IFCS_EVTS ===',    table.concat(EVTS,',\n'))
        CC = SUB(CC, '=== IFCS_FUNS ===',    table.concat(FUNS,',\n'))
        CC = SUB(CC, '=== IFCS_TRLS ===',    table.concat(TRLS,',\n'))
    end

    if not OPTS.os then
        FILES.ceu_os_c = SUB(FILES.ceu_os_c, '#include "ceu_os.h"',
                                             FILES.ceu_os_h)
        CC = SUB(CC, '#include "ceu_types.h"', FILES.ceu_types_h)
        CC = SUB(CC, '#include "ceu_os.h"',
                     FILES.ceu_os_h..'\n'..FILES.ceu_os_c)
    end

    -- TODO: ceu_pool_* => ceu_sys_pool_*
    FILES.ceu_pool_h = SUB(FILES.ceu_pool_h, '#include "ceu_os.h"',
                                             FILES.ceu_os_h)
    FILES.ceu_pool_c = SUB(FILES.ceu_pool_c, '#include "ceu_pool.h"', '')
    CC = SUB(CC, '#include "ceu_pool.h"',
                         FILES.ceu_pool_h..'\n'..FILES.ceu_pool_c)

    if OPTS.out_s ~= 'CEU_SIZE' then
        CC = SUB(CC, 'CEU_SIZE', OPTS.out_s)
    end
    if OPTS.out_f ~= 'ceu_app_init' then
        CC = SUB(CC, 'ceu_app_init', OPTS.out_f)
    end

    -- app lua interface
    if OPTS.os_luaifc then
        local ifc = ''
        for i, evt in ipairs(ENV.exts) do
            if string.sub(evt.id,1,1) ~= '_' then
                ifc = ifc ..[[
[ ']]..evt.id..[[' ] = {
    ln  = { ']]..evt.ln[1].."', "..evt.ln[2]..[[ },
    pre = ']]..evt.pre..[[',
    n   = ]]..evt.n..[[,
},
]]
            end
        end
        ifc = 'return {\n'..ifc..'}'
        CC = SUB(CC, '=== APP_LUAIFC ===', string.format("%q",ifc))
    end
end

if OPTS.verbose then
    local T = {
        --mem  = AST.root.mem.max,
        evts = ENV.max_evt+#ENV.exts,
        lbls = #LBLS.list,

        trls = AST.root.trails_n,

        exts      = PROPS.has_exts,
        wclocks   = PROPS.has_wclocks,
        ints      = PROPS.has_ints,
        asyncs    = PROPS.has_asyncs,
        orgs      = PROPS.has_orgs,
        orgs_news = PROPS.has_orgs_news,
        ifcs      = PROPS.has_ifcs,
        ret       = PROPS.has_ret,
    }
    local t = {}
    for k, v in pairs(T) do
        if v == true then
            t[#t+1] = k
        elseif v then
            t[#t+1] = k..'='..v
        end
    end
    table.sort(t)
    DBG('[ '..table.concat(t,' | ')..' ]')
end

-- OUTPUT

if OPTS.out_h and OPTS.out_h~='-' then
    local f = assert(io.open(OPTS.out_h,'w'))
    f:write(HH)
    f:close()
end
CC = SUB(CC, '=== OUT_H ===', HH)

local out
if OPTS.out_c == '-' then
    out = io.stdout
else
    out = assert(io.open(OPTS.out_c,'w'))
end
out:write([[
/*
 * This file is automatically generated.
 * Check the github repository for a readable version:
 * http://github.com/fsantanna/ceu
 *
 * Céu is distributed under the MIT License:
 *

Copyright (C) 2012 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
]] .. CC)
out:close()
